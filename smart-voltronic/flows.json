[{"id":"ca0b537221e236b6","type":"tab","label":"‚öôÔ∏è Config","disabled":false,"info":""},{"id":"280951c3196085f3","type":"tab","label":"üîå Voltronic","disabled":false,"info":""},{"id":"296b81230a5aed2a","type":"tab","label":"üì° MQTT","disabled":false,"info":""},{"id":"57656369260fdee6","type":"group","z":"280951c3196085f3","name":"onduleur 1","style":{"label":true},"nodes":["e4d2c8d8e64970ac","32b643591e2b04ed","70182d375061cbef","fd71ee45ebc28f61","286da83a35d93180","2c9a803f94dce0bb","589f82c1423c9842","957af781b779e33e","6294edb213438cd0","4e49dec8b23d003f","71f23c568f360d5b","cdfa7de40dc84703","de354293640c80a3","8558e17ff63073c1","de9aa384c451b6cf","b64df27ef9b2e03f"],"x":14,"y":19,"w":1172,"h":242},{"id":"7ec01c3a3046742d","type":"group","z":"280951c3196085f3","name":"onduleur 2","style":{"label":true},"nodes":["da6ab8ea42e3c773","3771ead040fae605","0cb75a50bfad7cf1","c6db8ec683e40f8c","213e33dc0a23c9f5","79e8ddf5e61d2ba2","1662751f64ba1280","95c044d0fae501bc","c6a6cf11c6876196","3f378285d5efa6bc","152320995f37f3e8","83ef0d7ea356371d","0967f976f3607b87","f75b804e3f323942","4f7d529112896319","361cfd9b7b2c4692","535730443c533ff9"],"x":14,"y":299,"w":1172,"h":262},{"id":"7ded0da774dae4c3","type":"group","z":"280951c3196085f3","name":"onduleur 3","style":{"label":true},"nodes":["f8cd5845ef986b83","9d8b9dae17ecfdd1","5fc4530736e20310","d6de7f12225cc573","e8f00ee886c8b175","80d50b3c6c5325e0","55367afd35b705e1","0df7d5d102daeb53","85e54b63ab62f9c6","55f030bbc6796553","36618809bf6b7d3c"],"x":14,"y":579,"w":972,"h":202},{"id":"fca760cd70eac181","type":"group","z":"296b81230a5aed2a","name":"onduleur 1","style":{"label":true},"nodes":["a21ddb7191f1b93f","a5d5ee44dfe21839","5c73574c1a191af3"],"x":34,"y":39,"w":772,"h":82},{"id":"2ffb0ad1ec6c4336","type":"group","z":"296b81230a5aed2a","name":"onduleur 2","style":{"label":true},"nodes":["9900a8c0b8fb0ade","9fd6ea60084d9aba","423279481f2891e9"],"x":34,"y":159,"w":772,"h":82},{"id":"8b109ad885d98582","type":"group","z":"296b81230a5aed2a","name":"onduleur 3","style":{"label":true},"nodes":["05595a6f316d37e4","b49da1eb9e7aeb60","fd3b9f314f1f6121"],"x":34,"y":279,"w":772,"h":82},{"id":"mqtt_broker","type":"mqtt-broker","name":"HA MQTT Broker","broker":"core-mosquitto","port":"1883","clientid":"","autoConnect":true,"usetls":false,"protocolVersion":"4","keepalive":"60","cleansession":true,"autoUnsubscribe":true,"birthTopic":"","birthQos":"0","birthPayload":"","birthMsg":{},"closeTopic":"","closeQos":"0","closePayload":"","closeMsg":{},"willTopic":"","willQos":"0","willPayload":"","willMsg":{},"userProps":"","sessionExpiry":""},{"id":"c546b54ae425b9d2","type":"serial-port","name":"","serialport":"/dev/serial/by-id/usb-Prolific_Technology_Inc._ATEN_USB_to_Serial_Bridge_EDBNl117620-if00-port0","serialbaud":"2400","databits":"8","parity":"none","stopbits":"1","waitfor":"","dtr":"none","rts":"none","cts":"none","dsr":"none","newline":"\\r","bin":"bin","out":"char","addchar":"","responsetimeout":"3000"},{"id":"55a40ce3e960db15","type":"serial-port","name":"","serialport":"/dev/serial/by-id/usb-Prolific_Technology_Inc._ATEN_USB_to_Serial_Bridge_FNDCb113318-if00-port0","serialbaud":"2400","databits":"8","parity":"none","stopbits":"1","waitfor":"","dtr":"none","rts":"none","cts":"none","dsr":"none","newline":"\\r","bin":"bin","out":"char","addchar":"","responsetimeout":"3000"},{"id":"a70fef526976f555","type":"global-config","env":[],"modules":{"node-red-node-serialport":"2.0.3"}},{"id":"ae5c8da7ec1307dc","type":"inject","z":"ca0b537221e236b6","name":"init config","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":true,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":80,"y":60,"wires":[["f2494e47753be160"]]},{"id":"f2494e47753be160","type":"file in","z":"ca0b537221e236b6","name":"","filename":"/data/options.json","filenameType":"str","format":"utf8","chunk":false,"sendError":false,"encoding":"none","allProps":false,"x":270,"y":60,"wires":[["fa2cedb5d020e0d8"]]},{"id":"fa2cedb5d020e0d8","type":"function","z":"ca0b537221e236b6","name":"parse options","func":"let opts;\ntry {\n  opts = JSON.parse(msg.payload);\n} catch (e) {\n  node.error(\"options.json invalide: \" + e.toString(), msg);\n  node.status({ fill: \"red\", shape: \"ring\", text: \"options.json invalide\" });\n  return null;\n}\n\nconst serialPorts = (opts.serial_ports || [])\n  .filter(p => typeof p === \"string\")\n  .map(p => p.trim())\n  .filter(p => p.length > 0);\n\n// ‚úÖ s√©curit√©: ne pas √©craser une config existante avec une liste vide\nif (serialPorts.length === 0) {\n  const existing = global.get(\"config.serialPorts\") || [];\n  global.set(\"config.invertersCount\", existing.length); // ‚úÖ important\n  node.warn(\"Init: serial_ports vide -> on ne remplace pas la config existante (\" + existing.length + \" port(s))\");\n  node.status({ fill: \"yellow\", shape: \"ring\", text: `serial_ports vide (garde ${existing.length})` });\n  msg.payload = { inverters: existing.length, serialPorts: existing, skipped: true };\n  return msg;\n}\n\nconst mqttConfig = {\n  baseTopic: opts.mqtt_prefix || \"voltronic\",\n  discoveryPrefix: \"homeassistant\",\n  deviceName: \"Onduleur Voltronic\",\n  broker: opts.mqtt_host || \"core-mosquitto\",\n  port: opts.mqtt_port || 1883\n};\n\n// ‚úÖ polling fast robuste\nconst fastSecRaw = (opts.polling_fast ?? opts.polling?.fast ?? 5);\nconst fastSec = Number(fastSecRaw);\nconst pollingFastMs = (Number.isFinite(fastSec) && fastSec > 0 ? fastSec : 5) * 1000;\n\n// ‚úÖ √©crire la config globale\nglobal.set(\"config.serialPorts\", serialPorts);\nglobal.set(\"config.mqtt\", mqttConfig);\nglobal.set(\"config.pollingFastMs\", pollingFastMs);\n\n// ‚úÖ nettoyer d'anciens slots si le nombre de ports a diminu√©\nconst prevCount = global.get(\"config.invertersCount\") || 0;\nfor (let i = serialPorts.length + 1; i <= prevCount; i++) {\n  global.set(`inverter_${i}.port`, null);\n  global.set(`inverter_${i}.data`, {});\n  global.set(`inverter_${i}.lastUpdate`, 0);\n}\nglobal.set(\"config.invertersCount\", serialPorts.length);\n\n// ‚úÖ initialiser autant d'onduleurs que de ports\nfor (let i = 0; i < serialPorts.length; i++) {\n  const inverterNum = i + 1;\n  global.set(`inverter_${inverterNum}.port`, serialPorts[i]);\n  if (!global.get(`inverter_${inverterNum}.data`)) global.set(`inverter_${inverterNum}.data`, {});\n  global.set(`inverter_${inverterNum}.lastUpdate`, 0);\n}\n\nnode.status({\n  fill: \"green\",\n  shape: \"dot\",\n  text: `Config OK (${serialPorts.length} port(s))`\n});\n\nmsg.payload = {\n  inverters: serialPorts.length,\n  serialPorts,\n  mqtt: { broker: mqttConfig.broker, port: mqttConfig.port, baseTopic: mqttConfig.baseTopic },\n  pollingFastMs\n};\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":500,"y":60,"wires":[["20784343c1215897"]]},{"id":"20784343c1215897","type":"debug","z":"ca0b537221e236b6","name":"debug 2","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":680,"y":60,"wires":[]},{"id":"e84f90f9a3664b13","type":"inject","z":"ca0b537221e236b6","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":true,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":90,"y":160,"wires":[["d9dbd753121d3c9a"]]},{"id":"d9dbd753121d3c9a","type":"function","z":"ca0b537221e236b6","name":"function 1","func":"// INIT helpers - √† lancer une fois au d√©marrage\nif (!global.get(\"helpers\")) global.set(\"helpers\", {});\n\nconst helpers = global.get(\"helpers\");\n\nif (typeof helpers.buildVoltronicCommand !== \"function\") {\n  function crc16_xmodem(buf) {\n    let crc = 0x0000;\n    for (const b of buf) {\n      crc ^= (b << 8);\n      for (let i = 0; i < 8; i++) {\n        crc = (crc & 0x8000) ? ((crc << 1) ^ 0x1021) : (crc << 1);\n        crc &= 0xFFFF;\n      }\n    }\n    return crc & 0xFFFF;\n  }\n\n  helpers.buildVoltronicCommand = function (cmd) {\n    cmd = (cmd || \"\").toString().trim();\n    const data = Buffer.from(cmd, \"ascii\");\n    const crc = crc16_xmodem(data);\n    const frame = Buffer.alloc(data.length + 3);\n    data.copy(frame, 0);\n    frame.writeUInt16BE(crc, data.length);\n    frame[frame.length - 1] = 0x0D; // \\r\n    return frame;\n  };\n\n  global.set(\"helpers\", helpers);\n}\n\nnode.status({ fill: \"green\", shape: \"dot\", text: \"helpers OK\" });\nreturn null;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":340,"y":160,"wires":[[]]},{"id":"da6ab8ea42e3c773","type":"serial out","z":"280951c3196085f3","g":"7ec01c3a3046742d","name":"üì§ Serial Out 2","serial":"55a40ce3e960db15","x":1080,"y":400,"wires":[]},{"id":"3771ead040fae605","type":"serial in","z":"280951c3196085f3","g":"7ec01c3a3046742d","name":"üì• Serial In 2","serial":"55a40ce3e960db15","x":130,"y":460,"wires":[["0967f976f3607b87"]]},{"id":"e4d2c8d8e64970ac","type":"function","z":"280951c3196085f3","g":"57656369260fdee6","name":"construire commande ","func":"// ====== CONSTRUIRE COMMANDE (Voltronic) ======\nconst helpers = global.get(\"helpers\");\n\nif (!helpers || typeof helpers.buildVoltronicCommand !== \"function\") {\n  node.error(\"helpers.buildVoltronicCommand introuvable (global.helpers)\");\n  return null;\n}\n\n// R√©cup√®re la commande (priorit√© √† msg.command)\nlet cmd = (msg.command ?? msg._cmd ?? msg.payload ?? \"\").toString().trim().toUpperCase();\n\nif (!cmd) {\n  node.warn(\"Commande vide -> ignor√©e\");\n  return null;\n}\n\n// S√©curit√©: commande uniquement alphanum (Voltronic = lettres/chiffres)\nif (!/^[A-Z0-9]+$/.test(cmd)) {\n  node.warn(`Commande invalide ignor√©e: \"${cmd}\"`);\n  return null;\n}\n\n// Conserver la commande envoy√©e (utile pour associer RX)\nmsg.command = cmd;\nmsg._cmd = cmd;\n\n// Construire la trame (CRC + CR)\nconst buf = helpers.buildVoltronicCommand(cmd);\n\n// Payload = Buffer √† envoyer dans Serial Out\nmsg.payload = buf;\n\n// Debug utile\nmsg._tx_ts = Date.now();\nmsg._tx_ascii = cmd;\nmsg._tx_hex = buf.toString(\"hex\");\n\n// Status (optionnel)\nnode.status({\n  fill: \"blue\",\n  shape: \"dot\",\n  text: `${cmd} ‚Üí ond${msg.inverterNum ?? \"?\"}`\n});\n\n// m√©morise la derni√®re commande par onduleur\nif (msg.inverterNum != null) {\n  flow.set(`inv${msg.inverterNum}_last_cmd`, msg._cmd);\n  flow.set(`inv${msg.inverterNum}_last_cmd_ts`, Date.now());\n}\n\n\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":860,"y":100,"wires":[["32b643591e2b04ed"]]},{"id":"32b643591e2b04ed","type":"serial out","z":"280951c3196085f3","g":"57656369260fdee6","name":"üì§ Serial Out 1","serial":"c546b54ae425b9d2","x":1080,"y":100,"wires":[]},{"id":"70182d375061cbef","type":"serial in","z":"280951c3196085f3","g":"57656369260fdee6","name":"üì• Serial In 1","serial":"c546b54ae425b9d2","x":130,"y":160,"wires":[["2c9a803f94dce0bb"]]},{"id":"fd71ee45ebc28f61","type":"inject","z":"280951c3196085f3","g":"57656369260fdee6","name":"ond1","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"0.5","crontab":"","once":true,"onceDelay":"2","topic":"","payload":"","payloadType":"date","x":110,"y":100,"wires":[["286da83a35d93180"]]},{"id":"286da83a35d93180","type":"function","z":"280951c3196085f3","g":"57656369260fdee6","name":"requetes","func":"// ====== REQUETES (Option A + firstRun + force + QPIGS2 auto-disable + retry 1h) ======\nconst inverterNum = 1;\nconst ts = Date.now();\nconst now = new Date();\n\nconst pad2 = (n) => String(n).padStart(2, \"0\");\nconst yyyy = now.getFullYear();\nconst mm = pad2(now.getMonth() + 1);\nconst dd = pad2(now.getDate());\n\nconst yyyymm = `${yyyy}${mm}`;\nconst yyyymmdd = `${yyyy}${mm}${dd}`;\n\n// √©tat alternance\nlet alt = context.get(\"alt\");\nif (alt === undefined || alt === null) alt = 0;\n\n// firstRun peut rester false si context persistant\nlet firstRun = context.get(\"firstRun\");\nif (firstRun === undefined) firstRun = true;\n\n// Permet de forcer un burst via un inject bouton (msg.forceFirstRun=true)\nif (msg && msg.forceFirstRun === true) {\n  firstRun = true;\n}\n\n// timers\nlet nextQMOD = context.get(\"nextQMOD\");\nlet nextHour = context.get(\"nextHour\");\nlet nextDay10m = context.get(\"nextDay10m\");\nlet nextMonth6 = context.get(\"nextMonth6\");\nlet nextYear24 = context.get(\"nextYear24\");\n\n// >>> NOUVEAUX TIMERS\nlet nextQPIRI = context.get(\"nextQPIRI\");\nlet nextQDOP = context.get(\"nextQDOP\");\n\n// retry QPIGS2 m√™me si d√©sactiv√©\nlet nextRetryQPIGS2 = context.get(\"nextRetryQPIGS2\");\nif (!nextRetryQPIGS2) nextRetryQPIGS2 = ts + 60 * 60 * 1000;\n\nfunction makeCmd(cmd) {\n  return { inverterNum, command: cmd, _cmd: cmd, payload: cmd };\n}\n\nconst msgs = [];\n\n// ----- QPIGS/QPIGS2 strat√©gie -----\nconst supportsQPIGS2 = flow.get(`inv${inverterNum}_supports_qpigs2`);\nconst useQPIGS2 = (supportsQPIGS2 !== false);\n\nfunction pushRealtimeTick() {\n  if (useQPIGS2) {\n    msgs.push(makeCmd(alt === 0 ? \"QPIGS\" : \"QPIGS2\"));\n    alt = alt ? 0 : 1;\n  } else {\n    msgs.push(makeCmd(\"QPIGS\"));\n    if (ts >= nextRetryQPIGS2) {\n      msgs.push(makeCmd(\"QPIGS2\"));\n      nextRetryQPIGS2 = ts + 60 * 60 * 1000;\n    }\n  }\n}\n\n// 1) tick realtime\npushRealtimeTick();\n\n// 2) Burst imm√©diat\nif (firstRun) {\n  const burst = [\n    \"QMOD\",\n    \"QET\", `QEY${yyyy}`, `QEM${yyyymm}`, `QED${yyyymmdd}`,\n    \"QLT\", `QLY${yyyy}`, `QLM${yyyymm}`, `QLD${yyyymmdd}`,\n  ];\n  burst.forEach(c => msgs.push(makeCmd(c)));\n\n  nextQMOD = ts + 5 * 60 * 1000;\n  nextHour = ts + 60 * 60 * 1000;\n  nextDay10m = ts + 10 * 60 * 1000;\n  nextMonth6 = ts + 6 * 60 * 60 * 1000;\n  nextYear24 = ts + 24 * 60 * 60 * 1000;\n\n  // >>> INIT QPIRI + QDOP\n  nextQPIRI = ts + 5 * 60 * 1000;\n  nextQDOP = ts + 5 * 60 * 1000;\n\n  firstRun = false;\n  node.status({ fill: \"green\", shape: \"dot\", text: `FIRST RUN: ${msgs.length} cmds` });\n\n} else {\n\n  // QMOD 5 min\n  if (nextQMOD == null) nextQMOD = ts + 5 * 60 * 1000;\n  if (ts >= nextQMOD) {\n    msgs.push(makeCmd(\"QMOD\"));\n    nextQMOD = ts + 5 * 60 * 1000;\n  }\n\n  // >>> QPIRI 5 min\n  if (nextQPIRI == null) nextQPIRI = ts + 5 * 60 * 1000;\n  if (ts >= nextQPIRI) {\n    msgs.push(makeCmd(\"QPIRI\"));\n    nextQPIRI = ts + 5 * 60 * 1000;\n  }\n\n  // >>> QDOP 5 min\n  if (nextQDOP == null) nextQDOP = ts + 5 * 60 * 1000;\n  if (ts >= nextQDOP) {\n    msgs.push(makeCmd(\"QDOP\"));\n    nextQDOP = ts + 5 * 60 * 1000;\n  }\n\n  // Hourly\n  if (nextHour == null) nextHour = ts + 60 * 60 * 1000;\n  if (ts >= nextHour) {\n    msgs.push(makeCmd(\"QET\"));\n    msgs.push(makeCmd(\"QLT\"));\n    nextHour = ts + 60 * 60 * 1000;\n  }\n\n  // Daily 10min\n  if (nextDay10m == null) nextDay10m = ts + 10 * 60 * 1000;\n  if (ts >= nextDay10m) {\n    msgs.push(makeCmd(`QED${yyyymmdd}`));\n    msgs.push(makeCmd(`QLD${yyyymmdd}`));\n    nextDay10m = ts + 10 * 60 * 1000;\n  }\n\n  // Monthly 6h\n  if (nextMonth6 == null) nextMonth6 = ts + 6 * 60 * 60 * 1000;\n  if (ts >= nextMonth6) {\n    msgs.push(makeCmd(`QEM${yyyymm}`));\n    msgs.push(makeCmd(`QLM${yyyymm}`));\n    nextMonth6 = ts + 6 * 60 * 60 * 1000;\n  }\n\n  // Yearly 24h\n  if (nextYear24 == null) nextYear24 = ts + 24 * 60 * 60 * 1000;\n  if (ts >= nextYear24) {\n    msgs.push(makeCmd(`QEY${yyyy}`));\n    msgs.push(makeCmd(`QLY${yyyy}`));\n    nextYear24 = ts + 24 * 60 * 60 * 1000;\n  }\n}\n\n// save\ncontext.set(\"alt\", alt);\ncontext.set(\"firstRun\", firstRun);\ncontext.set(\"nextQMOD\", nextQMOD);\ncontext.set(\"nextHour\", nextHour);\ncontext.set(\"nextDay10m\", nextDay10m);\ncontext.set(\"nextMonth6\", nextMonth6);\ncontext.set(\"nextYear24\", nextYear24);\ncontext.set(\"nextQPIRI\", nextQPIRI);\ncontext.set(\"nextQDOP\", nextQDOP);\ncontext.set(\"nextRetryQPIGS2\", nextRetryQPIGS2);\n\nreturn [msgs];\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":240,"y":100,"wires":[["4e49dec8b23d003f"]]},{"id":"2c9a803f94dce0bb","type":"function","z":"280951c3196085f3","g":"57656369260fdee6","name":"parser 1","func":"// ====== PARSER 1 (Voltronic) - QUEUE MODE ======\n// Entr√©e: msg.payload = Buffer (Serial IN en \"a single buffer\", pas de split)\n// Sorties:\n//   1) trigger pump (msg.topic=\"pump\")\n//   2) data pars√©e (vers normalize state)\n// Associe la r√©ponse √† la commande \"inflight\" (envoy√©e par Queue Pump)\n\nconst inv = msg.inverterNum ?? 1;\nif (!Buffer.isBuffer(msg.payload)) return null;\n\n// --- accumulateur RX ---\nlet rx = context.get(\"rxbuf\");\nif (!Buffer.isBuffer(rx)) rx = Buffer.alloc(0);\n\n// s√©curit√© overflow\nif (rx.length > 8192) rx = Buffer.alloc(0);\n\n// concat\nrx = Buffer.concat([rx, msg.payload]);\n\nconst CR = 0x0D;\n\n// extrait toutes les frames finissant par CR\nconst frames = [];\nwhile (true) {\n  const idx = rx.indexOf(CR);\n  if (idx === -1) break;\n  frames.push(rx.slice(0, idx + 1));\n  rx = rx.slice(idx + 1);\n}\ncontext.set(\"rxbuf\", rx);\n\nif (!frames.length) return null;\n\n// commande inflight (celle r√©ellement envoy√©e)\nconst inflightKey = `inv${inv}_inflight`;\nconst inflight = flow.get(inflightKey);\nconst inflightCmd = inflight?.cmd || \"UNKNOWN\";\n\n// Nettoyage trame -> ASCII sans CRC/CR\nfunction cleanAsciiFromFrame(frameBuf) {\n  // NAK brut possible (0x15)\n  if (frameBuf.length === 1 && frameBuf[0] === 0x15) return \"NAK\";\n\n  // Normalement: <data ASCII> + <CRC 2 bytes> + <CR>\n  let dataBuf = frameBuf;\n\n  if (frameBuf.length >= 3 && frameBuf[frameBuf.length - 1] === CR) {\n    dataBuf = frameBuf.slice(0, -3); // retire CRC(2) + CR(1)\n  } else if (frameBuf.length >= 1 && frameBuf[frameBuf.length - 1] === CR) {\n    dataBuf = frameBuf.slice(0, -1); // fallback retire CR\n  }\n\n  return dataBuf.toString(\"ascii\");\n}\n\nfunction parseFrame(frameBuf, cmd) {\n  const ascii = cleanAsciiFromFrame(frameBuf);\n\n  // D√©tection NAK \"NAK\" ou 0x15\n  if (ascii.includes(\"NAK\") || ascii === \"NAK\") {\n    return {\n      inverter: inv,\n      command: cmd,\n      nak: true,\n      raw: \"NAK\",\n      fields: [],\n      nums: [],\n      value: null\n    };\n  }\n\n  // Enlever parenth√®ses si pr√©sentes\n  let body = ascii.trim();\n  if (body.startsWith(\"(\")) body = body.slice(1);\n  if (body.endsWith(\")\")) body = body.slice(0, -1);\n  body = body.trim();\n\n  const fields = body.length ? body.split(/\\s+/) : [];\n  const nums = fields.map(v => {\n    const n = Number(v);\n    return Number.isFinite(n) ? n : null;\n  });\n\n  // Cas √©nergie (1 valeur)\n  const isEnergyCmd = /^Q(E[TYMD]|L[TYMD])/.test(cmd);\n  let value = null;\n  if (isEnergyCmd && fields.length >= 1) {\n    const n0 = Number(fields[0]);\n    if (Number.isFinite(n0)) value = n0;\n  }\n\n  return {\n    inverter: inv,\n    command: cmd,\n    raw: body,\n    fields,\n    nums,\n    value\n  };\n}\n\n// Ici, on part du principe QUEUE = 1 commande envoy√©e -> 1 r√©ponse attendue.\n// Mais on g√®re quand m√™me le cas \"plusieurs frames d'un coup\" :\n// - 1√®re frame = inflightCmd\n// - frames suivantes = UNKNOWN (ou on garde inflightCmd si tu pr√©f√®res)\nconst outMsgs = [];\nfor (let i = 0; i < frames.length; i++) {\n  const cmd = (i === 0) ? inflightCmd : \"UNKNOWN\";\n  outMsgs.push({\n    inverterNum: inv,\n    _cmd: cmd,\n    command: cmd,\n    payload: parseFrame(frames[i], cmd),\n    _rx_ts: Date.now()\n  });\n}\n\n// ACK : d√®s qu'on re√ßoit au moins une frame, on lib√®re inflight\nflow.set(inflightKey, null);\n\n// Trigger pump imm√©diatement (pour envoyer la prochaine commande)\nconst pumpMsg = { inverterNum: inv, topic: \"pump\" };\n\n// Sortie 1: pump trigger\n// Sortie 2: data pars√©e (plusieurs messages possibles)\nreturn [[pumpMsg], outMsgs];\n","outputs":2,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":280,"y":160,"wires":[["71f23c568f360d5b"],["957af781b779e33e"]]},{"id":"589f82c1423c9842","type":"mqtt out","z":"280951c3196085f3","g":"57656369260fdee6","name":"ond1","topic":"","qos":"0","retain":"","respTopic":"","contentType":"","userProps":"","correl":"","expiry":"","broker":"mqtt_broker","x":910,"y":160,"wires":[]},{"id":"957af781b779e33e","type":"function","z":"280951c3196085f3","g":"57656369260fdee6","name":"normalize state","func":"// ====== NORMALIZE STATE (AUTO / MULTI-MODEL) - FIX ENERGIES TODAY ======\nif (!msg.payload || typeof msg.payload !== \"object\") return null;\n\nconst inv = msg.inverterNum ?? msg.payload.inverter ?? 1;\n\n// ‚úÖ FIX MINIMAL: normaliser la commande (√©vite \"QPIRI\\r\", \"qpiri\", \"QPIRI \")\nconst cmd = String(msg.payload.command || msg.command || msg._cmd || \"UNKNOWN\")\n  .trim()\n  .toUpperCase();\n\nconst f = Array.isArray(msg.payload.fields) ? msg.payload.fields : [];\nconst n = Array.isArray(msg.payload.nums) ? msg.payload.nums : [];\nconst value = msg.payload.value;\n\nlet state = context.get(\"state\");\nif (!state || typeof state !== \"object\") state = {};\n\n// helpers\nconst num = (idx) => (Number.isFinite(n[idx]) ? n[idx] : null);\nconst int = (idx) => {\n  const v = num(idx);\n  return v == null ? null : Math.trunc(v);\n};\n\n// --- apprentissage index pv1_power par node (donc par inverter) ---\nlet pv1PowerIdx = context.get(\"pv1PowerIdx\"); // m√©moris√© par node\n\n// ===== QPIGS =====\nif (cmd === \"QPIGS\" && f.length >= 16) {\n\n  // Champs communs (tr√®s stables)\n  if (f.length > 0) state.grid_voltage = num(0);\n  if (f.length > 1) state.grid_frequency = num(1);\n  if (f.length > 2) state.ac_output_voltage = num(2);\n  if (f.length > 3) state.ac_output_frequency = num(3);\n\n  // Apparent/active/load : souvent 4/5/6\n  if (f.length > 5) state.ac_output_active_power = int(5);\n  if (f.length > 6) state.output_load_percent = int(6);\n\n  // bus voltage : souvent 7\n  if (f.length > 7) state.bus_voltage = int(7);\n\n  // Batterie : souvent 8/9/10/11\n  if (f.length > 8) state.battery_voltage = num(8);\n  if (f.length > 9) state.battery_charging_current = int(9);\n  if (f.length > 10) state.battery_capacity = int(10);\n  if (f.length > 11) state.inverter_heat_sink_temp = int(11);\n\n  // PV entr√©e : souvent 12/13\n  if (f.length > 12) state.pv1_input_current = num(12);\n  if (f.length > 13) state.pv1_input_voltage = num(13);\n\n  // Discharge current : souvent 15\n  if (f.length > 15) state.battery_discharge_current = int(15);\n\n  // ---- PV1 Power : auto\n  // 1) si on a d√©j√† appris l‚Äôindex, on l‚Äôutilise\n  if (pv1PowerIdx != null && f.length > pv1PowerIdx) {\n    state.pv1_power = int(pv1PowerIdx);\n  } else {\n    // 2) sinon on tente des index connus\n    const candidates = [19, 20, 18, 17, 16]; // couvre variantes connues\n    for (const idx of candidates) {\n      if (f.length > idx && Number.isFinite(n[idx])) {\n        const I = state.pv1_input_current;\n        const V = state.pv1_input_voltage;\n        const pCalc = (Number.isFinite(I) && Number.isFinite(V)) ? (I * V) : null;\n        const pField = n[idx];\n\n        // si on a I et V : on valide si proche (+/- 20%)\n        if (pCalc != null && pCalc > 10) {\n          const ratio = pField / pCalc;\n          if (ratio > 0.8 && ratio < 1.2) {\n            pv1PowerIdx = idx;\n            context.set(\"pv1PowerIdx\", pv1PowerIdx);\n            state.pv1_power = int(idx);\n            break;\n          }\n        } else {\n          // fallback : on choisit l'index le plus probable\n          if (idx === 19) {\n            state.pv1_power = int(19);\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  state._last_qpigs_ts = Date.now();\n}\n\n// ===== QPIGS2 (optionnel) =====\nif (cmd === \"QPIGS2\" && f.length >= 3) {\n  state.pv2_input_current = num(0);\n  state.pv2_input_voltage = num(1);\n  state.pv2_power = int(2);\n  state._last_qpigs2_ts = Date.now();\n}\n\n// ===== QMOD =====\nif (cmd === \"QMOD\") {\n  const rawMode = (f[0] ?? msg.payload.raw ?? \"\").toString().trim();\n  const modeMap = { P: \"Power On\", S: \"Standby\", L: \"Grid\", B: \"Battery\", F: \"Fault\" };\n  state.operation_mode = modeMap[rawMode] || rawMode || null;\n  state.operation_mode_code = rawMode || null;\n  state._last_qmod_ts = Date.now();\n}\n\n// ===== QPIRI -> PARAMETRES (bloc s√©par√©) =====\nif (cmd === \"QPIRI\" && msg.payload?.nak !== true) {\n  const nf = (idx) => {\n    const v = (f && f.length > idx) ? f[idx] : null;\n    const nn = Number(v);\n    return Number.isFinite(nn) ? nn : null;\n  };\n\n  const mapBatteryType = (code) => {\n    const m = {\n      0: \"AGM\",\n      1: \"Flooded\",\n      2: \"User\",\n      3: \"Pylon\",\n      5: \"Weco\",\n      6: \"Soltaro\",\n      8: \"Lib\",\n      9: \"Lic\"\n    };\n    return m[code] ?? String(code ?? \"\");\n  };\n\n  const mapOutputPriority = (code) => {\n    const m = { 0: \"UtilitySolarBat\", 1: \"SolarUtilityBat\", 2: \"SolarBatUtility\" };\n    return m[code] ?? String(code ?? \"\");\n  };\n\n  const mapChargerPriority = (code) => {\n    const m = { 1: \"Solar first\", 2: \"Solar + Utility\", 3: \"Only solar\" };\n    return m[code] ?? String(code ?? \"\");\n  };\n\n  if (!state.params || typeof state.params !== \"object\") state.params = {};\n\n  const battTypeCode = nf(12);\n  const outPrioCode = nf(16);\n  const chgPrioCode = nf(17);\n\n  state.params.qpiri = {\n    battery_recharge_voltage: nf(8),\n    battery_under_voltage: nf(9),\n    battery_bulk_voltage: nf(10),\n    battery_float_voltage: nf(11),\n\n    battery_type_code: battTypeCode,\n    battery_type: mapBatteryType(battTypeCode),\n\n    max_ac_charging_current: nf(13),\n    max_charging_current: nf(14),\n\n    output_source_priority_code: outPrioCode,\n    output_source_priority: mapOutputPriority(outPrioCode),\n\n    charger_source_priority_code: chgPrioCode,\n    charger_source_priority: mapChargerPriority(chgPrioCode),\n\n    battery_re_discharge_voltage: nf(22),\n    max_discharging_current: nf(27),\n\n    ts: Date.now()\n  };\n\n  state._last_qpiri_ts = Date.now();\n}\n\n// ===== QDOP -> PARAMETRES batterie (%) (3 champs seulement) =====\nif (cmd === \"QDOP\" && msg.payload?.nak !== true) {\n  const nf = (idx) => {\n    const v = (f && f.length > idx) ? f[idx] : null;\n    const nn = Number(v);\n    return Number.isFinite(nn) ? nn : null;\n  };\n\n  if (!state.params || typeof state.params !== \"object\") state.params = {};\n\n  state.params.qdop = {\n    battery_recharge_capacity_pct: nf(8),      // iii\n    battery_redischarge_capacity_pct: nf(9),   // jjj\n    battery_under_capacity_pct: nf(10),        // kkk\n    ts: Date.now()\n  };\n\n  state._last_qdop_ts = Date.now();\n}\n\n// ===== Support QPIGS2 (diagnostic) =====\nconst supportsKey = `inv${inv}_supports_qpigs2`;\nconst supports = flow.get(supportsKey);\nif (supports !== undefined) state.supports_qpigs2 = (supports !== false);\n\n// ===== ENERGIES (FIX Today) =====\nconst round2 = (v) => (v == null ? null : Math.round(v * 100) / 100);\n\n// Today est (chez toi) en Wh -> kWh\nconst toKwhToday = (v) => (!Number.isFinite(v) ? null : round2(v / 1000));\n\n// Total/Month/Year: mix firmwares -> auto (Wh si gros)\nconst toKwhAuto = (v) => (!Number.isFinite(v) ? null : (v >= 10000 ? round2(v / 1000) : round2(v)));\n\nif (Number.isFinite(value)) {\n  // PV\n  if (cmd === \"QET\") { state.pv_energy_total_raw = value; state.pv_energy_total_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QEY\")) { state.pv_energy_year_raw = value; state.pv_energy_year_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QEM\")) { state.pv_energy_month_raw = value; state.pv_energy_month_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QED\")) { state.pv_energy_day_raw = value; state.pv_energy_day_kwh = toKwhToday(value); }\n\n  // LOAD\n  if (cmd === \"QLT\") { state.load_energy_total_raw = value; state.load_energy_total_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QLY\")) { state.load_energy_year_raw = value; state.load_energy_year_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QLM\")) { state.load_energy_month_raw = value; state.load_energy_month_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QLD\")) { state.load_energy_day_raw = value; state.load_energy_day_kwh = toKwhToday(value); }\n\n  state._last_energy_ts = Date.now();\n}\n\n// ===== PV total power =====\nconst pv1 = Number.isFinite(state.pv1_power) ? state.pv1_power : 0;\nconst pv2 = Number.isFinite(state.pv2_power) ? state.pv2_power : 0;\nstate.pv_total_power = pv1 + pv2;\n\n// ===== BATTERY POWER (W) - CUSTOM SENSORS =====\nconst Vb = Number.isFinite(state.battery_voltage) ? state.battery_voltage : null;\nconst Ichg = Number.isFinite(state.battery_charging_current) ? state.battery_charging_current : 0;\nconst Idis = Number.isFinite(state.battery_discharge_current) ? state.battery_discharge_current : 0;\n\nif (Vb != null) {\n  const chargeW = Math.round(Vb * Math.max(0, Ichg));\n  const dischargeW = Math.round(Vb * Math.max(0, Idis));\n\n  // Noms demand√©s\n  state.battery_charge = chargeW;              // +W\n  state.battery_discharge = dischargeW;        // +W\n  state.battery_power = chargeW - dischargeW;  // + charge / - d√©charge\n} else {\n  state.battery_charge = null;\n  state.battery_discharge = null;\n  state.battery_power = null;\n}\n\ncontext.set(\"state\", state);\nmsg.inverterNum = inv;\nmsg.payload = state;\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":500,"y":160,"wires":[["6294edb213438cd0"]]},{"id":"6294edb213438cd0","type":"function","z":"280951c3196085f3","g":"57656369260fdee6","name":"MQTT state publisher","func":"if (!msg.payload || typeof msg.payload !== \"object\") return null;\n\nconst inv = msg.inverterNum ?? 1;\n\nreturn [\n    {\n        topic: `voltronic/${inv}/state`,\n        payload: JSON.stringify(msg.payload),\n        retain: false\n    },\n    {\n        topic: `voltronic/${inv}/availability`,\n        payload: \"online\",\n        retain: true\n    }\n];\n","outputs":2,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":720,"y":160,"wires":[["589f82c1423c9842"],["589f82c1423c9842"]]},{"id":"4e49dec8b23d003f","type":"function","z":"280951c3196085f3","g":"57656369260fdee6","name":"Queue Enqueue","func":"const inv = msg.inverterNum ?? 1;\nconst key = `inv${inv}_queue`;\n\nlet q = flow.get(key);\nif (!Array.isArray(q)) q = [];\n\n// msg peut √™tre 1 commande, ou un lot (si tu envoies [msgs])\n// Ici, on g√®re les deux cas proprement.\nconst toPush = [];\n\nif (Array.isArray(msg)) {\n    // rare : si tu envoies direct un tableau de msgs\n    toPush.push(...msg);\n} else if (Array.isArray(msg.payload) && msg.payload?.[0]?.command) {\n    // si jamais ton flow passe un tableau dans payload\n    toPush.push(...msg.payload);\n} else {\n    // msg normal\n    toPush.push(msg);\n}\n\n// ajoute uniquement si on a une commande\ntoPush.forEach(m => {\n    const cmd = (m.command || m._cmd || m.payload || \"\").toString().trim().toUpperCase();\n    if (!cmd) return;\n\n    q.push({\n        inverterNum: inv,\n        command: cmd,\n        _cmd: cmd,\n        payload: cmd,\n        enqueued_ts: Date.now()\n    });\n});\n\n// limite taille\nif (q.length > 200) q = q.slice(-200);\n\nflow.set(key, q);\n\n// d√©clenche le pump\nreturn { inverterNum: inv, topic: \"pump\" };\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":420,"y":100,"wires":[["71f23c568f360d5b"]]},{"id":"71f23c568f360d5b","type":"function","z":"280951c3196085f3","g":"57656369260fdee6","name":"Queue Pump","func":"const inv = msg.inverterNum ?? 1;\n\nconst qKey = `inv${inv}_queue`;\nconst inFlightKey = `inv${inv}_inflight`;\n\nlet inFlight = flow.get(inFlightKey);\n\n// Si une commande est d√©j√† en attente de r√©ponse, on n‚Äôen envoie pas une autre\nif (inFlight && (Date.now() - (inFlight.ts || 0)) < 3000) {\n  return null;\n}\n\nlet q = flow.get(qKey);\nif (!Array.isArray(q) || q.length === 0) return null;\n\n// Prend la prochaine commande\nconst next = q.shift();\nflow.set(qKey, q);\n\n// Marque comme en vol\nflow.set(inFlightKey, { cmd: next.command, ts: Date.now() });\n\n// Envoie au construire commande\nreturn next;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":650,"y":120,"wires":[["e4d2c8d8e64970ac"]]},{"id":"cdfa7de40dc84703","type":"inject","z":"280951c3196085f3","g":"57656369260fdee6","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"2","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":650,"y":80,"wires":[["71f23c568f360d5b"]]},{"id":"0cb75a50bfad7cf1","type":"function","z":"280951c3196085f3","g":"7ec01c3a3046742d","name":"construire commande ","func":"// ====== CONSTRUIRE COMMANDE (Voltronic) ======\nconst helpers = global.get(\"helpers\");\n\nif (!helpers || typeof helpers.buildVoltronicCommand !== \"function\") {\n  node.error(\"helpers.buildVoltronicCommand introuvable (global.helpers)\");\n  return null;\n}\n\n// R√©cup√®re la commande (priorit√© √† msg.command)\nlet cmd = (msg.command ?? msg._cmd ?? msg.payload ?? \"\").toString().trim().toUpperCase();\n\nif (!cmd) {\n  node.warn(\"Commande vide -> ignor√©e\");\n  return null;\n}\n\n// S√©curit√©: commande uniquement alphanum (Voltronic = lettres/chiffres)\nif (!/^[A-Z0-9]+$/.test(cmd)) {\n  node.warn(`Commande invalide ignor√©e: \"${cmd}\"`);\n  return null;\n}\n\n// Conserver la commande envoy√©e (utile pour associer RX)\nmsg.command = cmd;\nmsg._cmd = cmd;\n\n// Construire la trame (CRC + CR)\nconst buf = helpers.buildVoltronicCommand(cmd);\n\n// Payload = Buffer √† envoyer dans Serial Out\nmsg.payload = buf;\n\n// Debug utile\nmsg._tx_ts = Date.now();\nmsg._tx_ascii = cmd;\nmsg._tx_hex = buf.toString(\"hex\");\n\n// Status (optionnel)\nnode.status({\n  fill: \"blue\",\n  shape: \"dot\",\n  text: `${cmd} ‚Üí ond${msg.inverterNum ?? \"?\"}`\n});\n\n// m√©morise la derni√®re commande par onduleur\nif (msg.inverterNum != null) {\n  flow.set(`inv${msg.inverterNum}_last_cmd`, msg._cmd);\n  flow.set(`inv${msg.inverterNum}_last_cmd_ts`, Date.now());\n}\n\n\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":860,"y":400,"wires":[["da6ab8ea42e3c773"]]},{"id":"c6db8ec683e40f8c","type":"inject","z":"280951c3196085f3","g":"7ec01c3a3046742d","name":"ond2","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"0.5","crontab":"","once":true,"onceDelay":"2","topic":"","payload":"","payloadType":"date","x":110,"y":400,"wires":[["213e33dc0a23c9f5"]]},{"id":"213e33dc0a23c9f5","type":"function","z":"280951c3196085f3","g":"7ec01c3a3046742d","name":"requetes","func":"// ====== REQUETES (Option A + firstRun + force + QPIGS2 auto-disable + retry 1h) ======\nconst inverterNum = 2;\nconst ts = Date.now();\nconst now = new Date();\n\nconst pad2 = (n) => String(n).padStart(2, \"0\");\nconst yyyy = now.getFullYear();\nconst mm = pad2(now.getMonth() + 1);\nconst dd = pad2(now.getDate());\n\nconst yyyymm = `${yyyy}${mm}`;\nconst yyyymmdd = `${yyyy}${mm}${dd}`;\n\n// √©tat alternance\nlet alt = context.get(\"alt\");\nif (alt === undefined || alt === null) alt = 0;\n\n// firstRun peut rester false si context persistant\nlet firstRun = context.get(\"firstRun\");\nif (firstRun === undefined) firstRun = true;\n\n// Permet de forcer un burst via un inject bouton (msg.forceFirstRun=true)\nif (msg && msg.forceFirstRun === true) {\n  firstRun = true;\n}\n\n// timers\nlet nextQMOD = context.get(\"nextQMOD\");\nlet nextHour = context.get(\"nextHour\");\nlet nextDay10m = context.get(\"nextDay10m\");\nlet nextMonth6 = context.get(\"nextMonth6\");\nlet nextYear24 = context.get(\"nextYear24\");\n\n// >>> NOUVEAUX TIMERS\nlet nextQPIRI = context.get(\"nextQPIRI\");\nlet nextQDOP = context.get(\"nextQDOP\");\n\n// retry QPIGS2 m√™me si d√©sactiv√©\nlet nextRetryQPIGS2 = context.get(\"nextRetryQPIGS2\");\nif (!nextRetryQPIGS2) nextRetryQPIGS2 = ts + 60 * 60 * 1000;\n\nfunction makeCmd(cmd) {\n  return { inverterNum, command: cmd, _cmd: cmd, payload: cmd };\n}\n\nconst msgs = [];\n\n// ----- QPIGS/QPIGS2 strat√©gie -----\nconst supportsQPIGS2 = flow.get(`inv${inverterNum}_supports_qpigs2`);\nconst useQPIGS2 = (supportsQPIGS2 !== false);\n\nfunction pushRealtimeTick() {\n  if (useQPIGS2) {\n    msgs.push(makeCmd(alt === 0 ? \"QPIGS\" : \"QPIGS2\"));\n    alt = alt ? 0 : 1;\n  } else {\n    msgs.push(makeCmd(\"QPIGS\"));\n    if (ts >= nextRetryQPIGS2) {\n      msgs.push(makeCmd(\"QPIGS2\"));\n      nextRetryQPIGS2 = ts + 60 * 60 * 1000;\n    }\n  }\n}\n\n// 1) tick realtime\npushRealtimeTick();\n\n// 2) Burst imm√©diat\nif (firstRun) {\n  const burst = [\n    \"QMOD\",\n    \"QET\", `QEY${yyyy}`, `QEM${yyyymm}`, `QED${yyyymmdd}`,\n    \"QLT\", `QLY${yyyy}`, `QLM${yyyymm}`, `QLD${yyyymmdd}`,\n  ];\n  burst.forEach(c => msgs.push(makeCmd(c)));\n\n  nextQMOD = ts + 5 * 60 * 1000;\n  nextHour = ts + 60 * 60 * 1000;\n  nextDay10m = ts + 10 * 60 * 1000;\n  nextMonth6 = ts + 6 * 60 * 60 * 1000;\n  nextYear24 = ts + 24 * 60 * 60 * 1000;\n\n  // >>> INIT QPIRI + QDOP\n  nextQPIRI = ts + 5 * 60 * 1000;\n  nextQDOP = ts + 5 * 60 * 1000;\n\n  firstRun = false;\n  node.status({ fill: \"green\", shape: \"dot\", text: `FIRST RUN: ${msgs.length} cmds` });\n\n} else {\n\n  // QMOD 5 min\n  if (nextQMOD == null) nextQMOD = ts + 5 * 60 * 1000;\n  if (ts >= nextQMOD) {\n    msgs.push(makeCmd(\"QMOD\"));\n    nextQMOD = ts + 5 * 60 * 1000;\n  }\n\n  // >>> QPIRI 5 min\n  if (nextQPIRI == null) nextQPIRI = ts + 5 * 60 * 1000;\n  if (ts >= nextQPIRI) {\n    msgs.push(makeCmd(\"QPIRI\"));\n    nextQPIRI = ts + 5 * 60 * 1000;\n  }\n\n  // >>> QDOP 5 min\n  if (nextQDOP == null) nextQDOP = ts + 5 * 60 * 1000;\n  if (ts >= nextQDOP) {\n    msgs.push(makeCmd(\"QDOP\"));\n    nextQDOP = ts + 5 * 60 * 1000;\n  }\n\n  // Hourly\n  if (nextHour == null) nextHour = ts + 60 * 60 * 1000;\n  if (ts >= nextHour) {\n    msgs.push(makeCmd(\"QET\"));\n    msgs.push(makeCmd(\"QLT\"));\n    nextHour = ts + 60 * 60 * 1000;\n  }\n\n  // Daily 10min\n  if (nextDay10m == null) nextDay10m = ts + 10 * 60 * 1000;\n  if (ts >= nextDay10m) {\n    msgs.push(makeCmd(`QED${yyyymmdd}`));\n    msgs.push(makeCmd(`QLD${yyyymmdd}`));\n    nextDay10m = ts + 10 * 60 * 1000;\n  }\n\n  // Monthly 6h\n  if (nextMonth6 == null) nextMonth6 = ts + 6 * 60 * 60 * 1000;\n  if (ts >= nextMonth6) {\n    msgs.push(makeCmd(`QEM${yyyymm}`));\n    msgs.push(makeCmd(`QLM${yyyymm}`));\n    nextMonth6 = ts + 6 * 60 * 60 * 1000;\n  }\n\n  // Yearly 24h\n  if (nextYear24 == null) nextYear24 = ts + 24 * 60 * 60 * 1000;\n  if (ts >= nextYear24) {\n    msgs.push(makeCmd(`QEY${yyyy}`));\n    msgs.push(makeCmd(`QLY${yyyy}`));\n    nextYear24 = ts + 24 * 60 * 60 * 1000;\n  }\n}\n\n// save\ncontext.set(\"alt\", alt);\ncontext.set(\"firstRun\", firstRun);\ncontext.set(\"nextQMOD\", nextQMOD);\ncontext.set(\"nextHour\", nextHour);\ncontext.set(\"nextDay10m\", nextDay10m);\ncontext.set(\"nextMonth6\", nextMonth6);\ncontext.set(\"nextYear24\", nextYear24);\ncontext.set(\"nextQPIRI\", nextQPIRI);\ncontext.set(\"nextQDOP\", nextQDOP);\ncontext.set(\"nextRetryQPIGS2\", nextRetryQPIGS2);\n\nreturn [msgs];\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":240,"y":400,"wires":[["3f378285d5efa6bc"]]},{"id":"79e8ddf5e61d2ba2","type":"function","z":"280951c3196085f3","g":"7ec01c3a3046742d","name":"parser ","func":"// ====== PARSER 1 (Voltronic) - QUEUE MODE ======\n// Entr√©e: msg.payload = Buffer (Serial IN en \"a single buffer\", pas de split)\n// Sorties:\n//   1) trigger pump (msg.topic=\"pump\")\n//   2) data pars√©e (vers normalize state)\n// Associe la r√©ponse √† la commande \"inflight\" (envoy√©e par Queue Pump)\n\nconst inv = msg.inverterNum ?? 1;\nif (!Buffer.isBuffer(msg.payload)) return null;\n\n// --- accumulateur RX ---\nlet rx = context.get(\"rxbuf\");\nif (!Buffer.isBuffer(rx)) rx = Buffer.alloc(0);\n\n// s√©curit√© overflow\nif (rx.length > 8192) rx = Buffer.alloc(0);\n\n// concat\nrx = Buffer.concat([rx, msg.payload]);\n\nconst CR = 0x0D;\n\n// extrait toutes les frames finissant par CR\nconst frames = [];\nwhile (true) {\n  const idx = rx.indexOf(CR);\n  if (idx === -1) break;\n  frames.push(rx.slice(0, idx + 1));\n  rx = rx.slice(idx + 1);\n}\ncontext.set(\"rxbuf\", rx);\n\nif (!frames.length) return null;\n\n// commande inflight (celle r√©ellement envoy√©e)\nconst inflightKey = `inv${inv}_inflight`;\nconst inflight = flow.get(inflightKey);\nconst inflightCmd = inflight?.cmd || \"UNKNOWN\";\n\n// Nettoyage trame -> ASCII sans CRC/CR\nfunction cleanAsciiFromFrame(frameBuf) {\n  // NAK brut possible (0x15)\n  if (frameBuf.length === 1 && frameBuf[0] === 0x15) return \"NAK\";\n\n  // Normalement: <data ASCII> + <CRC 2 bytes> + <CR>\n  let dataBuf = frameBuf;\n\n  if (frameBuf.length >= 3 && frameBuf[frameBuf.length - 1] === CR) {\n    dataBuf = frameBuf.slice(0, -3); // retire CRC(2) + CR(1)\n  } else if (frameBuf.length >= 1 && frameBuf[frameBuf.length - 1] === CR) {\n    dataBuf = frameBuf.slice(0, -1); // fallback retire CR\n  }\n\n  return dataBuf.toString(\"ascii\");\n}\n\nfunction parseFrame(frameBuf, cmd) {\n  const ascii = cleanAsciiFromFrame(frameBuf);\n\n  // D√©tection NAK \"NAK\" ou 0x15\n  if (ascii.includes(\"NAK\") || ascii === \"NAK\") {\n    return {\n      inverter: inv,\n      command: cmd,\n      nak: true,\n      raw: \"NAK\",\n      fields: [],\n      nums: [],\n      value: null\n    };\n  }\n\n  // Enlever parenth√®ses si pr√©sentes\n  let body = ascii.trim();\n  if (body.startsWith(\"(\")) body = body.slice(1);\n  if (body.endsWith(\")\")) body = body.slice(0, -1);\n  body = body.trim();\n\n  const fields = body.length ? body.split(/\\s+/) : [];\n  const nums = fields.map(v => {\n    const n = Number(v);\n    return Number.isFinite(n) ? n : null;\n  });\n\n  // Cas √©nergie (1 valeur)\n  const isEnergyCmd = /^Q(E[TYMD]|L[TYMD])/.test(cmd);\n  let value = null;\n  if (isEnergyCmd && fields.length >= 1) {\n    const n0 = Number(fields[0]);\n    if (Number.isFinite(n0)) value = n0;\n  }\n\n  return {\n    inverter: inv,\n    command: cmd,\n    raw: body,\n    fields,\n    nums,\n    value\n  };\n}\n\n// Ici, on part du principe QUEUE = 1 commande envoy√©e -> 1 r√©ponse attendue.\n// Mais on g√®re quand m√™me le cas \"plusieurs frames d'un coup\" :\n// - 1√®re frame = inflightCmd\n// - frames suivantes = UNKNOWN (ou on garde inflightCmd si tu pr√©f√®res)\nconst outMsgs = [];\nfor (let i = 0; i < frames.length; i++) {\n  const cmd = (i === 0) ? inflightCmd : \"UNKNOWN\";\n  outMsgs.push({\n    inverterNum: inv,\n    _cmd: cmd,\n    command: cmd,\n    payload: parseFrame(frames[i], cmd),\n    _rx_ts: Date.now()\n  });\n}\n\n// ACK : d√®s qu'on re√ßoit au moins une frame, on lib√®re inflight\nflow.set(inflightKey, null);\n\n// Trigger pump imm√©diatement (pour envoyer la prochaine commande)\nconst pumpMsg = { inverterNum: inv, topic: \"pump\" };\n\n// Sortie 1: pump trigger\n// Sortie 2: data pars√©e (plusieurs messages possibles)\nreturn [[pumpMsg], outMsgs];\n","outputs":2,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":430,"y":460,"wires":[["152320995f37f3e8"],["95c044d0fae501bc"]]},{"id":"1662751f64ba1280","type":"mqtt out","z":"280951c3196085f3","g":"7ec01c3a3046742d","name":"ond2","topic":"","qos":"0","retain":"","respTopic":"","contentType":"","userProps":"","correl":"","expiry":"","broker":"mqtt_broker","x":1090,"y":460,"wires":[]},{"id":"95c044d0fae501bc","type":"function","z":"280951c3196085f3","g":"7ec01c3a3046742d","name":"normalize state","func":"// ====== NORMALIZE STATE (AUTO / MULTI-MODEL) - FIX ENERGIES TODAY ======\nif (!msg.payload || typeof msg.payload !== \"object\") return null;\n\nconst inv = msg.inverterNum ?? msg.payload.inverter ?? 1;\n\n// ‚úÖ FIX MINIMAL: normaliser la commande (√©vite \"QPIRI\\r\", \"qpiri\", \"QPIRI \")\nconst cmd = String(msg.payload.command || msg.command || msg._cmd || \"UNKNOWN\")\n  .trim()\n  .toUpperCase();\n\nconst f = Array.isArray(msg.payload.fields) ? msg.payload.fields : [];\nconst n = Array.isArray(msg.payload.nums) ? msg.payload.nums : [];\nconst value = msg.payload.value;\n\nlet state = context.get(\"state\");\nif (!state || typeof state !== \"object\") state = {};\n\n// helpers\nconst num = (idx) => (Number.isFinite(n[idx]) ? n[idx] : null);\nconst int = (idx) => {\n  const v = num(idx);\n  return v == null ? null : Math.trunc(v);\n};\n\n// --- apprentissage index pv1_power par node (donc par inverter) ---\nlet pv1PowerIdx = context.get(\"pv1PowerIdx\"); // m√©moris√© par node\n\n// ===== QPIGS =====\nif (cmd === \"QPIGS\" && f.length >= 16) {\n\n  // Champs communs (tr√®s stables)\n  if (f.length > 0) state.grid_voltage = num(0);\n  if (f.length > 1) state.grid_frequency = num(1);\n  if (f.length > 2) state.ac_output_voltage = num(2);\n  if (f.length > 3) state.ac_output_frequency = num(3);\n\n  // Apparent/active/load : souvent 4/5/6\n  if (f.length > 5) state.ac_output_active_power = int(5);\n  if (f.length > 6) state.output_load_percent = int(6);\n\n  // bus voltage : souvent 7\n  if (f.length > 7) state.bus_voltage = int(7);\n\n  // Batterie : souvent 8/9/10/11\n  if (f.length > 8) state.battery_voltage = num(8);\n  if (f.length > 9) state.battery_charging_current = int(9);\n  if (f.length > 10) state.battery_capacity = int(10);\n  if (f.length > 11) state.inverter_heat_sink_temp = int(11);\n\n  // PV entr√©e : souvent 12/13\n  if (f.length > 12) state.pv1_input_current = num(12);\n  if (f.length > 13) state.pv1_input_voltage = num(13);\n\n  // Discharge current : souvent 15\n  if (f.length > 15) state.battery_discharge_current = int(15);\n\n  // ---- PV1 Power : auto\n  // 1) si on a d√©j√† appris l‚Äôindex, on l‚Äôutilise\n  if (pv1PowerIdx != null && f.length > pv1PowerIdx) {\n    state.pv1_power = int(pv1PowerIdx);\n  } else {\n    // 2) sinon on tente des index connus\n    const candidates = [19, 20, 18, 17, 16]; // couvre variantes connues\n    for (const idx of candidates) {\n      if (f.length > idx && Number.isFinite(n[idx])) {\n        const I = state.pv1_input_current;\n        const V = state.pv1_input_voltage;\n        const pCalc = (Number.isFinite(I) && Number.isFinite(V)) ? (I * V) : null;\n        const pField = n[idx];\n\n        // si on a I et V : on valide si proche (+/- 20%)\n        if (pCalc != null && pCalc > 10) {\n          const ratio = pField / pCalc;\n          if (ratio > 0.8 && ratio < 1.2) {\n            pv1PowerIdx = idx;\n            context.set(\"pv1PowerIdx\", pv1PowerIdx);\n            state.pv1_power = int(idx);\n            break;\n          }\n        } else {\n          // fallback : on choisit l'index le plus probable\n          if (idx === 19) {\n            state.pv1_power = int(19);\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  state._last_qpigs_ts = Date.now();\n}\n\n// ===== QPIGS2 (optionnel) =====\nif (cmd === \"QPIGS2\" && f.length >= 3) {\n  state.pv2_input_current = num(0);\n  state.pv2_input_voltage = num(1);\n  state.pv2_power = int(2);\n  state._last_qpigs2_ts = Date.now();\n}\n\n// ===== QMOD =====\nif (cmd === \"QMOD\") {\n  const rawMode = (f[0] ?? msg.payload.raw ?? \"\").toString().trim();\n  const modeMap = { P: \"Power On\", S: \"Standby\", L: \"Grid\", B: \"Battery\", F: \"Fault\" };\n  state.operation_mode = modeMap[rawMode] || rawMode || null;\n  state.operation_mode_code = rawMode || null;\n  state._last_qmod_ts = Date.now();\n}\n\n// ===== QPIRI -> PARAMETRES (bloc s√©par√©) =====\nif (cmd === \"QPIRI\" && msg.payload?.nak !== true) {\n  const nf = (idx) => {\n    const v = (f && f.length > idx) ? f[idx] : null;\n    const nn = Number(v);\n    return Number.isFinite(nn) ? nn : null;\n  };\n\n  const mapBatteryType = (code) => {\n    const m = {\n      0: \"AGM\",\n      1: \"Flooded\",\n      2: \"User\",\n      3: \"Pylon\",\n      5: \"Weco\",\n      6: \"Soltaro\",\n      8: \"Lib\",\n      9: \"Lic\"\n    };\n    return m[code] ?? String(code ?? \"\");\n  };\n\n  const mapOutputPriority = (code) => {\n    const m = { 0: \"UtilitySolarBat\", 1: \"SolarUtilityBat\", 2: \"SolarBatUtility\" };\n    return m[code] ?? String(code ?? \"\");\n  };\n\n  const mapChargerPriority = (code) => {\n    const m = { 1: \"Solar first\", 2: \"Solar + Utility\", 3: \"Only solar\" };\n    return m[code] ?? String(code ?? \"\");\n  };\n\n  if (!state.params || typeof state.params !== \"object\") state.params = {};\n\n  const battTypeCode = nf(12);\n  const outPrioCode = nf(16);\n  const chgPrioCode = nf(17);\n\n  state.params.qpiri = {\n    battery_recharge_voltage: nf(8),\n    battery_under_voltage: nf(9),\n    battery_bulk_voltage: nf(10),\n    battery_float_voltage: nf(11),\n\n    battery_type_code: battTypeCode,\n    battery_type: mapBatteryType(battTypeCode),\n\n    max_ac_charging_current: nf(13),\n    max_charging_current: nf(14),\n\n    output_source_priority_code: outPrioCode,\n    output_source_priority: mapOutputPriority(outPrioCode),\n\n    charger_source_priority_code: chgPrioCode,\n    charger_source_priority: mapChargerPriority(chgPrioCode),\n\n    battery_re_discharge_voltage: nf(22),\n    max_discharging_current: nf(27),\n\n    ts: Date.now()\n  };\n\n  state._last_qpiri_ts = Date.now();\n}\n\n// ===== QDOP -> PARAMETRES batterie (%) (3 champs seulement) =====\nif (cmd === \"QDOP\" && msg.payload?.nak !== true) {\n  const nf = (idx) => {\n    const v = (f && f.length > idx) ? f[idx] : null;\n    const nn = Number(v);\n    return Number.isFinite(nn) ? nn : null;\n  };\n\n  if (!state.params || typeof state.params !== \"object\") state.params = {};\n\n  state.params.qdop = {\n    battery_recharge_capacity_pct: nf(8),      // iii\n    battery_redischarge_capacity_pct: nf(9),   // jjj\n    battery_under_capacity_pct: nf(10),        // kkk\n    ts: Date.now()\n  };\n\n  state._last_qdop_ts = Date.now();\n}\n\n// ===== Support QPIGS2 (diagnostic) =====\nconst supportsKey = `inv${inv}_supports_qpigs2`;\nconst supports = flow.get(supportsKey);\nif (supports !== undefined) state.supports_qpigs2 = (supports !== false);\n\n// ===== ENERGIES (FIX Today) =====\nconst round2 = (v) => (v == null ? null : Math.round(v * 100) / 100);\n\n// Today est (chez toi) en Wh -> kWh\nconst toKwhToday = (v) => (!Number.isFinite(v) ? null : round2(v / 1000));\n\n// Total/Month/Year: mix firmwares -> auto (Wh si gros)\nconst toKwhAuto = (v) => (!Number.isFinite(v) ? null : (v >= 10000 ? round2(v / 1000) : round2(v)));\n\nif (Number.isFinite(value)) {\n  // PV\n  if (cmd === \"QET\") { state.pv_energy_total_raw = value; state.pv_energy_total_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QEY\")) { state.pv_energy_year_raw = value; state.pv_energy_year_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QEM\")) { state.pv_energy_month_raw = value; state.pv_energy_month_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QED\")) { state.pv_energy_day_raw = value; state.pv_energy_day_kwh = toKwhToday(value); }\n\n  // LOAD\n  if (cmd === \"QLT\") { state.load_energy_total_raw = value; state.load_energy_total_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QLY\")) { state.load_energy_year_raw = value; state.load_energy_year_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QLM\")) { state.load_energy_month_raw = value; state.load_energy_month_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QLD\")) { state.load_energy_day_raw = value; state.load_energy_day_kwh = toKwhToday(value); }\n\n  state._last_energy_ts = Date.now();\n}\n\n// ===== PV total power =====\nconst pv1 = Number.isFinite(state.pv1_power) ? state.pv1_power : 0;\nconst pv2 = Number.isFinite(state.pv2_power) ? state.pv2_power : 0;\nstate.pv_total_power = pv1 + pv2;\n\n// ===== BATTERY POWER (W) - CUSTOM SENSORS =====\nconst Vb = Number.isFinite(state.battery_voltage) ? state.battery_voltage : null;\nconst Ichg = Number.isFinite(state.battery_charging_current) ? state.battery_charging_current : 0;\nconst Idis = Number.isFinite(state.battery_discharge_current) ? state.battery_discharge_current : 0;\n\nif (Vb != null) {\n  const chargeW = Math.round(Vb * Math.max(0, Ichg));\n  const dischargeW = Math.round(Vb * Math.max(0, Idis));\n\n  // Noms demand√©s\n  state.battery_charge = chargeW;              // +W\n  state.battery_discharge = dischargeW;        // +W\n  state.battery_power = chargeW - dischargeW;  // + charge / - d√©charge\n} else {\n  state.battery_charge = null;\n  state.battery_discharge = null;\n  state.battery_power = null;\n}\n\ncontext.set(\"state\", state);\nmsg.inverterNum = inv;\nmsg.payload = state;\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":660,"y":460,"wires":[["c6a6cf11c6876196"]]},{"id":"c6a6cf11c6876196","type":"function","z":"280951c3196085f3","g":"7ec01c3a3046742d","name":"MQTT state publisher","func":"if (!msg.payload || typeof msg.payload !== \"object\") return null;\n\nconst inv = msg.inverterNum ?? 1;\n\nreturn [\n    {\n        topic: `voltronic/${inv}/state`,\n        payload: JSON.stringify(msg.payload),\n        retain: false\n    },\n    {\n        topic: `voltronic/${inv}/availability`,\n        payload: \"online\",\n        retain: true\n    }\n];\n","outputs":2,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":880,"y":460,"wires":[["1662751f64ba1280"],["1662751f64ba1280"]]},{"id":"3f378285d5efa6bc","type":"function","z":"280951c3196085f3","g":"7ec01c3a3046742d","name":"Queue Enqueue ","func":"const inv = msg.inverterNum ?? 1;\nconst key = `inv${inv}_queue`;\n\nlet q = flow.get(key);\nif (!Array.isArray(q)) q = [];\n\n// msg peut √™tre 1 commande, ou un lot (si tu envoies [msgs])\n// Ici, on g√®re les deux cas proprement.\nconst toPush = [];\n\nif (Array.isArray(msg)) {\n    // rare : si tu envoies direct un tableau de msgs\n    toPush.push(...msg);\n} else if (Array.isArray(msg.payload) && msg.payload?.[0]?.command) {\n    // si jamais ton flow passe un tableau dans payload\n    toPush.push(...msg.payload);\n} else {\n    // msg normal\n    toPush.push(msg);\n}\n\n// ajoute uniquement si on a une commande\ntoPush.forEach(m => {\n    const cmd = (m.command || m._cmd || m.payload || \"\").toString().trim().toUpperCase();\n    if (!cmd) return;\n\n    q.push({\n        inverterNum: inv,\n        command: cmd,\n        _cmd: cmd,\n        payload: cmd,\n        enqueued_ts: Date.now()\n    });\n});\n\n// limite taille\nif (q.length > 200) q = q.slice(-200);\n\nflow.set(key, q);\n\n// d√©clenche le pump\nreturn { inverterNum: inv, topic: \"pump\" };\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":440,"y":400,"wires":[["152320995f37f3e8"]]},{"id":"152320995f37f3e8","type":"function","z":"280951c3196085f3","g":"7ec01c3a3046742d","name":"Queue Pump ","func":"const inv = msg.inverterNum ?? 1;\n\nconst qKey = `inv${inv}_queue`;\nconst inFlightKey = `inv${inv}_inflight`;\n\nlet inFlight = flow.get(inFlightKey);\n\n// Si une commande est d√©j√† en attente de r√©ponse, on n‚Äôen envoie pas une autre\nif (inFlight && (Date.now() - (inFlight.ts || 0)) < 3000) {\n  return null;\n}\n\nlet q = flow.get(qKey);\nif (!Array.isArray(q) || q.length === 0) return null;\n\n// Prend la prochaine commande\nconst next = q.shift();\nflow.set(qKey, q);\n\n// Marque comme en vol\nflow.set(inFlightKey, { cmd: next.command, ts: Date.now() });\n\n// Envoie au construire commande\nreturn next;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":650,"y":420,"wires":[["0cb75a50bfad7cf1"]]},{"id":"83ef0d7ea356371d","type":"inject","z":"280951c3196085f3","g":"7ec01c3a3046742d","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"2","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":650,"y":380,"wires":[["152320995f37f3e8"]]},{"id":"0967f976f3607b87","type":"function","z":"280951c3196085f3","g":"7ec01c3a3046742d","name":"tag","func":"msg.inverterNum = 2;\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":290,"y":460,"wires":[["79e8ddf5e61d2ba2"]]},{"id":"f8cd5845ef986b83","type":"function","z":"280951c3196085f3","g":"7ded0da774dae4c3","name":"construire commande ","func":"// ====== CONSTRUIRE COMMANDE (Voltronic) ======\nconst helpers = global.get(\"helpers\");\n\nif (!helpers || typeof helpers.buildVoltronicCommand !== \"function\") {\n  node.error(\"helpers.buildVoltronicCommand introuvable (global.helpers)\");\n  return null;\n}\n\n// R√©cup√®re la commande (priorit√© √† msg.command)\nlet cmd = (msg.command ?? msg._cmd ?? msg.payload ?? \"\").toString().trim().toUpperCase();\n\nif (!cmd) {\n  node.warn(\"Commande vide -> ignor√©e\");\n  return null;\n}\n\n// S√©curit√©: commande uniquement alphanum (Voltronic = lettres/chiffres)\nif (!/^[A-Z0-9]+$/.test(cmd)) {\n  node.warn(`Commande invalide ignor√©e: \"${cmd}\"`);\n  return null;\n}\n\n// Conserver la commande envoy√©e (utile pour associer RX)\nmsg.command = cmd;\nmsg._cmd = cmd;\n\n// Construire la trame (CRC + CR)\nconst buf = helpers.buildVoltronicCommand(cmd);\n\n// Payload = Buffer √† envoyer dans Serial Out\nmsg.payload = buf;\n\n// Debug utile\nmsg._tx_ts = Date.now();\nmsg._tx_ascii = cmd;\nmsg._tx_hex = buf.toString(\"hex\");\n\n// Status (optionnel)\nnode.status({\n  fill: \"blue\",\n  shape: \"dot\",\n  text: `${cmd} ‚Üí ond${msg.inverterNum ?? \"?\"}`\n});\n\n// m√©morise la derni√®re commande par onduleur\nif (msg.inverterNum != null) {\n  flow.set(`inv${msg.inverterNum}_last_cmd`, msg._cmd);\n  flow.set(`inv${msg.inverterNum}_last_cmd_ts`, Date.now());\n}\n\n\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":860,"y":680,"wires":[[]]},{"id":"9d8b9dae17ecfdd1","type":"inject","z":"280951c3196085f3","g":"7ded0da774dae4c3","name":"ond2","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"0.5","crontab":"","once":true,"onceDelay":"2","topic":"","payload":"","payloadType":"date","x":110,"y":680,"wires":[["5fc4530736e20310"]]},{"id":"5fc4530736e20310","type":"function","z":"280951c3196085f3","g":"7ded0da774dae4c3","name":"requetes","func":"// ====== REQUETES (Option A + firstRun + force + QPIGS2 auto-disable + retry 1h) ======\nconst inverterNum = 3;\nconst ts = Date.now();\nconst now = new Date();\n\nconst pad2 = (n) => String(n).padStart(2, \"0\");\nconst yyyy = now.getFullYear();\nconst mm = pad2(now.getMonth() + 1);\nconst dd = pad2(now.getDate());\n\nconst yyyymm = `${yyyy}${mm}`;\nconst yyyymmdd = `${yyyy}${mm}${dd}`;\n\n// √©tat alternance\nlet alt = context.get(\"alt\");\nif (alt === undefined || alt === null) alt = 0;\n\n// firstRun peut rester false si context persistant\nlet firstRun = context.get(\"firstRun\");\nif (firstRun === undefined) firstRun = true;\n\n// Permet de forcer un burst via un inject bouton (msg.forceFirstRun=true)\nif (msg && msg.forceFirstRun === true) {\n  firstRun = true;\n}\n\n// timers\nlet nextQMOD = context.get(\"nextQMOD\");\nlet nextHour = context.get(\"nextHour\");\nlet nextDay10m = context.get(\"nextDay10m\");\nlet nextMonth6 = context.get(\"nextMonth6\");\nlet nextYear24 = context.get(\"nextYear24\");\n\n// retry QPIGS2 m√™me si d√©sactiv√©\nlet nextRetryQPIGS2 = context.get(\"nextRetryQPIGS2\");\nif (!nextRetryQPIGS2) nextRetryQPIGS2 = ts + 60 * 60 * 1000;\n\nfunction makeCmd(cmd) {\n  return { inverterNum, command: cmd, _cmd: cmd, payload: cmd };\n}\n\nconst msgs = [];\n\n// ----- QPIGS/QPIGS2 strat√©gie par onduleur -----\nconst supportsQPIGS2 = flow.get(`inv${inverterNum}_supports_qpigs2`);\nconst useQPIGS2 = (supportsQPIGS2 !== false);\n\nfunction pushRealtimeTick() {\n  if (useQPIGS2) {\n    msgs.push(makeCmd(alt === 0 ? \"QPIGS\" : \"QPIGS2\"));\n    alt = alt ? 0 : 1;\n  } else {\n    msgs.push(makeCmd(\"QPIGS\"));\n\n    // tentative 1 fois par heure\n    if (ts >= nextRetryQPIGS2) {\n      msgs.push(makeCmd(\"QPIGS2\"));\n      nextRetryQPIGS2 = ts + 60 * 60 * 1000;\n    }\n  }\n}\n\n// 1) tick realtime\npushRealtimeTick();\n\n// 2) Burst imm√©diat (au 1er run OU si forc√©)\nif (firstRun) {\n  const burst = [\n    \"QMOD\",\n    \"QET\", `QEY${yyyy}`, `QEM${yyyymm}`, `QED${yyyymmdd}`,\n    \"QLT\", `QLY${yyyy}`, `QLM${yyyymm}`, `QLD${yyyymmdd}`,\n  ];\n  burst.forEach(c => msgs.push(makeCmd(c)));\n\n  nextQMOD = ts + 5 * 60 * 1000;\n  nextHour = ts + 60 * 60 * 1000;\n  nextDay10m = ts + 10 * 60 * 1000;\n  nextMonth6 = ts + 6 * 60 * 60 * 1000;\n  nextYear24 = ts + 24 * 60 * 60 * 1000;\n\n  firstRun = false;\n\n  node.status({ fill: \"green\", shape: \"dot\", text: `FIRST RUN: ${msgs.length} cmds` });\n} else {\n  // 3) timers normaux\n  if (nextQMOD == null) nextQMOD = ts + 5 * 60 * 1000;\n  if (ts >= nextQMOD) { msgs.push(makeCmd(\"QMOD\")); nextQMOD = ts + 5 * 60 * 1000; }\n\n  if (nextHour == null) nextHour = ts + 60 * 60 * 1000;\n  if (ts >= nextHour) { msgs.push(makeCmd(\"QET\")); msgs.push(makeCmd(\"QLT\")); nextHour = ts + 60 * 60 * 1000; }\n\n  if (nextDay10m == null) nextDay10m = ts + 10 * 60 * 1000;\n  if (ts >= nextDay10m) {\n    msgs.push(makeCmd(`QED${yyyymmdd}`));\n    msgs.push(makeCmd(`QLD${yyyymmdd}`));\n    nextDay10m = ts + 10 * 60 * 1000;\n  }\n\n  if (nextMonth6 == null) nextMonth6 = ts + 6 * 60 * 60 * 1000;\n  if (ts >= nextMonth6) {\n    msgs.push(makeCmd(`QEM${yyyymm}`));\n    msgs.push(makeCmd(`QLM${yyyymm}`));\n    nextMonth6 = ts + 6 * 60 * 60 * 1000;\n  }\n\n  if (nextYear24 == null) nextYear24 = ts + 24 * 60 * 60 * 1000;\n  if (ts >= nextYear24) {\n    msgs.push(makeCmd(`QEY${yyyy}`));\n    msgs.push(makeCmd(`QLY${yyyy}`));\n    nextYear24 = ts + 24 * 60 * 60 * 1000;\n  }\n}\n\n// save\ncontext.set(\"alt\", alt);\ncontext.set(\"firstRun\", firstRun);\ncontext.set(\"nextQMOD\", nextQMOD);\ncontext.set(\"nextHour\", nextHour);\ncontext.set(\"nextDay10m\", nextDay10m);\ncontext.set(\"nextMonth6\", nextMonth6);\ncontext.set(\"nextYear24\", nextYear24);\ncontext.set(\"nextRetryQPIGS2\", nextRetryQPIGS2);\n\n// IMPORTANT : renvoyer la rafale\nreturn [msgs];\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":240,"y":620,"wires":[["0df7d5d102daeb53"]]},{"id":"d6de7f12225cc573","type":"function","z":"280951c3196085f3","g":"7ded0da774dae4c3","name":"parser ","func":"// ====== PARSER 1 (Voltronic) - QUEUE MODE + QPIGS2 AUTO-DISABLE ======\n// Entr√©e: msg.payload = Buffer (Serial IN en \"a single buffer\", pas de split)\n// Sorties:\n//   1) trigger pump (msg.topic=\"pump\")\n//   2) data pars√©e (vers normalize state)\n// Associe la r√©ponse √† la commande \"inflight\" (envoy√©e par Queue Pump)\n\nconst inv = msg.inverterNum ?? 1;\nif (!Buffer.isBuffer(msg.payload)) return null;\n\n// ---- QPIGS2 support tracking (NAK seuil) ----\nconst supportsKey = `inv${inv}_supports_qpigs2`;\nconst nakKey = `inv${inv}_nak_qpigs2`;\nconst NAK_THRESHOLD = 3;\n\nif (flow.get(supportsKey) === undefined) flow.set(supportsKey, true);\nif (flow.get(nakKey) === undefined) flow.set(nakKey, 0);\n\n// --- accumulateur RX ---\nlet rx = context.get(\"rxbuf\");\nif (!Buffer.isBuffer(rx)) rx = Buffer.alloc(0);\n\n// s√©curit√© overflow\nif (rx.length > 8192) rx = Buffer.alloc(0);\n\n// concat\nrx = Buffer.concat([rx, msg.payload]);\n\nconst CR = 0x0D;\n\n// extrait toutes les frames finissant par CR\nconst frames = [];\nwhile (true) {\n  const idx = rx.indexOf(CR);\n  if (idx === -1) break;\n  frames.push(rx.slice(0, idx + 1));\n  rx = rx.slice(idx + 1);\n}\ncontext.set(\"rxbuf\", rx);\n\nif (!frames.length) return null;\n\n// commande inflight (celle r√©ellement envoy√©e)\nconst inflightKey = `inv${inv}_inflight`;\nconst inflight = flow.get(inflightKey);\nconst inflightCmd = inflight?.cmd || \"UNKNOWN\";\n\n// Nettoyage trame -> ASCII sans CRC/CR\nfunction cleanAsciiFromFrame(frameBuf) {\n  // NAK brut possible (0x15)\n  if (frameBuf.length === 1 && frameBuf[0] === 0x15) return \"NAK\";\n\n  // Normalement: <data ASCII> + <CRC 2 bytes> + <CR>\n  let dataBuf = frameBuf;\n\n  if (frameBuf.length >= 3 && frameBuf[frameBuf.length - 1] === CR) {\n    dataBuf = frameBuf.slice(0, -3); // retire CRC(2) + CR(1)\n  } else if (frameBuf.length >= 1 && frameBuf[frameBuf.length - 1] === CR) {\n    dataBuf = frameBuf.slice(0, -1); // fallback retire CR\n  }\n\n  return dataBuf.toString(\"ascii\");\n}\n\nfunction parseFrame(frameBuf, cmd) {\n  const ascii = cleanAsciiFromFrame(frameBuf);\n\n  // D√©tection NAK \"NAK\" ou 0x15\n  const isNak = (ascii.includes(\"NAK\") || ascii === \"NAK\");\n  if (isNak) {\n    // Gestion support QPIGS2 avec seuil\n    if (cmd === \"QPIGS2\") {\n      let c = flow.get(nakKey) || 0;\n      c += 1;\n      flow.set(nakKey, c);\n\n      if (c >= NAK_THRESHOLD) {\n        flow.set(supportsKey, false);\n      }\n    }\n\n    return {\n      inverter: inv,\n      command: cmd,\n      nak: true,\n      raw: \"NAK\",\n      fields: [],\n      nums: [],\n      value: null\n    };\n  }\n\n  // Si QPIGS2 r√©pond OK -> reset compteur + support true\n  if (cmd === \"QPIGS2\") {\n    flow.set(nakKey, 0);\n    flow.set(supportsKey, true);\n  }\n\n  // Enlever parenth√®ses si pr√©sentes\n  let body = ascii.trim();\n  if (body.startsWith(\"(\")) body = body.slice(1);\n  if (body.endsWith(\")\")) body = body.slice(0, -1);\n  body = body.trim();\n\n  const fields = body.length ? body.split(/\\s+/) : [];\n  const nums = fields.map(v => {\n    const n = Number(v);\n    return Number.isFinite(n) ? n : null;\n  });\n\n  // Cas √©nergie (1 valeur)\n  const isEnergyCmd = /^Q(E[TYMD]|L[TYMD])/.test(cmd);\n  let value = null;\n  if (isEnergyCmd && fields.length >= 1) {\n    const n0 = Number(fields[0]);\n    if (Number.isFinite(n0)) value = n0;\n  }\n\n  return {\n    inverter: inv,\n    command: cmd,\n    raw: body,\n    fields,\n    nums,\n    value\n  };\n}\n\n// QUEUE = 1 commande envoy√©e -> 1 r√©ponse attendue.\n// Si plusieurs frames d'un coup : 1√®re frame = inflightCmd, suivantes = UNKNOWN\nconst outMsgs = [];\nfor (let i = 0; i < frames.length; i++) {\n  const cmd = (i === 0) ? inflightCmd : \"UNKNOWN\";\n  outMsgs.push({\n    inverterNum: inv,\n    _cmd: cmd,\n    command: cmd,\n    payload: parseFrame(frames[i], cmd),\n    _rx_ts: Date.now()\n  });\n}\n\n// ACK : d√®s qu'on re√ßoit au moins une frame, on lib√®re inflight\nflow.set(inflightKey, null);\n\n// Trigger pump imm√©diatement (pour envoyer la prochaine commande)\nconst pumpMsg = { inverterNum: inv, topic: \"pump\" };\n\n// Sortie 1: pump trigger\n// Sortie 2: data pars√©e\nreturn [[pumpMsg], outMsgs];\n","outputs":2,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":330,"y":740,"wires":[["85e54b63ab62f9c6"],["80d50b3c6c5325e0"]]},{"id":"e8f00ee886c8b175","type":"mqtt out","z":"280951c3196085f3","g":"7ded0da774dae4c3","name":"ond3","topic":"","qos":"0","retain":"","respTopic":"","contentType":"","userProps":"","correl":"","expiry":"","broker":"mqtt_broker","x":910,"y":740,"wires":[]},{"id":"80d50b3c6c5325e0","type":"function","z":"280951c3196085f3","g":"7ded0da774dae4c3","name":"normalize state","func":"// ====== NORMALIZE STATE (AUTO / MULTI-MODEL) - FIX ENERGIES TODAY ======\nif (!msg.payload || typeof msg.payload !== \"object\") return null;\n\nconst inv = msg.inverterNum ?? msg.payload.inverter ?? 1;\nconst cmd = msg.payload.command || msg.command || msg._cmd || \"UNKNOWN\";\nconst f = msg.payload.fields || [];\nconst n = msg.payload.nums || [];\nconst value = msg.payload.value;\n\nlet state = context.get(\"state\");\nif (!state || typeof state !== \"object\") state = {};\n\nconst num = (idx) => (Number.isFinite(n[idx]) ? n[idx] : null);\nconst int = (idx) => {\n  const v = num(idx);\n  return v == null ? null : Math.trunc(v);\n};\n\n// --- apprentissage index pv1_power par node (donc par inverter) ---\nlet pv1PowerIdx = context.get(\"pv1PowerIdx\"); // m√©moris√© par node\n\n// ===== QPIGS =====\nif (cmd === \"QPIGS\" && f.length >= 16) {\n\n  // Champs communs (tr√®s stables)\n  if (f.length > 0) state.grid_voltage        = num(0);\n  if (f.length > 1) state.grid_frequency      = num(1);\n  if (f.length > 2) state.ac_output_voltage   = num(2);\n  if (f.length > 3) state.ac_output_frequency = num(3);\n\n  // Apparent/active/load : souvent 4/5/6\n  if (f.length > 5) state.ac_output_active_power = int(5);\n  if (f.length > 6) state.output_load_percent    = int(6);\n\n  // bus voltage : souvent 7\n  if (f.length > 7) state.bus_voltage = int(7);\n\n  // Batterie : souvent 8/9/10/11\n  if (f.length > 8)  state.battery_voltage = num(8);\n  if (f.length > 9)  state.battery_charging_current = int(9);\n  if (f.length > 10) state.battery_capacity = int(10);\n  if (f.length > 11) state.inverter_heat_sink_temp = int(11);\n\n  // PV entr√©e : souvent 12/13\n  if (f.length > 12) state.pv1_input_current = num(12);\n  if (f.length > 13) state.pv1_input_voltage = num(13);\n\n  // Discharge current : souvent 15\n  if (f.length > 15) state.battery_discharge_current = int(15);\n\n  // ---- PV1 Power : auto\n  // 1) si on a d√©j√† appris l‚Äôindex, on l‚Äôutilise\n  if (pv1PowerIdx != null && f.length > pv1PowerIdx) {\n    state.pv1_power = int(pv1PowerIdx);\n  } else {\n    // 2) sinon on tente des index connus\n    const candidates = [19, 20, 18, 17, 16]; // couvre variantes connues\n    for (const idx of candidates) {\n      if (f.length > idx && Number.isFinite(n[idx])) {\n        const I = state.pv1_input_current;\n        const V = state.pv1_input_voltage;\n        const pCalc = (Number.isFinite(I) && Number.isFinite(V)) ? (I * V) : null;\n        const pField = n[idx];\n\n        // si on a I et V : on valide si proche (+/- 20%)\n        if (pCalc != null && pCalc > 10) {\n          const ratio = pField / pCalc;\n          if (ratio > 0.8 && ratio < 1.2) {\n            pv1PowerIdx = idx;\n            context.set(\"pv1PowerIdx\", pv1PowerIdx);\n            state.pv1_power = int(idx);\n            break;\n          }\n        } else {\n          // fallback : on choisit l'index le plus probable\n          if (idx === 19) {\n            state.pv1_power = int(19);\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  state._last_qpigs_ts = Date.now();\n}\n\n// ===== QPIGS2 (optionnel) =====\nif (cmd === \"QPIGS2\" && f.length >= 3) {\n  state.pv2_input_current = num(0);\n  state.pv2_input_voltage = num(1);\n  state.pv2_power         = int(2);\n  state._last_qpigs2_ts = Date.now();\n}\n\n// ===== QMOD =====\nif (cmd === \"QMOD\") {\n  const rawMode = (f[0] ?? msg.payload.raw ?? \"\").toString().trim();\n  const modeMap = { P:\"Power On\", S:\"Standby\", L:\"Grid\", B:\"Battery\", F:\"Fault\" };\n  state.operation_mode = modeMap[rawMode] || rawMode || null;\n  state.operation_mode_code = rawMode || null;\n  state._last_qmod_ts = Date.now();\n}\n\n// ===== Support QPIGS2 (diagnostic) =====\nconst supportsKey = `inv${inv}_supports_qpigs2`;\nconst supports = flow.get(supportsKey);\nif (supports !== undefined) state.supports_qpigs2 = (supports !== false);\n\n// ===== ENERGIES (FIX Today) =====\nconst round2 = (v) => (v == null ? null : Math.round(v * 100) / 100);\n\n// Today est (chez toi) en Wh -> kWh\nconst toKwhToday = (v) => (!Number.isFinite(v) ? null : round2(v / 1000));\n\n// Total/Month/Year: mix firmwares -> auto (Wh si gros)\nconst toKwhAuto = (v) => (!Number.isFinite(v) ? null : (v >= 10000 ? round2(v / 1000) : round2(v)));\n\nif (Number.isFinite(value)) {\n  // PV\n  if (cmd === \"QET\")         { state.pv_energy_total_raw = value;  state.pv_energy_total_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QEY\")) { state.pv_energy_year_raw  = value;  state.pv_energy_year_kwh  = toKwhAuto(value); }\n  if (cmd.startsWith(\"QEM\")) { state.pv_energy_month_raw = value;  state.pv_energy_month_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QED\")) { state.pv_energy_day_raw   = value;  state.pv_energy_day_kwh   = toKwhToday(value); }\n\n  // LOAD\n  if (cmd === \"QLT\")         { state.load_energy_total_raw = value; state.load_energy_total_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QLY\")) { state.load_energy_year_raw  = value; state.load_energy_year_kwh  = toKwhAuto(value); }\n  if (cmd.startsWith(\"QLM\")) { state.load_energy_month_raw = value; state.load_energy_month_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QLD\")) { state.load_energy_day_raw   = value; state.load_energy_day_kwh   = toKwhToday(value); }\n\n  state._last_energy_ts = Date.now();\n}\n\n// ===== PV total power =====\nconst pv1 = Number.isFinite(state.pv1_power) ? state.pv1_power : 0;\nconst pv2 = Number.isFinite(state.pv2_power) ? state.pv2_power : 0;\nstate.pv_total_power = pv1 + pv2;\n\ncontext.set(\"state\", state);\nmsg.inverterNum = inv;\nmsg.payload = state;\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":500,"y":740,"wires":[["55367afd35b705e1"]]},{"id":"55367afd35b705e1","type":"function","z":"280951c3196085f3","g":"7ded0da774dae4c3","name":"MQTT state publisher","func":"if (!msg.payload || typeof msg.payload !== \"object\") return null;\n\nconst inv = msg.inverterNum ?? 1;\n\nreturn [\n    {\n        topic: `voltronic/${inv}/state`,\n        payload: JSON.stringify(msg.payload),\n        retain: false\n    },\n    {\n        topic: `voltronic/${inv}/availability`,\n        payload: \"online\",\n        retain: true\n    }\n];\n","outputs":2,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":720,"y":740,"wires":[["e8f00ee886c8b175"],["e8f00ee886c8b175"]]},{"id":"0df7d5d102daeb53","type":"function","z":"280951c3196085f3","g":"7ded0da774dae4c3","name":"Queue Enqueue ","func":"const inv = msg.inverterNum ?? 1;\nconst key = `inv${inv}_queue`;\n\nlet q = flow.get(key);\nif (!Array.isArray(q)) q = [];\n\n// msg peut √™tre 1 commande, ou un lot (si tu envoies [msgs])\n// Ici, on g√®re les deux cas proprement.\nconst toPush = [];\n\nif (Array.isArray(msg)) {\n    // rare : si tu envoies direct un tableau de msgs\n    toPush.push(...msg);\n} else if (Array.isArray(msg.payload) && msg.payload?.[0]?.command) {\n    // si jamais ton flow passe un tableau dans payload\n    toPush.push(...msg.payload);\n} else {\n    // msg normal\n    toPush.push(msg);\n}\n\n// ajoute uniquement si on a une commande\ntoPush.forEach(m => {\n    const cmd = (m.command || m._cmd || m.payload || \"\").toString().trim().toUpperCase();\n    if (!cmd) return;\n\n    q.push({\n        inverterNum: inv,\n        command: cmd,\n        _cmd: cmd,\n        payload: cmd,\n        enqueued_ts: Date.now()\n    });\n});\n\n// limite taille\nif (q.length > 200) q = q.slice(-200);\n\nflow.set(key, q);\n\n// d√©clenche le pump\nreturn { inverterNum: inv, topic: \"pump\" };\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":420,"y":680,"wires":[["85e54b63ab62f9c6"]]},{"id":"85e54b63ab62f9c6","type":"function","z":"280951c3196085f3","g":"7ded0da774dae4c3","name":"Queue Pump ","func":"const inv = msg.inverterNum ?? 1;\n\nconst qKey = `inv${inv}_queue`;\nconst inFlightKey = `inv${inv}_inflight`;\n\nlet inFlight = flow.get(inFlightKey);\n\n// Si une commande est d√©j√† en attente de r√©ponse, on n‚Äôen envoie pas une autre\nif (inFlight && (Date.now() - (inFlight.ts || 0)) < 3000) {\n  return null;\n}\n\nlet q = flow.get(qKey);\nif (!Array.isArray(q) || q.length === 0) return null;\n\n// Prend la prochaine commande\nconst next = q.shift();\nflow.set(qKey, q);\n\n// Marque comme en vol\nflow.set(inFlightKey, { cmd: next.command, ts: Date.now() });\n\n// Envoie au construire commande\nreturn next;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":650,"y":700,"wires":[["f8cd5845ef986b83"]]},{"id":"55f030bbc6796553","type":"inject","z":"280951c3196085f3","g":"7ded0da774dae4c3","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"2","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":650,"y":660,"wires":[["85e54b63ab62f9c6"]]},{"id":"36618809bf6b7d3c","type":"function","z":"280951c3196085f3","g":"7ded0da774dae4c3","name":"tag","func":"msg.inverterNum = 3;\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":250,"y":700,"wires":[["d6de7f12225cc573"]]},{"id":"de354293640c80a3","type":"mqtt in","z":"280951c3196085f3","g":"57656369260fdee6","name":"MQTT IN - HA SET","topic":"voltronic/+/set/+","qos":"0","datatype":"auto-detect","broker":"mqtt_broker","nl":false,"rap":true,"rh":0,"inputs":0,"x":150,"y":220,"wires":[["8558e17ff63073c1"]]},{"id":"8558e17ff63073c1","type":"function","z":"280951c3196085f3","g":"57656369260fdee6","name":"HA SET ‚Üí Voltronic CMD","func":"// HA SET -> Voltronic CMD  (1 sortie)\n// topic: voltronic/<inv>/set/<param>\n// payload: valeur\n\nconst m = (msg.topic || \"\").match(/^voltronic\\/(\\d+)\\/set\\/(.+)$/);\nif (!m) return null;\n\nconst inverterNum = Number(m[1]);\nconst param = m[2];\n\nlet v = msg.payload;\nif (typeof v === \"string\") v = v.trim();\n\nconst toNum = (x) => {\n  const n = Number(x);\n  return Number.isFinite(n) ? n : null;\n};\nconst pad3 = (x) => String(Math.trunc(Number(x))).padStart(3, \"0\");\nconst fixed1 = (x) => Number(x).toFixed(1);\nconst clamp = (x, a, b) => Math.min(b, Math.max(a, Number(x)));\n\nconst machine = inverterNum;\n\nlet cmd = null;\n\n// SELECTS\nif (param === \"output_source_priority\") {\n  const map = { UtilitySolarBat: \"POP00\", SolarUtilityBat: \"POP01\", SolarBatUtility: \"POP02\" };\n  cmd = map[v] || null;\n} else if (param === \"charger_source_priority\") {\n  const map = { \"Solar first\": \"PCP01\", \"Solar + Utility\": \"PCP02\", \"Only solar\": \"PCP03\" };\n  cmd = map[v] || null;\n} else if (param === \"battery_type\") {\n  const map = { AGM:\"PBT00\", Flooded:\"PBT01\", User:\"PBT02\", Pylon:\"PBT03\", Weco:\"PBT05\", Soltaro:\"PBT06\", Lib:\"PBT08\", Lic:\"PBT09\" };\n  cmd = map[v] || null;\n}\n\n// VOLTAGES nn.n\nelse if (param === \"battery_recharge_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PBCV${fixed1(nv)}`; }\nelse if (param === \"battery_re_discharge_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PBDV${fixed1(nv)}`; }\nelse if (param === \"battery_under_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PSDV${fixed1(nv)}`; }\nelse if (param === \"battery_bulk_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PCVV${fixed1(nv)}`; }\nelse if (param === \"battery_float_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PBFT${fixed1(nv)}`; }\n\n// CURRENTS\nelse if (param === \"max_charging_current\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `MNCHGC${machine}${pad3(clamp(nv,0,300))}`;\n}\nelse if (param === \"max_ac_charging_current\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `MUCHGC${machine}${pad3(clamp(nv,0,300))}`;\n}\nelse if (param === \"max_discharging_current\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `PBATMAXDISC${pad3(clamp(nv,0,300))}`;\n}\n\n// QDOP seuils %\nelse if (param === \"battery_recharge_capacity_pct\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `PBCC${pad3(clamp(nv,5,95))}`;\n}\nelse if (param === \"battery_redischarge_capacity_pct\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `PBDC${pad3(clamp(nv,10,100))}`;\n}\nelse if (param === \"battery_under_capacity_pct\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `PSDC${pad3(clamp(nv,0,90))}`;\n}\n\nif (!cmd) return null;\n\nconst mk = (c) => ({\n  inverterNum,\n  command: c,\n  _cmd: c,\n  payload: c,\n  _burst: true\n});\n\n// 1Ô∏è‚É£ Message SET (prioritaire)\nconst setMsg = mk(cmd);\nsetMsg._burst = false;\n\n// 2Ô∏è‚É£ Rafale refresh apr√®s SET (pour MAJ imm√©diate HA)\nconst refresh = [\"QPIRI\", \"QDOP\", \"QMOD\", \"QPIGS\"];\n// optionnel si support√© : refresh.splice(3,0,\"QPIGS2\");\n\nconst out = [setMsg, ...refresh.map(mk)];\n\nnode.status({\n  fill: \"green\",\n  shape: \"dot\",\n  text: `SET ${param} + refresh x${out.length - 1}`\n});\n\n// ‚ùóÔ∏èIMPORTANT : 1 sortie => tableau de messages dans la sortie 1\nreturn [out];\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":390,"y":220,"wires":[["de9aa384c451b6cf"]]},{"id":"de9aa384c451b6cf","type":"link out","z":"280951c3196085f3","g":"57656369260fdee6","name":"link out 1","mode":"link","links":["b64df27ef9b2e03f"],"x":575,"y":220,"wires":[]},{"id":"b64df27ef9b2e03f","type":"link in","z":"280951c3196085f3","g":"57656369260fdee6","name":"link in 1","links":["de9aa384c451b6cf"],"x":275,"y":60,"wires":[["4e49dec8b23d003f"]]},{"id":"f75b804e3f323942","type":"function","z":"280951c3196085f3","g":"7ec01c3a3046742d","name":"HA SET ‚Üí Voltronic CMD","func":"// HA SET -> Voltronic CMD  (1 sortie)\n// topic: voltronic/<inv>/set/<param>\n// payload: valeur\n\nconst m = (msg.topic || \"\").match(/^voltronic\\/(\\d+)\\/set\\/(.+)$/);\nif (!m) return null;\n\nconst inverterNum = Number(m[1]);\nconst param = m[2];\n\nlet v = msg.payload;\nif (typeof v === \"string\") v = v.trim();\n\nconst toNum = (x) => {\n  const n = Number(x);\n  return Number.isFinite(n) ? n : null;\n};\nconst pad3 = (x) => String(Math.trunc(Number(x))).padStart(3, \"0\");\nconst fixed1 = (x) => Number(x).toFixed(1);\nconst clamp = (x, a, b) => Math.min(b, Math.max(a, Number(x)));\n\nconst machine = inverterNum;\n\nlet cmd = null;\n\n// SELECTS\nif (param === \"output_source_priority\") {\n  const map = { UtilitySolarBat: \"POP00\", SolarUtilityBat: \"POP01\", SolarBatUtility: \"POP02\" };\n  cmd = map[v] || null;\n} else if (param === \"charger_source_priority\") {\n  const map = { \"Solar first\": \"PCP01\", \"Solar + Utility\": \"PCP02\", \"Only solar\": \"PCP03\" };\n  cmd = map[v] || null;\n} else if (param === \"battery_type\") {\n  const map = { AGM:\"PBT00\", Flooded:\"PBT01\", User:\"PBT02\", Pylon:\"PBT03\", Weco:\"PBT05\", Soltaro:\"PBT06\", Lib:\"PBT08\", Lic:\"PBT09\" };\n  cmd = map[v] || null;\n}\n\n// VOLTAGES nn.n\nelse if (param === \"battery_recharge_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PBCV${fixed1(nv)}`; }\nelse if (param === \"battery_re_discharge_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PBDV${fixed1(nv)}`; }\nelse if (param === \"battery_under_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PSDV${fixed1(nv)}`; }\nelse if (param === \"battery_bulk_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PCVV${fixed1(nv)}`; }\nelse if (param === \"battery_float_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PBFT${fixed1(nv)}`; }\n\n// CURRENTS\nelse if (param === \"max_charging_current\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `MNCHGC${machine}${pad3(clamp(nv,0,300))}`;\n}\nelse if (param === \"max_ac_charging_current\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `MUCHGC${machine}${pad3(clamp(nv,0,300))}`;\n}\nelse if (param === \"max_discharging_current\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `PBATMAXDISC${pad3(clamp(nv,0,300))}`;\n}\n\n// QDOP seuils %\nelse if (param === \"battery_recharge_capacity_pct\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `PBCC${pad3(clamp(nv,5,95))}`;\n}\nelse if (param === \"battery_redischarge_capacity_pct\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `PBDC${pad3(clamp(nv,10,100))}`;\n}\nelse if (param === \"battery_under_capacity_pct\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `PSDC${pad3(clamp(nv,0,90))}`;\n}\n\nif (!cmd) return null;\n\nconst mk = (c) => ({\n  inverterNum,\n  command: c,\n  _cmd: c,\n  payload: c,\n  _burst: true\n});\n\n// 1Ô∏è‚É£ Message SET (prioritaire)\nconst setMsg = mk(cmd);\nsetMsg._burst = false;\n\n// 2Ô∏è‚É£ Rafale refresh apr√®s SET (pour MAJ imm√©diate HA)\nconst refresh = [\"QPIRI\", \"QDOP\", \"QMOD\", \"QPIGS\"];\n// optionnel si support√© : refresh.splice(3,0,\"QPIGS2\");\n\nconst out = [setMsg, ...refresh.map(mk)];\n\nnode.status({\n  fill: \"green\",\n  shape: \"dot\",\n  text: `SET ${param} + refresh x${out.length - 1}`\n});\n\n// ‚ùóÔ∏èIMPORTANT : 1 sortie => tableau de messages dans la sortie 1\nreturn [out];\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":370,"y":520,"wires":[["361cfd9b7b2c4692"]]},{"id":"4f7d529112896319","type":"mqtt in","z":"280951c3196085f3","g":"7ec01c3a3046742d","name":"MQTT IN - HA SET","topic":"voltronic/+/set/+","qos":"0","datatype":"auto-detect","broker":"mqtt_broker","nl":false,"rap":true,"rh":0,"inputs":0,"x":130,"y":520,"wires":[["f75b804e3f323942"]]},{"id":"361cfd9b7b2c4692","type":"link out","z":"280951c3196085f3","g":"7ec01c3a3046742d","name":"link out 2","mode":"link","links":["535730443c533ff9"],"x":545,"y":520,"wires":[]},{"id":"535730443c533ff9","type":"link in","z":"280951c3196085f3","g":"7ec01c3a3046742d","name":"link in 2","links":["361cfd9b7b2c4692"],"x":315,"y":340,"wires":[["3f378285d5efa6bc"]]},{"id":"a21ddb7191f1b93f","type":"function","z":"296b81230a5aed2a","g":"fca760cd70eac181","name":"üîç HA Discovery ond1","func":"const inv = 1;\n\nconst base = `voltronic/${inv}`;\nconst state_topic = `${base}/state`;\nconst availability_topic = `${base}/availability`;\nconst set_base = `${base}/set`; // <-- o√π HA publiera les changements\n\nconst device = {\n  identifiers: [`voltronic_inv_${inv}`],\n  name: `Voltronic Inverter ${inv}`,\n  manufacturer: \"Voltronic\",\n  model: \"Axpert/Voltronic\",\n};\n\nfunction sensorCfg(objectId, name, unit, device_class, state_class, valueTpl, extra = {}) {\n  const uid = `voltronic_${inv}_${objectId}`;\n  const topic = `homeassistant/sensor/${uid}/config`;\n\n  const payload = {\n    name,\n    unique_id: uid,\n    state_topic,\n    availability_topic,\n    payload_available: \"online\",\n    payload_not_available: \"offline\",\n    value_template: valueTpl,\n    device,\n    ...extra,\n  };\n\n  if (unit) payload.unit_of_measurement = unit;\n  if (device_class) payload.device_class = device_class;\n  if (state_class) payload.state_class = state_class;\n\n  return { topic, payload: JSON.stringify(payload), retain: true };\n}\n\nfunction selectCfg(objectId, name, options, valueTpl, commandTopic, extra = {}) {\n  const uid = `voltronic_${inv}_${objectId}`;\n  const topic = `homeassistant/select/${uid}/config`;\n\n  const payload = {\n    name,\n    unique_id: uid,\n    state_topic,\n    availability_topic,\n    payload_available: \"online\",\n    payload_not_available: \"offline\",\n    value_template: valueTpl,\n    command_topic: commandTopic,\n    options,\n    device,\n    ...extra,\n  };\n\n  return { topic, payload: JSON.stringify(payload), retain: true };\n}\n\nfunction numberCfg(objectId, name, unit, min, max, step, valueTpl, commandTopic, extra = {}) {\n  const uid = `voltronic_${inv}_${objectId}`;\n  const topic = `homeassistant/number/${uid}/config`;\n\n  const payload = {\n    name,\n    unique_id: uid,\n    state_topic,\n    availability_topic,\n    payload_available: \"online\",\n    payload_not_available: \"offline\",\n    value_template: valueTpl,\n    command_topic: commandTopic,\n    unit_of_measurement: unit,\n    min,\n    max,\n    step,\n    mode: \"box\",\n    device,\n    ...extra,\n  };\n\n  return { topic, payload: JSON.stringify(payload), retain: true };\n}\n\n// =======================\n// 1) TES SENSORS EXISTANTS\n// =======================\nconst msgsSensors = [\n  // --- Puissances PV\n  sensorCfg(\"pv_total_power\", \"PV Total Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.pv_total_power }}\"),\n  sensorCfg(\"pv1_power\", \"PV1 Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.pv1_power }}\"),\n  sensorCfg(\"pv2_power\", \"PV2 Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.pv2_power }}\"),\n\n  // --- PV entr√©es\n  sensorCfg(\"pv1_input_voltage\", \"PV1 Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.pv1_input_voltage }}\"),\n  sensorCfg(\"pv2_input_voltage\", \"PV2 Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.pv2_input_voltage }}\"),\n  sensorCfg(\"pv1_input_current\", \"PV1 Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.pv1_input_current }}\"),\n  sensorCfg(\"pv2_input_current\", \"PV2 Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.pv2_input_current }}\"),\n\n  // --- AC sortie\n  sensorCfg(\"ac_output_voltage\", \"AC Output Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.ac_output_voltage }}\"),\n  sensorCfg(\"ac_output_frequency\", \"AC Output Frequency\", \"Hz\", \"frequency\", \"measurement\", \"{{ value_json.ac_output_frequency }}\"),\n  sensorCfg(\"ac_output_active_power\", \"AC Output Active Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.ac_output_active_power }}\"),\n  sensorCfg(\"output_load_percent\", \"Output Load\", \"%\", null, \"measurement\", \"{{ value_json.output_load_percent }}\"),\n\n  // --- Mode (QMOD)\n  sensorCfg(\"operation_mode\", \"Operation Mode\", null, null, null, \"{{ value_json.operation_mode }}\"),\n\n  // --- Batterie (brut)\n  sensorCfg(\"battery_voltage\", \"Battery Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.battery_voltage }}\"),\n  sensorCfg(\"battery_charging_current\", \"Battery Charging Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.battery_charging_current }}\"),\n  sensorCfg(\"battery_discharge_current\", \"Battery Discharge Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.battery_discharge_current }}\"),\n  sensorCfg(\"battery_capacity\", \"Battery Capacity\", \"%\", \"battery\", \"measurement\", \"{{ value_json.battery_capacity }}\"),\n\n  // ‚úÖ NOUVEAUX SENSORS PERSO (W)\n  sensorCfg(\"battery_charge\", \"Battery charge\", \"W\", \"power\", \"measurement\", \"{{ value_json.battery_charge }}\"),\n  sensorCfg(\"battery_discharge\", \"Battery discharge\", \"W\", \"power\", \"measurement\", \"{{ value_json.battery_discharge }}\"),\n  sensorCfg(\"battery_power\", \"Battery power\", \"W\", \"power\", \"measurement\", \"{{ value_json.battery_power }}\"),\n\n  // --- Temp√©rature\n  sensorCfg(\"inverter_heat_sink_temp\", \"Inverter Heatsink Temp\", \"¬∞C\", \"temperature\", \"measurement\", \"{{ value_json.inverter_heat_sink_temp }}\"),\n\n  // --- R√©seau\n  sensorCfg(\"grid_voltage\", \"Grid Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.grid_voltage }}\"),\n  sensorCfg(\"grid_frequency\", \"Grid Frequency\", \"Hz\", \"frequency\", \"measurement\", \"{{ value_json.grid_frequency }}\"),\n\n  // ====== ENERGIES kWh ======\n  sensorCfg(\"pv_energy_total_kwh\", \"PV Energy Total\", \"kWh\", \"energy\", \"total_increasing\", \"{{ value_json.pv_energy_total_kwh }}\"),\n  sensorCfg(\"pv_energy_day_kwh\", \"PV Energy Today\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.pv_energy_day_kwh }}\"),\n  sensorCfg(\"pv_energy_month_kwh\", \"PV Energy This Month\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.pv_energy_month_kwh }}\"),\n  sensorCfg(\"pv_energy_year_kwh\", \"PV Energy This Year\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.pv_energy_year_kwh }}\"),\n\n  sensorCfg(\"load_energy_total_kwh\", \"Load Energy Total\", \"kWh\", \"energy\", \"total_increasing\", \"{{ value_json.load_energy_total_kwh }}\"),\n  sensorCfg(\"load_energy_day_kwh\", \"Load Energy Today\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.load_energy_day_kwh }}\"),\n  sensorCfg(\"load_energy_month_kwh\", \"Load Energy This Month\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.load_energy_month_kwh }}\"),\n  sensorCfg(\"load_energy_year_kwh\", \"Load Energy This Year\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.load_energy_year_kwh }}\"),\n];\n\n// ==========================================\n// 2) PARAMETRES (QPIRI + QDOP) - MODIFIABLES (HA)\n// ==========================================\nconst baseTplQPIRI = \"value_json.params.qpiri\";\nconst baseTplQDOP = \"value_json.params.qdop\";\n\nconst msgsParams = [\n  selectCfg(\n    \"param_battery_type\",\n    \"Param Battery Type\",\n    [\"AGM\", \"Flooded\", \"User\", \"Lib\", \"Lic\", \"Pylon\", \"Weco\", \"Soltaro\"],\n    `{{ ${baseTplQPIRI}.battery_type }}`,\n    `${set_base}/battery_type`\n  ),\n\n  selectCfg(\n    \"param_output_source_priority\",\n    \"Param Output Source Priority\",\n    [\"UtilitySolarBat\", \"SolarUtilityBat\", \"SolarBatUtility\"],\n    `{{ ${baseTplQPIRI}.output_source_priority }}`,\n    `${set_base}/output_source_priority`\n  ),\n\n  selectCfg(\n    \"param_charger_source_priority\",\n    \"Battery Charging Priority\",\n    [\"Solar first\", \"Solar + Utility\", \"Only solar\"],\n    `{{ ${baseTplQPIRI}.charger_source_priority }}`,\n    `${set_base}/charger_source_priority`\n  ),\n\n  numberCfg(\n    \"param_battery_recharge_voltage\",\n    \"Param Battery Recharge Voltage\",\n    \"V\",\n    40, 60, 0.1,\n    `{{ ${baseTplQPIRI}.battery_recharge_voltage }}`,\n    `${set_base}/battery_recharge_voltage`\n  ),\n  numberCfg(\n    \"param_battery_under_voltage\",\n    \"Param Battery Under Voltage\",\n    \"V\",\n    40, 60, 0.1,\n    `{{ ${baseTplQPIRI}.battery_under_voltage }}`,\n    `${set_base}/battery_under_voltage`\n  ),\n  numberCfg(\n    \"param_battery_bulk_voltage\",\n    \"Param Battery Bulk Voltage\",\n    \"V\",\n    40, 65, 0.1,\n    `{{ ${baseTplQPIRI}.battery_bulk_voltage }}`,\n    `${set_base}/battery_bulk_voltage`\n  ),\n  numberCfg(\n    \"param_battery_float_voltage\",\n    \"Param Battery Float Voltage\",\n    \"V\",\n    40, 65, 0.1,\n    `{{ ${baseTplQPIRI}.battery_float_voltage }}`,\n    `${set_base}/battery_float_voltage`\n  ),\n  numberCfg(\n    \"param_battery_re_discharge_voltage\",\n    \"Param Battery Re-Discharge Voltage\",\n    \"V\",\n    40, 65, 0.1,\n    `{{ ${baseTplQPIRI}.battery_re_discharge_voltage }}`,\n    `${set_base}/battery_re_discharge_voltage`\n  ),\n\n  numberCfg(\n    \"param_max_ac_charging_current\",\n    \"Param Max AC Charging Current\",\n    \"A\",\n    0, 200, 1,\n    `{{ ${baseTplQPIRI}.max_ac_charging_current }}`,\n    `${set_base}/max_ac_charging_current`\n  ),\n  numberCfg(\n    \"param_max_charging_current\",\n    \"Param Max Charging Current\",\n    \"A\",\n    0, 200, 1,\n    `{{ ${baseTplQPIRI}.max_charging_current }}`,\n    `${set_base}/max_charging_current`\n  ),\n  numberCfg(\n    \"param_max_discharging_current\",\n    \"Param Max Discharging Current\",\n    \"A\",\n    0, 300, 1,\n    `{{ ${baseTplQPIRI}.max_discharging_current }}`,\n    `${set_base}/max_discharging_current`\n  ),\n\n  numberCfg(\n    \"param_battery_recharge_capacity_pct\",\n    \"Param Battery Recharge Capacity\",\n    \"%\",\n    0, 100, 1,\n    `{{ ${baseTplQDOP}.battery_recharge_capacity_pct }}`,\n    `${set_base}/battery_recharge_capacity_pct`\n  ),\n  numberCfg(\n    \"param_battery_redischarge_capacity_pct\",\n    \"Param Battery Redischarge Capacity\",\n    \"%\",\n    0, 100, 1,\n    `{{ ${baseTplQDOP}.battery_redischarge_capacity_pct }}`,\n    `${set_base}/battery_redischarge_capacity_pct`\n  ),\n  numberCfg(\n    \"param_battery_under_capacity_pct\",\n    \"Param Battery Under Capacity\",\n    \"%\",\n    0, 100, 1,\n    `{{ ${baseTplQDOP}.battery_under_capacity_pct }}`,\n    `${set_base}/battery_under_capacity_pct`\n  ),\n];\n\n// Un tableau final : sensors + params\nconst msgs = [...msgsSensors, ...msgsParams];\n\nreturn [msgs];\n","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":420,"y":80,"wires":[["a5d5ee44dfe21839"]]},{"id":"a5d5ee44dfe21839","type":"mqtt out","z":"296b81230a5aed2a","g":"fca760cd70eac181","name":"üì° MQTT Out","topic":"","qos":"0","retain":"false","respTopic":"","contentType":"","userProps":"","correl":"","expiry":"","broker":"mqtt_broker","x":700,"y":80,"wires":[]},{"id":"5c73574c1a191af3","type":"inject","z":"296b81230a5aed2a","g":"fca760cd70eac181","name":"‚è∞ Au d√©marrage","props":[{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":"2","topic":"","payload":"","payloadType":"date","x":170,"y":80,"wires":[["a21ddb7191f1b93f"]]},{"id":"9900a8c0b8fb0ade","type":"function","z":"296b81230a5aed2a","g":"2ffb0ad1ec6c4336","name":"üîç HA Discovery ond2","func":"const inv = 2;\n\nconst base = `voltronic/${inv}`;\nconst state_topic = `${base}/state`;\nconst availability_topic = `${base}/availability`;\nconst set_base = `${base}/set`; // <-- o√π HA publiera les changements\n\nconst device = {\n  identifiers: [`voltronic_inv_${inv}`],\n  name: `Voltronic Inverter ${inv}`,\n  manufacturer: \"Voltronic\",\n  model: \"Axpert/Voltronic\",\n};\n\nfunction sensorCfg(objectId, name, unit, device_class, state_class, valueTpl, extra = {}) {\n  const uid = `voltronic_${inv}_${objectId}`;\n  const topic = `homeassistant/sensor/${uid}/config`;\n\n  const payload = {\n    name,\n    unique_id: uid,\n    state_topic,\n    availability_topic,\n    payload_available: \"online\",\n    payload_not_available: \"offline\",\n    value_template: valueTpl,\n    device,\n    ...extra,\n  };\n\n  if (unit) payload.unit_of_measurement = unit;\n  if (device_class) payload.device_class = device_class;\n  if (state_class) payload.state_class = state_class;\n\n  return { topic, payload: JSON.stringify(payload), retain: true };\n}\n\nfunction selectCfg(objectId, name, options, valueTpl, commandTopic, extra = {}) {\n  const uid = `voltronic_${inv}_${objectId}`;\n  const topic = `homeassistant/select/${uid}/config`;\n\n  const payload = {\n    name,\n    unique_id: uid,\n    state_topic,\n    availability_topic,\n    payload_available: \"online\",\n    payload_not_available: \"offline\",\n    value_template: valueTpl,\n    command_topic: commandTopic,\n    options,\n    device,\n    ...extra,\n  };\n\n  return { topic, payload: JSON.stringify(payload), retain: true };\n}\n\nfunction numberCfg(objectId, name, unit, min, max, step, valueTpl, commandTopic, extra = {}) {\n  const uid = `voltronic_${inv}_${objectId}`;\n  const topic = `homeassistant/number/${uid}/config`;\n\n  const payload = {\n    name,\n    unique_id: uid,\n    state_topic,\n    availability_topic,\n    payload_available: \"online\",\n    payload_not_available: \"offline\",\n    value_template: valueTpl,\n    command_topic: commandTopic,\n    unit_of_measurement: unit,\n    min,\n    max,\n    step,\n    mode: \"box\",\n    device,\n    ...extra,\n  };\n\n  return { topic, payload: JSON.stringify(payload), retain: true };\n}\n\n// =======================\n// 1) TES SENSORS EXISTANTS\n// =======================\nconst msgsSensors = [\n  // --- Puissances PV\n  sensorCfg(\"pv_total_power\", \"PV Total Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.pv_total_power }}\"),\n  sensorCfg(\"pv1_power\", \"PV1 Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.pv1_power }}\"),\n  sensorCfg(\"pv2_power\", \"PV2 Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.pv2_power }}\"),\n\n  // --- PV entr√©es\n  sensorCfg(\"pv1_input_voltage\", \"PV1 Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.pv1_input_voltage }}\"),\n  sensorCfg(\"pv2_input_voltage\", \"PV2 Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.pv2_input_voltage }}\"),\n  sensorCfg(\"pv1_input_current\", \"PV1 Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.pv1_input_current }}\"),\n  sensorCfg(\"pv2_input_current\", \"PV2 Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.pv2_input_current }}\"),\n\n  // --- AC sortie\n  sensorCfg(\"ac_output_voltage\", \"AC Output Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.ac_output_voltage }}\"),\n  sensorCfg(\"ac_output_frequency\", \"AC Output Frequency\", \"Hz\", \"frequency\", \"measurement\", \"{{ value_json.ac_output_frequency }}\"),\n  sensorCfg(\"ac_output_active_power\", \"AC Output Active Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.ac_output_active_power }}\"),\n  sensorCfg(\"output_load_percent\", \"Output Load\", \"%\", null, \"measurement\", \"{{ value_json.output_load_percent }}\"),\n\n  // --- Mode (QMOD)\n  sensorCfg(\"operation_mode\", \"Operation Mode\", null, null, null, \"{{ value_json.operation_mode }}\"),\n\n  // --- Batterie (brut)\n  sensorCfg(\"battery_voltage\", \"Battery Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.battery_voltage }}\"),\n  sensorCfg(\"battery_charging_current\", \"Battery Charging Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.battery_charging_current }}\"),\n  sensorCfg(\"battery_discharge_current\", \"Battery Discharge Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.battery_discharge_current }}\"),\n  sensorCfg(\"battery_capacity\", \"Battery Capacity\", \"%\", \"battery\", \"measurement\", \"{{ value_json.battery_capacity }}\"),\n\n  // ‚úÖ NOUVEAUX SENSORS PERSO (W)\n  sensorCfg(\"battery_charge\", \"Battery charge\", \"W\", \"power\", \"measurement\", \"{{ value_json.battery_charge }}\"),\n  sensorCfg(\"battery_discharge\", \"Battery discharge\", \"W\", \"power\", \"measurement\", \"{{ value_json.battery_discharge }}\"),\n  sensorCfg(\"battery_power\", \"Battery power\", \"W\", \"power\", \"measurement\", \"{{ value_json.battery_power }}\"),\n\n  // --- Temp√©rature\n  sensorCfg(\"inverter_heat_sink_temp\", \"Inverter Heatsink Temp\", \"¬∞C\", \"temperature\", \"measurement\", \"{{ value_json.inverter_heat_sink_temp }}\"),\n\n  // --- R√©seau\n  sensorCfg(\"grid_voltage\", \"Grid Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.grid_voltage }}\"),\n  sensorCfg(\"grid_frequency\", \"Grid Frequency\", \"Hz\", \"frequency\", \"measurement\", \"{{ value_json.grid_frequency }}\"),\n\n  // ====== ENERGIES kWh ======\n  sensorCfg(\"pv_energy_total_kwh\", \"PV Energy Total\", \"kWh\", \"energy\", \"total_increasing\", \"{{ value_json.pv_energy_total_kwh }}\"),\n  sensorCfg(\"pv_energy_day_kwh\", \"PV Energy Today\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.pv_energy_day_kwh }}\"),\n  sensorCfg(\"pv_energy_month_kwh\", \"PV Energy This Month\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.pv_energy_month_kwh }}\"),\n  sensorCfg(\"pv_energy_year_kwh\", \"PV Energy This Year\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.pv_energy_year_kwh }}\"),\n\n  sensorCfg(\"load_energy_total_kwh\", \"Load Energy Total\", \"kWh\", \"energy\", \"total_increasing\", \"{{ value_json.load_energy_total_kwh }}\"),\n  sensorCfg(\"load_energy_day_kwh\", \"Load Energy Today\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.load_energy_day_kwh }}\"),\n  sensorCfg(\"load_energy_month_kwh\", \"Load Energy This Month\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.load_energy_month_kwh }}\"),\n  sensorCfg(\"load_energy_year_kwh\", \"Load Energy This Year\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.load_energy_year_kwh }}\"),\n];\n\n// ==========================================\n// 2) PARAMETRES (QPIRI + QDOP) - MODIFIABLES (HA)\n// ==========================================\nconst baseTplQPIRI = \"value_json.params.qpiri\";\nconst baseTplQDOP = \"value_json.params.qdop\";\n\nconst msgsParams = [\n  selectCfg(\n    \"param_battery_type\",\n    \"Param Battery Type\",\n    [\"AGM\", \"Flooded\", \"User\", \"Lib\", \"Lic\", \"Pylon\", \"Weco\", \"Soltaro\"],\n    `{{ ${baseTplQPIRI}.battery_type }}`,\n    `${set_base}/battery_type`\n  ),\n\n  selectCfg(\n    \"param_output_source_priority\",\n    \"Param Output Source Priority\",\n    [\"UtilitySolarBat\", \"SolarUtilityBat\", \"SolarBatUtility\"],\n    `{{ ${baseTplQPIRI}.output_source_priority }}`,\n    `${set_base}/output_source_priority`\n  ),\n\n  selectCfg(\n    \"param_charger_source_priority\",\n    \"Battery Charging Priority\",\n    [\"Solar first\", \"Solar + Utility\", \"Only solar\"],\n    `{{ ${baseTplQPIRI}.charger_source_priority }}`,\n    `${set_base}/charger_source_priority`\n  ),\n\n  numberCfg(\n    \"param_battery_recharge_voltage\",\n    \"Param Battery Recharge Voltage\",\n    \"V\",\n    40, 60, 0.1,\n    `{{ ${baseTplQPIRI}.battery_recharge_voltage }}`,\n    `${set_base}/battery_recharge_voltage`\n  ),\n  numberCfg(\n    \"param_battery_under_voltage\",\n    \"Param Battery Under Voltage\",\n    \"V\",\n    40, 60, 0.1,\n    `{{ ${baseTplQPIRI}.battery_under_voltage }}`,\n    `${set_base}/battery_under_voltage`\n  ),\n  numberCfg(\n    \"param_battery_bulk_voltage\",\n    \"Param Battery Bulk Voltage\",\n    \"V\",\n    40, 65, 0.1,\n    `{{ ${baseTplQPIRI}.battery_bulk_voltage }}`,\n    `${set_base}/battery_bulk_voltage`\n  ),\n  numberCfg(\n    \"param_battery_float_voltage\",\n    \"Param Battery Float Voltage\",\n    \"V\",\n    40, 65, 0.1,\n    `{{ ${baseTplQPIRI}.battery_float_voltage }}`,\n    `${set_base}/battery_float_voltage`\n  ),\n  numberCfg(\n    \"param_battery_re_discharge_voltage\",\n    \"Param Battery Re-Discharge Voltage\",\n    \"V\",\n    40, 65, 0.1,\n    `{{ ${baseTplQPIRI}.battery_re_discharge_voltage }}`,\n    `${set_base}/battery_re_discharge_voltage`\n  ),\n\n  numberCfg(\n    \"param_max_ac_charging_current\",\n    \"Param Max AC Charging Current\",\n    \"A\",\n    0, 200, 1,\n    `{{ ${baseTplQPIRI}.max_ac_charging_current }}`,\n    `${set_base}/max_ac_charging_current`\n  ),\n  numberCfg(\n    \"param_max_charging_current\",\n    \"Param Max Charging Current\",\n    \"A\",\n    0, 200, 1,\n    `{{ ${baseTplQPIRI}.max_charging_current }}`,\n    `${set_base}/max_charging_current`\n  ),\n  numberCfg(\n    \"param_max_discharging_current\",\n    \"Param Max Discharging Current\",\n    \"A\",\n    0, 300, 1,\n    `{{ ${baseTplQPIRI}.max_discharging_current }}`,\n    `${set_base}/max_discharging_current`\n  ),\n\n  numberCfg(\n    \"param_battery_recharge_capacity_pct\",\n    \"Param Battery Recharge Capacity\",\n    \"%\",\n    0, 100, 1,\n    `{{ ${baseTplQDOP}.battery_recharge_capacity_pct }}`,\n    `${set_base}/battery_recharge_capacity_pct`\n  ),\n  numberCfg(\n    \"param_battery_redischarge_capacity_pct\",\n    \"Param Battery Redischarge Capacity\",\n    \"%\",\n    0, 100, 1,\n    `{{ ${baseTplQDOP}.battery_redischarge_capacity_pct }}`,\n    `${set_base}/battery_redischarge_capacity_pct`\n  ),\n  numberCfg(\n    \"param_battery_under_capacity_pct\",\n    \"Param Battery Under Capacity\",\n    \"%\",\n    0, 100, 1,\n    `{{ ${baseTplQDOP}.battery_under_capacity_pct }}`,\n    `${set_base}/battery_under_capacity_pct`\n  ),\n];\n\n// Un tableau final : sensors + params\nconst msgs = [...msgsSensors, ...msgsParams];\n\nreturn [msgs];\n","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":420,"y":200,"wires":[["9fd6ea60084d9aba"]]},{"id":"9fd6ea60084d9aba","type":"mqtt out","z":"296b81230a5aed2a","g":"2ffb0ad1ec6c4336","name":"üì° MQTT Out","topic":"","qos":"0","retain":"false","respTopic":"","contentType":"","userProps":"","correl":"","expiry":"","broker":"mqtt_broker","x":700,"y":200,"wires":[]},{"id":"423279481f2891e9","type":"inject","z":"296b81230a5aed2a","g":"2ffb0ad1ec6c4336","name":"‚è∞ Au d√©marrage","props":[{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":"2","topic":"","payload":"","payloadType":"date","x":170,"y":200,"wires":[["9900a8c0b8fb0ade"]]},{"id":"05595a6f316d37e4","type":"function","z":"296b81230a5aed2a","g":"8b109ad885d98582","name":"üîç HA Discovery ond3","func":"const inv = 3;\n\nconst base = `voltronic/${inv}`;\nconst state_topic = `${base}/state`;\nconst availability_topic = `${base}/availability`;\n\nconst device = {\n  identifiers: [`voltronic_inv_${inv}`],\n  name: `Voltronic Inverter ${inv}`,\n  manufacturer: \"Voltronic\",\n  model: \"Axpert/Voltronic\",\n};\n\nfunction sensorCfg(objectId, name, unit, device_class, state_class, valueTpl, extra = {}) {\n  const uid = `voltronic_${inv}_${objectId}`;\n  const topic = `homeassistant/sensor/${uid}/config`;\n\n  const payload = {\n    name,\n    unique_id: uid,\n    state_topic,\n    availability_topic,\n    payload_available: \"online\",\n    payload_not_available: \"offline\",\n    value_template: valueTpl,\n    device,\n    ...extra,\n  };\n\n  if (unit) payload.unit_of_measurement = unit;\n  if (device_class) payload.device_class = device_class;\n  if (state_class) payload.state_class = state_class;\n\n  return { topic, payload: JSON.stringify(payload), retain: true };\n}\n\nconst msgs = [\n  // --- Puissances PV\n  sensorCfg(\"pv_total_power\", \"PV Total Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.pv_total_power }}\"),\n  sensorCfg(\"pv1_power\", \"PV1 Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.pv1_power }}\"),\n  sensorCfg(\"pv2_power\", \"PV2 Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.pv2_power }}\"),\n\n  // --- PV entr√©es\n  sensorCfg(\"pv1_input_voltage\", \"PV1 Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.pv1_input_voltage }}\"),\n  sensorCfg(\"pv2_input_voltage\", \"PV2 Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.pv2_input_voltage }}\"),\n  sensorCfg(\"pv1_input_current\", \"PV1 Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.pv1_input_current }}\"),\n  sensorCfg(\"pv2_input_current\", \"PV2 Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.pv2_input_current }}\"),\n\n  // --- AC sortie\n  sensorCfg(\"ac_output_voltage\", \"AC Output Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.ac_output_voltage }}\"),\n  sensorCfg(\"ac_output_frequency\", \"AC Output Frequency\", \"Hz\", \"frequency\", \"measurement\", \"{{ value_json.ac_output_frequency }}\"),\n  sensorCfg(\"ac_output_active_power\", \"AC Output Active Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.ac_output_active_power }}\"),\n  sensorCfg(\"output_load_percent\", \"Output Load\", \"%\", null, \"measurement\", \"{{ value_json.output_load_percent }}\"),\n\n  // --- Mode (QMOD) plac√© ici ‚Äúavec les autres‚Äù\n  sensorCfg(\"operation_mode\", \"Operation Mode\", null, null, null, \"{{ value_json.operation_mode }}\"),\n\n  // --- Batterie\n  sensorCfg(\"battery_voltage\", \"Battery Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.battery_voltage }}\"),\n  sensorCfg(\"battery_charging_current\", \"Battery Charging Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.battery_charging_current }}\"),\n  sensorCfg(\"battery_discharge_current\", \"Battery Discharge Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.battery_discharge_current }}\"),\n  sensorCfg(\"battery_capacity\", \"Battery Capacity\", \"%\", \"battery\", \"measurement\", \"{{ value_json.battery_capacity }}\"),\n\n  // --- Temp√©rature\n  sensorCfg(\"inverter_heat_sink_temp\", \"Inverter Heatsink Temp\", \"¬∞C\", \"temperature\", \"measurement\", \"{{ value_json.inverter_heat_sink_temp }}\"),\n\n  // --- R√©seau (0 si sur batterie)\n  sensorCfg(\"grid_voltage\", \"Grid Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.grid_voltage }}\"),\n  sensorCfg(\"grid_frequency\", \"Grid Frequency\", \"Hz\", \"frequency\", \"measurement\", \"{{ value_json.grid_frequency }}\"),\n\n  // ====== ENERGIES kWh ======\n  sensorCfg(\"pv_energy_total_kwh\", \"PV Energy Total\", \"kWh\", \"energy\", \"total_increasing\", \"{{ value_json.pv_energy_total_kwh }}\"),\n  sensorCfg(\"pv_energy_day_kwh\", \"PV Energy Today\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.pv_energy_day_kwh }}\"),\n  sensorCfg(\"pv_energy_month_kwh\", \"PV Energy This Month\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.pv_energy_month_kwh }}\"),\n  sensorCfg(\"pv_energy_year_kwh\", \"PV Energy This Year\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.pv_energy_year_kwh }}\"),\n\n  sensorCfg(\"load_energy_total_kwh\", \"Load Energy Total\", \"kWh\", \"energy\", \"total_increasing\", \"{{ value_json.load_energy_total_kwh }}\"),\n  sensorCfg(\"load_energy_day_kwh\", \"Load Energy Today\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.load_energy_day_kwh }}\"),\n  sensorCfg(\"load_energy_month_kwh\", \"Load Energy This Month\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.load_energy_month_kwh }}\"),\n  sensorCfg(\"load_energy_year_kwh\", \"Load Energy This Year\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.load_energy_year_kwh }}\"),\n];\n\nreturn [msgs];\n","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":420,"y":320,"wires":[["b49da1eb9e7aeb60"]]},{"id":"b49da1eb9e7aeb60","type":"mqtt out","z":"296b81230a5aed2a","g":"8b109ad885d98582","name":"üì° MQTT Out","topic":"","qos":"0","retain":"false","respTopic":"","contentType":"","userProps":"","correl":"","expiry":"","broker":"mqtt_broker","x":700,"y":320,"wires":[]},{"id":"fd3b9f314f1f6121","type":"inject","z":"296b81230a5aed2a","g":"8b109ad885d98582","name":"‚è∞ Au d√©marrage","props":[{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":"2","topic":"","payload":"","payloadType":"date","x":170,"y":320,"wires":[["05595a6f316d37e4"]]}]