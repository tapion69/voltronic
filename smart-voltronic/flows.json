[
    {
        "id": "ca0b537221e236b6",
        "type": "tab",
        "label": "‚öôÔ∏è Config",
        "disabled": false,
        "info": ""
    },
    {
        "id": "280951c3196085f3",
        "type": "tab",
        "label": "üîå Voltronic",
        "disabled": false,
        "info": ""
    },
    {
        "id": "296b81230a5aed2a",
        "type": "tab",
        "label": "üì° MQTT",
        "disabled": false,
        "info": ""
    },
    {
        "id": "57656369260fdee6",
        "type": "group",
        "z": "280951c3196085f3",
        "name": "onduleur 1",
        "style": {
            "label": true
        },
        "nodes": [
            "e4d2c8d8e64970ac",
            "32b643591e2b04ed",
            "70182d375061cbef",
            "fd71ee45ebc28f61",
            "286da83a35d93180",
            "2c9a803f94dce0bb",
            "589f82c1423c9842",
            "957af781b779e33e",
            "6294edb213438cd0",
            "4e49dec8b23d003f",
            "71f23c568f360d5b",
            "cdfa7de40dc84703",
            "de354293640c80a3",
            "8558e17ff63073c1",
            "de9aa384c451b6cf",
            "b64df27ef9b2e03f"
        ],
        "x": 14,
        "y": 19,
        "w": 1172,
        "h": 242
    },
    {
        "id": "7ec01c3a3046742d",
        "type": "group",
        "z": "280951c3196085f3",
        "name": "onduleur 2",
        "style": {
            "label": true
        },
        "nodes": [
            "da6ab8ea42e3c773",
            "3771ead040fae605",
            "0cb75a50bfad7cf1",
            "c6db8ec683e40f8c",
            "213e33dc0a23c9f5",
            "79e8ddf5e61d2ba2",
            "1662751f64ba1280",
            "95c044d0fae501bc",
            "c6a6cf11c6876196",
            "3f378285d5efa6bc",
            "152320995f37f3e8",
            "83ef0d7ea356371d",
            "0967f976f3607b87",
            "f75b804e3f323942",
            "4f7d529112896319",
            "361cfd9b7b2c4692",
            "535730443c533ff9"
        ],
        "x": 14,
        "y": 299,
        "w": 1172,
        "h": 262
    },
    {
        "id": "fca760cd70eac181",
        "type": "group",
        "z": "296b81230a5aed2a",
        "name": "onduleur 1",
        "style": {
            "label": true
        },
        "nodes": [
            "a21ddb7191f1b93f",
            "a5d5ee44dfe21839",
            "5c73574c1a191af3"
        ],
        "x": 34,
        "y": 39,
        "w": 772,
        "h": 82
    },
    {
        "id": "2ffb0ad1ec6c4336",
        "type": "group",
        "z": "296b81230a5aed2a",
        "name": "onduleur 2",
        "style": {
            "label": true
        },
        "nodes": [
            "9900a8c0b8fb0ade",
            "9fd6ea60084d9aba",
            "423279481f2891e9"
        ],
        "x": 34,
        "y": 159,
        "w": 772,
        "h": 82
    },
    {
        "id": "8b109ad885d98582",
        "type": "group",
        "z": "296b81230a5aed2a",
        "name": "onduleur 3",
        "style": {
            "label": true
        },
        "nodes": [
            "05595a6f316d37e4",
            "b49da1eb9e7aeb60",
            "fd3b9f314f1f6121"
        ],
        "x": 34,
        "y": 279,
        "w": 772,
        "h": 82
    },
    {
        "id": "5886b0dc312a65e2",
        "type": "group",
        "z": "280951c3196085f3",
        "name": "onduleur 3",
        "style": {
            "label": true
        },
        "nodes": [
            "3723c166ecd597c8",
            "15d3edfa362fa487",
            "9cad9c70bd135ba1",
            "934204be298bcd3d",
            "4d6727a8daa54583",
            "3b468cc517e1fcaa",
            "81f39a65ee5f7e5f",
            "12e2da8864f63658",
            "8feb5755ad105131",
            "3f12c1ae87a1cc36",
            "b0cf0a62812a68fe",
            "235c705debdbb1ae",
            "45c1028f3ead8766",
            "498a02e4859e8220",
            "636d882818322eec",
            "49440ecbca3993df",
            "f2b75a0a86b82097"
        ],
        "x": 14,
        "y": 599,
        "w": 1192,
        "h": 262
    },
    {
        "id": "mqtt_broker",
        "type": "mqtt-broker",
        "name": "HA MQTT Broker",
        "broker": "${MQTT_HOST}",
        "port": "${MQTT_PORT}",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "c546b54ae425b9d2",
        "type": "serial-port",
        "name": "",
        "serialport": "__SERIAL_1__",
        "serialbaud": "2400",
        "databits": "8",
        "parity": "none",
        "stopbits": "1",
        "waitfor": "",
        "dtr": "none",
        "rts": "none",
        "cts": "none",
        "dsr": "none",
        "newline": "\\r",
        "bin": "bin",
        "out": "char",
        "addchar": "",
        "responsetimeout": "3000"
    },
    {
        "id": "55a40ce3e960db15",
        "type": "serial-port",
        "name": "",
        "serialport": "__SERIAL_2__",
        "serialbaud": "2400",
        "databits": "8",
        "parity": "none",
        "stopbits": "1",
        "waitfor": "",
        "dtr": "none",
        "rts": "none",
        "cts": "none",
        "dsr": "none",
        "newline": "\\r",
        "bin": "bin",
        "out": "char",
        "addchar": "",
        "responsetimeout": "3000"
    },
    {
        "id": "39e06a015d18096d",
        "type": "serial-port",
        "name": "",
        "serialport": "__SERIAL_3__",
        "serialbaud": "2400",
        "databits": 8,
        "parity": "none",
        "stopbits": 1,
        "waitfor": "",
        "dtr": "none",
        "rts": "none",
        "cts": "none",
        "dsr": "none",
        "newline": "\\r",
        "bin": "bin",
        "out": "char",
        "addchar": "",
        "responsetimeout": "3000"
    },
    {
        "id": "ae5c8da7ec1307dc",
        "type": "inject",
        "z": "ca0b537221e236b6",
        "name": "init config",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 80,
        "y": 60,
        "wires": [
            [
                "f2494e47753be160"
            ]
        ]
    },
    {
        "id": "f2494e47753be160",
        "type": "file in",
        "z": "ca0b537221e236b6",
        "name": "",
        "filename": "/data/options.json",
        "filenameType": "str",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "encoding": "none",
        "allProps": false,
        "x": 270,
        "y": 60,
        "wires": [
            [
                "fa2cedb5d020e0d8"
            ]
        ]
    },
    {
        "id": "fa2cedb5d020e0d8",
        "type": "function",
        "z": "ca0b537221e236b6",
        "name": "parse options",
        "func": "let opts;\ntry {\n  opts = JSON.parse(msg.payload);\n} catch (e) {\n  node.error(\"options.json invalide: \" + e.toString(), msg);\n  node.status({ fill: \"red\", shape: \"ring\", text: \"options.json invalide\" });\n  return null;\n}\n\nconst serialPorts = (opts.serial_ports || [])\n  .filter(p => typeof p === \"string\")\n  .map(p => p.trim())\n  .filter(p => p.length > 0);\n\n// ‚úÖ s√©curit√©: ne pas √©craser une config existante avec une liste vide\nif (serialPorts.length === 0) {\n  const existing = global.get(\"config.serialPorts\") || [];\n  global.set(\"config.invertersCount\", existing.length); // ‚úÖ important\n  node.warn(\"Init: serial_ports vide -> on ne remplace pas la config existante (\" + existing.length + \" port(s))\");\n  node.status({ fill: \"yellow\", shape: \"ring\", text: `serial_ports vide (garde ${existing.length})` });\n  msg.payload = { inverters: existing.length, serialPorts: existing, skipped: true };\n  return msg;\n}\n\nconst mqttConfig = {\n  baseTopic: opts.mqtt_prefix || \"voltronic\",\n  discoveryPrefix: \"homeassistant\",\n  deviceName: \"Onduleur Voltronic\",\n  broker: opts.mqtt_host || \"core-mosquitto\",\n  port: opts.mqtt_port || 1883\n};\n\n// ‚úÖ polling fast robuste\nconst fastSecRaw = (opts.polling_fast ?? opts.polling?.fast ?? 5);\nconst fastSec = Number(fastSecRaw);\nconst pollingFastMs = (Number.isFinite(fastSec) && fastSec > 0 ? fastSec : 5) * 1000;\n\n// ‚úÖ √©crire la config globale\nglobal.set(\"config.serialPorts\", serialPorts);\nglobal.set(\"config.mqtt\", mqttConfig);\nglobal.set(\"config.pollingFastMs\", pollingFastMs);\n\n// ‚úÖ nettoyer d'anciens slots si le nombre de ports a diminu√©\nconst prevCount = global.get(\"config.invertersCount\") || 0;\nfor (let i = serialPorts.length + 1; i <= prevCount; i++) {\n  global.set(`inverter_${i}.port`, null);\n  global.set(`inverter_${i}.data`, {});\n  global.set(`inverter_${i}.lastUpdate`, 0);\n}\nglobal.set(\"config.invertersCount\", serialPorts.length);\n\n// ‚úÖ initialiser autant d'onduleurs que de ports\nfor (let i = 0; i < serialPorts.length; i++) {\n  const inverterNum = i + 1;\n  global.set(`inverter_${inverterNum}.port`, serialPorts[i]);\n  if (!global.get(`inverter_${inverterNum}.data`)) global.set(`inverter_${inverterNum}.data`, {});\n  global.set(`inverter_${inverterNum}.lastUpdate`, 0);\n}\n\nnode.status({\n  fill: \"green\",\n  shape: \"dot\",\n  text: `Config OK (${serialPorts.length} port(s))`\n});\n\nmsg.payload = {\n  inverters: serialPorts.length,\n  serialPorts,\n  mqtt: { broker: mqttConfig.broker, port: mqttConfig.port, baseTopic: mqttConfig.baseTopic },\n  pollingFastMs\n};\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 60,
        "wires": [
            [
                "20784343c1215897"
            ]
        ]
    },
    {
        "id": "20784343c1215897",
        "type": "debug",
        "z": "ca0b537221e236b6",
        "name": "debug 2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 680,
        "y": 60,
        "wires": []
    },
    {
        "id": "e84f90f9a3664b13",
        "type": "inject",
        "z": "ca0b537221e236b6",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 90,
        "y": 160,
        "wires": [
            [
                "d9dbd753121d3c9a"
            ]
        ]
    },
    {
        "id": "d9dbd753121d3c9a",
        "type": "function",
        "z": "ca0b537221e236b6",
        "name": "function 1",
        "func": "// INIT helpers - √† lancer une fois au d√©marrage\nif (!global.get(\"helpers\")) global.set(\"helpers\", {});\n\nconst helpers = global.get(\"helpers\");\n\nif (typeof helpers.buildVoltronicCommand !== \"function\") {\n  function crc16_xmodem(buf) {\n    let crc = 0x0000;\n    for (const b of buf) {\n      crc ^= (b << 8);\n      for (let i = 0; i < 8; i++) {\n        crc = (crc & 0x8000) ? ((crc << 1) ^ 0x1021) : (crc << 1);\n        crc &= 0xFFFF;\n      }\n    }\n    return crc & 0xFFFF;\n  }\n\n  helpers.buildVoltronicCommand = function (cmd) {\n    cmd = (cmd || \"\").toString().trim();\n    const data = Buffer.from(cmd, \"ascii\");\n    const crc = crc16_xmodem(data);\n    const frame = Buffer.alloc(data.length + 3);\n    data.copy(frame, 0);\n    frame.writeUInt16BE(crc, data.length);\n    frame[frame.length - 1] = 0x0D; // \\r\n    return frame;\n  };\n\n  global.set(\"helpers\", helpers);\n}\n\nnode.status({ fill: \"green\", shape: \"dot\", text: \"helpers OK\" });\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 340,
        "y": 160,
        "wires": [
            []
        ]
    },
    {
        "id": "da6ab8ea42e3c773",
        "type": "serial out",
        "z": "280951c3196085f3",
        "g": "7ec01c3a3046742d",
        "name": "üì§ Serial Out 2",
        "serial": "55a40ce3e960db15",
        "x": 1080,
        "y": 400,
        "wires": []
    },
    {
        "id": "3771ead040fae605",
        "type": "serial in",
        "z": "280951c3196085f3",
        "g": "7ec01c3a3046742d",
        "name": "üì• Serial In 2",
        "serial": "55a40ce3e960db15",
        "x": 130,
        "y": 460,
        "wires": [
            [
                "0967f976f3607b87"
            ]
        ]
    },
    {
        "id": "e4d2c8d8e64970ac",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "57656369260fdee6",
        "name": "construire commande ",
        "func": "// ====== CONSTRUIRE COMMANDE (Voltronic) ======\nconst helpers = global.get(\"helpers\");\n\nif (!helpers || typeof helpers.buildVoltronicCommand !== \"function\") {\n  node.error(\"helpers.buildVoltronicCommand introuvable (global.helpers)\");\n  return null;\n}\n\n// R√©cup√®re la commande (priorit√© √† msg.command)\nlet cmd = (msg.command ?? msg._cmd ?? msg.payload ?? \"\").toString().trim().toUpperCase();\n\nif (!cmd) {\n  node.warn(\"Commande vide -> ignor√©e\");\n  return null;\n}\n\n// S√©curit√©: commande uniquement alphanum (Voltronic = lettres/chiffres)\nif (!/^[A-Z0-9]+$/.test(cmd)) {\n  node.warn(`Commande invalide ignor√©e: \"${cmd}\"`);\n  return null;\n}\n\n// Conserver la commande envoy√©e (utile pour associer RX)\nmsg.command = cmd;\nmsg._cmd = cmd;\n\n// Construire la trame (CRC + CR)\nconst buf = helpers.buildVoltronicCommand(cmd);\n\n// Payload = Buffer √† envoyer dans Serial Out\nmsg.payload = buf;\n\n// Debug utile\nmsg._tx_ts = Date.now();\nmsg._tx_ascii = cmd;\nmsg._tx_hex = buf.toString(\"hex\");\n\n// Status (optionnel)\nnode.status({\n  fill: \"blue\",\n  shape: \"dot\",\n  text: `${cmd} ‚Üí ond${msg.inverterNum ?? \"?\"}`\n});\n\n// m√©morise la derni√®re commande par onduleur\nif (msg.inverterNum != null) {\n  flow.set(`inv${msg.inverterNum}_last_cmd`, msg._cmd);\n  flow.set(`inv${msg.inverterNum}_last_cmd_ts`, Date.now());\n}\n\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 860,
        "y": 100,
        "wires": [
            [
                "32b643591e2b04ed"
            ]
        ]
    },
    {
        "id": "32b643591e2b04ed",
        "type": "serial out",
        "z": "280951c3196085f3",
        "g": "57656369260fdee6",
        "name": "üì§ Serial Out 1",
        "serial": "c546b54ae425b9d2",
        "x": 1080,
        "y": 100,
        "wires": []
    },
    {
        "id": "70182d375061cbef",
        "type": "serial in",
        "z": "280951c3196085f3",
        "g": "57656369260fdee6",
        "name": "üì• Serial In 1",
        "serial": "c546b54ae425b9d2",
        "x": 130,
        "y": 160,
        "wires": [
            [
                "2c9a803f94dce0bb"
            ]
        ]
    },
    {
        "id": "fd71ee45ebc28f61",
        "type": "inject",
        "z": "280951c3196085f3",
        "g": "57656369260fdee6",
        "name": "ond1",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "0.5",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 110,
        "y": 100,
        "wires": [
            [
                "286da83a35d93180"
            ]
        ]
    },
    {
        "id": "286da83a35d93180",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "57656369260fdee6",
        "name": "requetes",
        "func": "// ====== REQUETES (Option A + firstRun + force + QPIGS2 auto-disable + retry 1h + DIAG) ======\nconst inverterNum = 1;\nconst ts = Date.now();\nconst now = new Date();\n\nconst pad2 = (n) => String(n).padStart(2, \"0\");\nconst yyyy = now.getFullYear();\nconst mm = pad2(now.getMonth() + 1);\nconst dd = pad2(now.getDate());\n\nconst yyyymm = `${yyyy}${mm}`;\nconst yyyymmdd = `${yyyy}${mm}${dd}`;\n\n// √©tat alternance\nlet alt = context.get(\"alt\");\nif (alt === undefined || alt === null) alt = 0;\n\n// firstRun peut rester false si context persistant\nlet firstRun = context.get(\"firstRun\");\nif (firstRun === undefined) firstRun = true;\n\n// Permet de forcer un burst via un inject bouton (msg.forceFirstRun=true)\nif (msg && msg.forceFirstRun === true) {\n  firstRun = true;\n}\n\n// timers existants\nlet nextQMOD = context.get(\"nextQMOD\");\nlet nextHour = context.get(\"nextHour\");\nlet nextDay10m = context.get(\"nextDay10m\");\nlet nextMonth6 = context.get(\"nextMonth6\");\nlet nextYear24 = context.get(\"nextYear24\");\n\n// timers params\nlet nextQPIRI = context.get(\"nextQPIRI\");\nlet nextQDOP = context.get(\"nextQDOP\");\n\n// retry QPIGS2 m√™me si d√©sactiv√©\nlet nextRetryQPIGS2 = context.get(\"nextRetryQPIGS2\");\nif (!nextRetryQPIGS2) nextRetryQPIGS2 = ts + 60 * 60 * 1000;\n\n// ‚úÖ DIAG timers\nlet diagDone = context.get(\"diagDone\");           // 1-shot after boot\nlet nextQPIWS = context.get(\"nextQPIWS\");         // 5 min\n\nfunction makeCmd(cmd) {\n  return { inverterNum, command: cmd, _cmd: cmd, payload: cmd };\n}\n\nconst msgs = [];\n\n// ----- QPIGS/QPIGS2 strat√©gie -----\nconst supportsQPIGS2 = flow.get(`inv${inverterNum}_supports_qpigs2`);\nconst useQPIGS2 = (supportsQPIGS2 !== false);\n\nfunction pushRealtimeTick() {\n  if (useQPIGS2) {\n    msgs.push(makeCmd(alt === 0 ? \"QPIGS\" : \"QPIGS2\"));\n    alt = alt ? 0 : 1;\n  } else {\n    msgs.push(makeCmd(\"QPIGS\"));\n    if (ts >= nextRetryQPIGS2) {\n      msgs.push(makeCmd(\"QPIGS2\"));\n      nextRetryQPIGS2 = ts + 60 * 60 * 1000;\n    }\n  }\n}\n\n// 1) tick realtime\npushRealtimeTick();\n\n// 2) Burst imm√©diat + DIAG one-shot\nif (firstRun) {\n  const burst = [\n    // realtime infos\n    \"QMOD\",\n\n    // energies\n    \"QET\", `QEY${yyyy}`, `QEM${yyyymm}`, `QED${yyyymmdd}`,\n    \"QLT\", `QLY${yyyy}`, `QLM${yyyymm}`, `QLD${yyyymmdd}`,\n\n    // ‚úÖ DIAG (1 fois au boot)\n    \"QMN\",      // model\n    \"QID\",      // serial (si besoin: remplacer par QSID)\n    \"QVFW\",     // fw main\n    \"QVFW3\",    // fw remote/panel (si support√©)\n    \"QPIWS\"     // warnings/faults (1er √©tat)\n  ];\n  burst.forEach(c => msgs.push(makeCmd(c)));\n\n  // schedules\n  nextQMOD = ts + 5 * 60 * 1000;\n  nextHour = ts + 60 * 60 * 1000;\n  nextDay10m = ts + 10 * 60 * 1000;\n  nextMonth6 = ts + 6 * 60 * 60 * 1000;\n  nextYear24 = ts + 24 * 60 * 60 * 1000;\n\n  nextQPIRI = ts + 5 * 60 * 1000;\n  nextQDOP = ts + 5 * 60 * 1000;\n\n  // ‚úÖ DIAG flags/timers\n  diagDone = true;\n  nextQPIWS = ts + 5 * 60 * 1000;\n\n  firstRun = false;\n  node.status({ fill: \"green\", shape: \"dot\", text: `FIRST RUN: ${msgs.length} cmds` });\n\n} else {\n\n  // QMOD 5 min\n  if (nextQMOD == null) nextQMOD = ts + 5 * 60 * 1000;\n  if (ts >= nextQMOD) {\n    msgs.push(makeCmd(\"QMOD\"));\n    nextQMOD = ts + 5 * 60 * 1000;\n  }\n\n  // QPIRI 5 min\n  if (nextQPIRI == null) nextQPIRI = ts + 5 * 60 * 1000;\n  if (ts >= nextQPIRI) {\n    msgs.push(makeCmd(\"QPIRI\"));\n    nextQPIRI = ts + 5 * 60 * 1000;\n  }\n\n  // QDOP 5 min\n  if (nextQDOP == null) nextQDOP = ts + 5 * 60 * 1000;\n  if (ts >= nextQDOP) {\n    msgs.push(makeCmd(\"QDOP\"));\n    nextQDOP = ts + 5 * 60 * 1000;\n  }\n\n  // ‚úÖ QPIWS (fault/warnings) 5 min\n  if (nextQPIWS == null) nextQPIWS = ts + 5 * 60 * 1000;\n  if (ts >= nextQPIWS) {\n    msgs.push(makeCmd(\"QPIWS\"));\n    nextQPIWS = ts + 5 * 60 * 1000;\n  }\n\n  // Hourly\n  if (nextHour == null) nextHour = ts + 60 * 60 * 1000;\n  if (ts >= nextHour) {\n    msgs.push(makeCmd(\"QET\"));\n    msgs.push(makeCmd(\"QLT\"));\n    nextHour = ts + 60 * 60 * 1000;\n  }\n\n  // Daily 10min\n  if (nextDay10m == null) nextDay10m = ts + 10 * 60 * 1000;\n  if (ts >= nextDay10m) {\n    msgs.push(makeCmd(`QED${yyyymmdd}`));\n    msgs.push(makeCmd(`QLD${yyyymmdd}`));\n    nextDay10m = ts + 10 * 60 * 1000;\n  }\n\n  // Monthly 6h\n  if (nextMonth6 == null) nextMonth6 = ts + 6 * 60 * 60 * 1000;\n  if (ts >= nextMonth6) {\n    msgs.push(makeCmd(`QEM${yyyymm}`));\n    msgs.push(makeCmd(`QLM${yyyymm}`));\n    nextMonth6 = ts + 6 * 60 * 60 * 1000;\n  }\n\n  // Yearly 24h\n  if (nextYear24 == null) nextYear24 = ts + 24 * 60 * 60 * 1000;\n  if (ts >= nextYear24) {\n    msgs.push(makeCmd(`QEY${yyyy}`));\n    msgs.push(makeCmd(`QLY${yyyy}`));\n    nextYear24 = ts + 24 * 60 * 60 * 1000;\n  }\n}\n\n// save\ncontext.set(\"alt\", alt);\ncontext.set(\"firstRun\", firstRun);\ncontext.set(\"nextQMOD\", nextQMOD);\ncontext.set(\"nextHour\", nextHour);\ncontext.set(\"nextDay10m\", nextDay10m);\ncontext.set(\"nextMonth6\", nextMonth6);\ncontext.set(\"nextYear24\", nextYear24);\ncontext.set(\"nextQPIRI\", nextQPIRI);\ncontext.set(\"nextQDOP\", nextQDOP);\ncontext.set(\"nextRetryQPIGS2\", nextRetryQPIGS2);\n\n// ‚úÖ save DIAG\ncontext.set(\"diagDone\", diagDone);\ncontext.set(\"nextQPIWS\", nextQPIWS);\n\nreturn [msgs];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 240,
        "y": 100,
        "wires": [
            [
                "4e49dec8b23d003f"
            ]
        ]
    },
    {
        "id": "2c9a803f94dce0bb",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "57656369260fdee6",
        "name": "parser 1",
        "func": "// ====== PARSER 1 (Voltronic) - QUEUE MODE ======\n// Entr√©e: msg.payload = Buffer (Serial IN en \"a single buffer\", pas de split)\n// Sorties:\n//   1) trigger pump (msg.topic=\"pump\")\n//   2) data pars√©e (vers normalize state)\n// Associe la r√©ponse √† la commande \"inflight\" (envoy√©e par Queue Pump)\n\nconst inv = msg.inverterNum ?? 1;\nif (!Buffer.isBuffer(msg.payload)) return null;\n\n// --- accumulateur RX ---\nlet rx = context.get(\"rxbuf\");\nif (!Buffer.isBuffer(rx)) rx = Buffer.alloc(0);\n\n// s√©curit√© overflow\nif (rx.length > 8192) rx = Buffer.alloc(0);\n\n// concat\nrx = Buffer.concat([rx, msg.payload]);\n\nconst CR = 0x0D;\n\n// extrait toutes les frames finissant par CR\nconst frames = [];\nwhile (true) {\n  const idx = rx.indexOf(CR);\n  if (idx === -1) break;\n  frames.push(rx.slice(0, idx + 1));\n  rx = rx.slice(idx + 1);\n}\ncontext.set(\"rxbuf\", rx);\n\nif (!frames.length) return null;\n\n// commande inflight (celle r√©ellement envoy√©e)\nconst inflightKey = `inv${inv}_inflight`;\nconst inflight = flow.get(inflightKey);\nconst inflightCmd = inflight?.cmd || \"UNKNOWN\";\n\n// Nettoyage trame -> ASCII sans CRC/CR\nfunction cleanAsciiFromFrame(frameBuf) {\n  // NAK brut possible (0x15)\n  if (frameBuf.length === 1 && frameBuf[0] === 0x15) return \"NAK\";\n\n  // Normalement: <data ASCII> + <CRC 2 bytes> + <CR>\n  let dataBuf = frameBuf;\n\n  if (frameBuf.length >= 3 && frameBuf[frameBuf.length - 1] === CR) {\n    dataBuf = frameBuf.slice(0, -3); // retire CRC(2) + CR(1)\n  } else if (frameBuf.length >= 1 && frameBuf[frameBuf.length - 1] === CR) {\n    dataBuf = frameBuf.slice(0, -1); // fallback retire CR\n  }\n\n  return dataBuf.toString(\"ascii\");\n}\n\nfunction parseFrame(frameBuf, cmd) {\n  const ascii = cleanAsciiFromFrame(frameBuf);\n\n  // D√©tection NAK \"NAK\" ou 0x15\n  if (ascii.includes(\"NAK\") || ascii === \"NAK\") {\n    return {\n      inverter: inv,\n      command: cmd,\n      nak: true,\n      raw: \"NAK\",\n      fields: [],\n      nums: [],\n      value: null\n    };\n  }\n\n  // Enlever parenth√®ses si pr√©sentes\n  let body = ascii.trim();\n  if (body.startsWith(\"(\")) body = body.slice(1);\n  if (body.endsWith(\")\")) body = body.slice(0, -1);\n  body = body.trim();\n\n  const fields = body.length ? body.split(/\\s+/) : [];\n  const nums = fields.map(v => {\n    const n = Number(v);\n    return Number.isFinite(n) ? n : null;\n  });\n\n  // Cas √©nergie (1 valeur)\n  const isEnergyCmd = /^Q(E[TYMD]|L[TYMD])/.test(cmd);\n  let value = null;\n  if (isEnergyCmd && fields.length >= 1) {\n    const n0 = Number(fields[0]);\n    if (Number.isFinite(n0)) value = n0;\n  }\n\n  return {\n    inverter: inv,\n    command: cmd,\n    raw: body,\n    fields,\n    nums,\n    value\n  };\n}\n\n// Ici, on part du principe QUEUE = 1 commande envoy√©e -> 1 r√©ponse attendue.\n// Mais on g√®re quand m√™me le cas \"plusieurs frames d'un coup\" :\n// - 1√®re frame = inflightCmd\n// - frames suivantes = UNKNOWN (ou on garde inflightCmd si tu pr√©f√®res)\nconst outMsgs = [];\nfor (let i = 0; i < frames.length; i++) {\n  const cmd = (i === 0) ? inflightCmd : \"UNKNOWN\";\n  outMsgs.push({\n    inverterNum: inv,\n    _cmd: cmd,\n    command: cmd,\n    payload: parseFrame(frames[i], cmd),\n    _rx_ts: Date.now()\n  });\n}\n\n// ACK : d√®s qu'on re√ßoit au moins une frame, on lib√®re inflight\nflow.set(inflightKey, null);\n\n// Trigger pump imm√©diatement (pour envoyer la prochaine commande)\nconst pumpMsg = { inverterNum: inv, topic: \"pump\" };\n\n// Sortie 1: pump trigger\n// Sortie 2: data pars√©e (plusieurs messages possibles)\nreturn [[pumpMsg], outMsgs];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 280,
        "y": 160,
        "wires": [
            [
                "71f23c568f360d5b"
            ],
            [
                "957af781b779e33e"
            ]
        ]
    },
    {
        "id": "589f82c1423c9842",
        "type": "mqtt out",
        "z": "280951c3196085f3",
        "g": "57656369260fdee6",
        "name": "ond1",
        "topic": "",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "mqtt_broker",
        "x": 930,
        "y": 160,
        "wires": []
    },
    {
        "id": "957af781b779e33e",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "57656369260fdee6",
        "name": "normalize state",
        "func": "// ====== NORMALIZE STATE (AUTO / MULTI-MODEL) - + SCC BATTERY VOLTAGE + DIAG + MORE PRECISION ======\nif (!msg.payload || typeof msg.payload !== \"object\") return null;\n\nconst inv = msg.inverterNum ?? msg.payload.inverter ?? 1;\n\n// Normaliser la commande (√©vite \"QPIRI\\r\", \"qpiri\", \"QPIRI \")\nconst cmd = String(msg.payload.command || msg.command || msg._cmd || \"UNKNOWN\")\n  .trim()\n  .toUpperCase();\n\nconst f = Array.isArray(msg.payload.fields) ? msg.payload.fields : [];\nconst n = Array.isArray(msg.payload.nums) ? msg.payload.nums : [];\nconst value = msg.payload.value;\n\nlet state = context.get(\"state\");\nif (!state || typeof state !== \"object\") state = {};\n\n// helpers\nconst num = (idx) => (Number.isFinite(n[idx]) ? n[idx] : null);\nconst int = (idx) => {\n  const v = num(idx);\n  return v == null ? null : Math.trunc(v);\n};\nconst round = (v, d) => {\n  const nn = Number(v);\n  if (!Number.isFinite(nn)) return null;\n  const m = 10 ** d;\n  return Math.round(nn * m) / m;\n};\n\n// --- apprentissage index pv1_power par node (donc par inverter) ---\nlet pv1PowerIdx = context.get(\"pv1PowerIdx\"); // m√©moris√© par node\n\n// ===== QPIGS =====\nif (cmd === \"QPIGS\" && f.length >= 16) {\n  // Champs communs (stables)\n  if (f.length > 0) state.grid_voltage = round(num(0), 1);\n  if (f.length > 1) state.grid_frequency = round(num(1), 1);\n  if (f.length > 2) state.ac_output_voltage = round(num(2), 1);\n  if (f.length > 3) state.ac_output_frequency = round(num(3), 1);\n\n  // Apparent/active/load : souvent 4/5/6\n  if (f.length > 4) state.ac_output_apparent_power = int(4); // (optionnel utile)\n  if (f.length > 5) state.ac_output_active_power = int(5);\n  if (f.length > 6) state.output_load_percent = int(6);\n\n  // bus voltage : souvent 7\n  if (f.length > 7) state.bus_voltage = int(7);\n\n  // ‚úÖ Batterie : tension 2 d√©cimales, courants 1 d√©cimale\n  if (f.length > 8) state.battery_voltage = round(num(8), 2);\n  if (f.length > 9) state.battery_charging_current = round(num(9), 1);\n  if (f.length > 10) state.battery_capacity = int(10);\n  if (f.length > 11) state.inverter_heat_sink_temp = int(11);\n\n  // PV entr√©e : souvent 12/13\n  if (f.length > 12) state.pv1_input_current = round(num(12), 1);\n  if (f.length > 13) state.pv1_input_voltage = round(num(13), 1);\n\n  // ‚úÖ NOUVEAU SENSOR : Battery voltage from SCC (WW.WW) -> champ 15 => index 14 (selon TES trames)\n  if (f.length > 14) state.battery_voltage_from_scc = round(num(14), 2);\n\n  // ‚úÖ Discharge current : champ 16 => index 15 (selon TES trames)\n  if (f.length > 15) state.battery_discharge_current = round(num(15), 1);\n\n  // ---- PV1 Power : auto\n  if (pv1PowerIdx != null && f.length > pv1PowerIdx) {\n    state.pv1_power = int(pv1PowerIdx);\n  } else {\n    const candidates = [19, 20, 18, 17, 16]; // variantes connues\n    for (const idx of candidates) {\n      if (f.length > idx && Number.isFinite(n[idx])) {\n        const I = state.pv1_input_current;\n        const V = state.pv1_input_voltage;\n        const pCalc = (Number.isFinite(I) && Number.isFinite(V)) ? (I * V) : null;\n        const pField = n[idx];\n\n        if (pCalc != null && pCalc > 10) {\n          const ratio = pField / pCalc;\n          if (ratio > 0.8 && ratio < 1.2) {\n            pv1PowerIdx = idx;\n            context.set(\"pv1PowerIdx\", pv1PowerIdx);\n            state.pv1_power = int(idx);\n            break;\n          }\n        } else {\n          if (idx === 19) {\n            state.pv1_power = int(19);\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  state._last_qpigs_ts = Date.now();\n}\n\n// ===== NOUVEAU : GRID POWER (champ 25 firmwares r√©cents)\nif (f.length > 24 && Number.isFinite(n[24])) {\n  state.grid_power = int(24);\n}\n\n\n// ===== QPIGS2 (optionnel) =====\nif (cmd === \"QPIGS2\" && f.length >= 3) {\n  state.pv2_input_current = round(num(0), 1);\n  state.pv2_input_voltage = round(num(1), 1);\n  state.pv2_power = int(2);\n  state._last_qpigs2_ts = Date.now();\n}\n\n// ===== QMOD =====\nif (cmd === \"QMOD\") {\n  const rawMode = (f[0] ?? msg.payload.raw ?? \"\").toString().trim();\n  const modeMap = { P: \"Power On\", S: \"Standby\", L: \"Grid\", B: \"Battery\", F: \"Fault\" };\n  state.operation_mode = modeMap[rawMode] || rawMode || null;\n  state.operation_mode_code = rawMode || null;\n  state._last_qmod_ts = Date.now();\n}\n\n// ===== QPIRI -> PARAMETRES =====\nif (cmd === \"QPIRI\" && msg.payload?.nak !== true) {\n  const nf = (idx) => {\n    const v = (f && f.length > idx) ? f[idx] : null;\n    const nn = Number(v);\n    return Number.isFinite(nn) ? nn : null;\n  };\n\n  const mapBatteryType = (code) => {\n    const m = { 0: \"AGM\", 1: \"Flooded\", 2: \"User\", 3: \"Pylon\", 5: \"Weco\", 6: \"Soltaro\", 8: \"Lib\", 9: \"Lic\" };\n    return m[code] ?? String(code ?? \"\");\n  };\n  const mapOutputPriority = (code) => {\n    const m = { 0: \"UtilitySolarBat\", 1: \"SolarUtilityBat\", 2: \"SolarBatUtility\" };\n    return m[code] ?? String(code ?? \"\");\n  };\n  const mapChargerPriority = (code) => {\n    const m = { 1: \"Solar first\", 2: \"Solar + Utility\", 3: \"Only solar\" };\n    return m[code] ?? String(code ?? \"\");\n  };\n\n  if (!state.params || typeof state.params !== \"object\") state.params = {};\n\n  const battTypeCode = nf(12);\n  const outPrioCode = nf(16);\n  const chgPrioCode = nf(17);\n\n  state.params.qpiri = {\n    battery_recharge_voltage: nf(8),\n    battery_under_voltage: nf(9),\n    battery_bulk_voltage: nf(10),\n    battery_float_voltage: nf(11),\n\n    battery_type_code: battTypeCode,\n    battery_type: mapBatteryType(battTypeCode),\n\n    max_ac_charging_current: nf(13),\n    max_charging_current: nf(14),\n\n    output_source_priority_code: outPrioCode,\n    output_source_priority: mapOutputPriority(outPrioCode),\n\n    charger_source_priority_code: chgPrioCode,\n    charger_source_priority: mapChargerPriority(chgPrioCode),\n\n    battery_re_discharge_voltage: nf(22),\n    max_discharging_current: nf(27),\n\n    ts: Date.now()\n  };\n\n  state._last_qpiri_ts = Date.now();\n}\n\n// ===== QDOP -> PARAMETRES batterie (%) =====\nif (cmd === \"QDOP\" && msg.payload?.nak !== true) {\n  const nf = (idx) => {\n    const v = (f && f.length > idx) ? f[idx] : null;\n    const nn = Number(v);\n    return Number.isFinite(nn) ? nn : null;\n  };\n\n  if (!state.params || typeof state.params !== \"object\") state.params = {};\n\n  state.params.qdop = {\n    battery_recharge_capacity_pct: nf(8),\n    battery_redischarge_capacity_pct: nf(9),\n    battery_under_capacity_pct: nf(10),\n    ts: Date.now()\n  };\n\n  state._last_qdop_ts = Date.now();\n}\n\n// ===== DIAGNOSTIC (model/serial/fw + faults/warnings) =====\nif (cmd === \"QMN\" && msg.payload?.nak !== true) {\n  state.diag = state.diag || {};\n  state.diag.model = (f[0] ?? msg.payload.raw ?? \"\").toString().trim() || null;\n  state._last_qmn_ts = Date.now();\n}\n\nif ((cmd === \"QID\" || cmd === \"QSID\") && msg.payload?.nak !== true) {\n  state.diag = state.diag || {};\n  state.diag.serial = (f[0] ?? msg.payload.raw ?? \"\").toString().trim() || null;\n  state._last_qid_ts = Date.now();\n}\n\nif ((cmd === \"QVFW\" || cmd === \"QVFW3\") && msg.payload?.nak !== true) {\n  state.diag = state.diag || {};\n  const fw = (f[0] ?? msg.payload.raw ?? \"\").toString().trim() || null;\n  if (cmd === \"QVFW\") state.diag.fw_main = fw;\n  if (cmd === \"QVFW3\") state.diag.fw_remote = fw;\n  state._last_qvfw_ts = Date.now();\n}\n\n// ===== QPIWS -> FAULTS / WARNINGS (4 lignes HA) =====\nif (cmd === \"QPIWS\" && msg.payload?.nak !== true) {\n\n  const bits = String(f[0] ?? msg.payload.raw ?? \"\").trim();\n  if (!state.diag || typeof state.diag !== \"object\") state.diag = {};\n\n  const bit = (i) => (bits.length > i ? bits.charAt(i) === \"1\" : false);\n  const a1_fault = bit(1);\n\n  // Mapping QPIWS (principaux) - adapt√© doc\n  const map = [\n    { i: 0, label: \"PV loss\", kind: \"warn\" },\n    { i: 1, label: \"Inverter fault\", kind: \"fault\" },\n    { i: 2, label: \"Bus over\", kind: \"fault\" },\n    { i: 3, label: \"Bus under\", kind: \"fault\" },\n    { i: 4, label: \"Bus soft fail\", kind: \"fault\" },\n    { i: 5, label: \"Line fail\", kind: \"warn\" },\n    { i: 6, label: \"OPV short\", kind: \"fault\" },\n    { i: 7, label: \"Inverter voltage low\", kind: \"fault\" },\n    { i: 8, label: \"Inverter voltage high\", kind: \"fault\" },\n\n    // \"Compile with a1\" -> peut √™tre warning ou fault selon a1\n    { i: 9, label: \"Over temperature\", kind: () => a1_fault ? \"fault\" : \"warn\" },\n    { i: 10, label: \"Fan locked\", kind: () => a1_fault ? \"fault\" : \"warn\" },\n    { i: 11, label: \"Battery voltage high\", kind: () => a1_fault ? \"fault\" : \"warn\" },\n\n    { i: 12, label: \"Battery low alarm\", kind: \"warn\" },\n    { i: 14, label: \"Battery shutdown\", kind: \"warn\" },\n    { i: 15, label: \"Battery derating\", kind: \"warn\" },\n    { i: 16, label: \"Over load\", kind: () => a1_fault ? \"fault\" : \"warn\" },\n\n    { i: 17, label: \"EEPROM fault\", kind: \"warn\" },\n    { i: 18, label: \"Inverter over current\", kind: \"fault\" },\n    { i: 19, label: \"Inverter soft fail\", kind: \"fault\" },\n    { i: 20, label: \"Self test fail\", kind: \"fault\" },\n    { i: 21, label: \"OP DC voltage over\", kind: \"fault\" },\n    { i: 23, label: \"Current sensor fail\", kind: \"fault\" },\n\n    // VMIV sp√©cifiques (optionnels)\n    { i: 33, label: \"Low PV energy\", kind: \"warn\" },\n    { i: 34, label: \"High AC input\", kind: \"warn\" },\n    { i: 35, label: \"Battery equalization\", kind: \"warn\" }\n  ];\n\n  const faults = [];\n  const warns = [];\n\n  for (const m of map) {\n    if (!bit(m.i)) continue;\n    const k = (typeof m.kind === \"function\") ? m.kind() : m.kind;\n    if (k === \"fault\") faults.push(m.label);\n    else warns.push(m.label);\n  }\n\n  // ---- 4 lignes pour HA\n  state.diag.fault_state = faults.length ? \"FAULT\" : \"OK\";\n  state.diag.fault_details = faults.length ? faults.join(\", \") : \"None\";\n\n  state.diag.warn_state = warns.length ? \"WARN\" : \"OK\";\n  state.diag.warn_details = warns.length ? warns.join(\", \") : \"None\";\n\n  // bool utiles pour automations\n  state.diag.has_fault = faults.length > 0;\n  state.diag.has_warning = warns.length > 0;\n\n  state.diag._last_qpiws_ts = Date.now();\n}\n\n// ===== Support QPIGS2 (diagnostic) =====\nconst supportsKey = `inv${inv}_supports_qpigs2`;\nconst supports = flow.get(supportsKey);\nif (supports !== undefined) state.supports_qpigs2 = (supports !== false);\n\n// ===== ENERGIES (FIX Today) =====\nconst round2 = (v) => (v == null ? null : Math.round(v * 100) / 100);\nconst toKwhToday = (v) => (!Number.isFinite(v) ? null : round2(v / 1000));\nconst toKwhAuto = (v) => (!Number.isFinite(v) ? null : (v >= 10000 ? round2(v / 1000) : round2(v)));\n\nif (Number.isFinite(value)) {\n  // PV\n  if (cmd === \"QET\") { state.pv_energy_total_raw = value; state.pv_energy_total_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QEY\")) { state.pv_energy_year_raw = value; state.pv_energy_year_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QEM\")) { state.pv_energy_month_raw = value; state.pv_energy_month_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QED\")) { state.pv_energy_day_raw = value; state.pv_energy_day_kwh = toKwhToday(value); }\n\n  // LOAD\n  if (cmd === \"QLT\") { state.load_energy_total_raw = value; state.load_energy_total_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QLY\")) { state.load_energy_year_raw = value; state.load_energy_year_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QLM\")) { state.load_energy_month_raw = value; state.load_energy_month_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QLD\")) { state.load_energy_day_raw = value; state.load_energy_day_kwh = toKwhToday(value); }\n\n  state._last_energy_ts = Date.now();\n}\n\n// ===== PV total power =====\nconst pv1 = Number.isFinite(state.pv1_power) ? state.pv1_power : 0;\nconst pv2 = Number.isFinite(state.pv2_power) ? state.pv2_power : 0;\nstate.pv_total_power = pv1 + pv2;\n\n// ===== BATTERY POWER (W) - CUSTOM SENSORS =====\nconst Vb = Number.isFinite(state.battery_voltage) ? state.battery_voltage : null;\nconst Ichg = Number.isFinite(state.battery_charging_current) ? state.battery_charging_current : 0;\nconst Idis = Number.isFinite(state.battery_discharge_current) ? state.battery_discharge_current : 0;\n\nif (Vb != null) {\n  const chargeW = round(Vb * Math.max(0, Ichg), 1);\n  const dischargeW = round(Vb * Math.max(0, Idis), 1);\n\n  state.battery_charge = chargeW;              // +W\n  state.battery_discharge = dischargeW;        // +W\n  state.battery_power = (chargeW != null && dischargeW != null) ? round(chargeW - dischargeW, 1) : null;\n} else {\n  state.battery_charge = null;\n  state.battery_discharge = null;\n  state.battery_power = null;\n}\n\ncontext.set(\"state\", state);\nmsg.inverterNum = inv;\nmsg.payload = state;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 160,
        "wires": [
            [
                "6294edb213438cd0"
            ]
        ]
    },
    {
        "id": "6294edb213438cd0",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "57656369260fdee6",
        "name": "MQTT state publisher",
        "func": "if (!msg.payload || typeof msg.payload !== \"object\") return null;\n\nconst inv = msg.inverterNum ?? 1;\n\nreturn [\n    {\n        topic: `voltronic/${inv}/state`,\n        payload: JSON.stringify(msg.payload),\n        retain: false\n    },\n    {\n        topic: `voltronic/${inv}/availability`,\n        payload: \"online\",\n        retain: true\n    }\n];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 160,
        "wires": [
            [
                "589f82c1423c9842"
            ],
            [
                "589f82c1423c9842"
            ]
        ]
    },
    {
        "id": "4e49dec8b23d003f",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "57656369260fdee6",
        "name": "Queue Enqueue",
        "func": "const inv = msg.inverterNum ?? 1;\nconst key = `inv${inv}_queue`;\n\nlet q = flow.get(key);\nif (!Array.isArray(q)) q = [];\n\n// msg peut √™tre 1 commande, ou un lot (si tu envoies [msgs])\n// Ici, on g√®re les deux cas proprement.\nconst toPush = [];\n\nif (Array.isArray(msg)) {\n    // rare : si tu envoies direct un tableau de msgs\n    toPush.push(...msg);\n} else if (Array.isArray(msg.payload) && msg.payload?.[0]?.command) {\n    // si jamais ton flow passe un tableau dans payload\n    toPush.push(...msg.payload);\n} else {\n    // msg normal\n    toPush.push(msg);\n}\n\n// ajoute uniquement si on a une commande\ntoPush.forEach(m => {\n    const cmd = (m.command || m._cmd || m.payload || \"\").toString().trim().toUpperCase();\n    if (!cmd) return;\n\n    q.push({\n        inverterNum: inv,\n        command: cmd,\n        _cmd: cmd,\n        payload: cmd,\n        enqueued_ts: Date.now()\n    });\n});\n\n// limite taille\nif (q.length > 200) q = q.slice(-200);\n\nflow.set(key, q);\n\n// d√©clenche le pump\nreturn { inverterNum: inv, topic: \"pump\" };\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 100,
        "wires": [
            [
                "71f23c568f360d5b"
            ]
        ]
    },
    {
        "id": "71f23c568f360d5b",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "57656369260fdee6",
        "name": "Queue Pump",
        "func": "const inv = msg.inverterNum ?? 1;\n\nconst qKey = `inv${inv}_queue`;\nconst inFlightKey = `inv${inv}_inflight`;\n\nlet inFlight = flow.get(inFlightKey);\n\n// Si une commande est d√©j√† en attente de r√©ponse, on n‚Äôen envoie pas une autre\nif (inFlight && (Date.now() - (inFlight.ts || 0)) < 3000) {\n  return null;\n}\n\nlet q = flow.get(qKey);\nif (!Array.isArray(q) || q.length === 0) return null;\n\n// Prend la prochaine commande\nconst next = q.shift();\nflow.set(qKey, q);\n\n// Marque comme en vol\nflow.set(inFlightKey, { cmd: next.command, ts: Date.now() });\n\n// Envoie au construire commande\nreturn next;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 120,
        "wires": [
            [
                "e4d2c8d8e64970ac"
            ]
        ]
    },
    {
        "id": "cdfa7de40dc84703",
        "type": "inject",
        "z": "280951c3196085f3",
        "g": "57656369260fdee6",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 650,
        "y": 80,
        "wires": [
            [
                "71f23c568f360d5b"
            ]
        ]
    },
    {
        "id": "0cb75a50bfad7cf1",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "7ec01c3a3046742d",
        "name": "construire commande ",
        "func": "// ====== CONSTRUIRE COMMANDE (Voltronic) ======\nconst helpers = global.get(\"helpers\");\n\nif (!helpers || typeof helpers.buildVoltronicCommand !== \"function\") {\n  node.error(\"helpers.buildVoltronicCommand introuvable (global.helpers)\");\n  return null;\n}\n\n// R√©cup√®re la commande (priorit√© √† msg.command)\nlet cmd = (msg.command ?? msg._cmd ?? msg.payload ?? \"\").toString().trim().toUpperCase();\n\nif (!cmd) {\n  node.warn(\"Commande vide -> ignor√©e\");\n  return null;\n}\n\n// S√©curit√©: commande uniquement alphanum (Voltronic = lettres/chiffres)\nif (!/^[A-Z0-9]+$/.test(cmd)) {\n  node.warn(`Commande invalide ignor√©e: \"${cmd}\"`);\n  return null;\n}\n\n// Conserver la commande envoy√©e (utile pour associer RX)\nmsg.command = cmd;\nmsg._cmd = cmd;\n\n// Construire la trame (CRC + CR)\nconst buf = helpers.buildVoltronicCommand(cmd);\n\n// Payload = Buffer √† envoyer dans Serial Out\nmsg.payload = buf;\n\n// Debug utile\nmsg._tx_ts = Date.now();\nmsg._tx_ascii = cmd;\nmsg._tx_hex = buf.toString(\"hex\");\n\n// Status (optionnel)\nnode.status({\n  fill: \"blue\",\n  shape: \"dot\",\n  text: `${cmd} ‚Üí ond${msg.inverterNum ?? \"?\"}`\n});\n\n// m√©morise la derni√®re commande par onduleur\nif (msg.inverterNum != null) {\n  flow.set(`inv${msg.inverterNum}_last_cmd`, msg._cmd);\n  flow.set(`inv${msg.inverterNum}_last_cmd_ts`, Date.now());\n}\n\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 860,
        "y": 400,
        "wires": [
            [
                "da6ab8ea42e3c773"
            ]
        ]
    },
    {
        "id": "c6db8ec683e40f8c",
        "type": "inject",
        "z": "280951c3196085f3",
        "g": "7ec01c3a3046742d",
        "name": "ond2",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "0.5",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 110,
        "y": 400,
        "wires": [
            [
                "213e33dc0a23c9f5"
            ]
        ]
    },
    {
        "id": "213e33dc0a23c9f5",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "7ec01c3a3046742d",
        "name": "requetes",
        "func": "// ====== REQUETES (Option A + firstRun + force + QPIGS2 auto-disable + retry 1h + DIAG) ======\nconst inverterNum = 2;\nconst ts = Date.now();\nconst now = new Date();\n\nconst pad2 = (n) => String(n).padStart(2, \"0\");\nconst yyyy = now.getFullYear();\nconst mm = pad2(now.getMonth() + 1);\nconst dd = pad2(now.getDate());\n\nconst yyyymm = `${yyyy}${mm}`;\nconst yyyymmdd = `${yyyy}${mm}${dd}`;\n\n// √©tat alternance\nlet alt = context.get(\"alt\");\nif (alt === undefined || alt === null) alt = 0;\n\n// firstRun peut rester false si context persistant\nlet firstRun = context.get(\"firstRun\");\nif (firstRun === undefined) firstRun = true;\n\n// Permet de forcer un burst via un inject bouton (msg.forceFirstRun=true)\nif (msg && msg.forceFirstRun === true) {\n  firstRun = true;\n}\n\n// timers existants\nlet nextQMOD = context.get(\"nextQMOD\");\nlet nextHour = context.get(\"nextHour\");\nlet nextDay10m = context.get(\"nextDay10m\");\nlet nextMonth6 = context.get(\"nextMonth6\");\nlet nextYear24 = context.get(\"nextYear24\");\n\n// timers params\nlet nextQPIRI = context.get(\"nextQPIRI\");\nlet nextQDOP = context.get(\"nextQDOP\");\n\n// retry QPIGS2 m√™me si d√©sactiv√©\nlet nextRetryQPIGS2 = context.get(\"nextRetryQPIGS2\");\nif (!nextRetryQPIGS2) nextRetryQPIGS2 = ts + 60 * 60 * 1000;\n\n// ‚úÖ DIAG timers\nlet diagDone = context.get(\"diagDone\");           // 1-shot after boot\nlet nextQPIWS = context.get(\"nextQPIWS\");         // 5 min\n\nfunction makeCmd(cmd) {\n  return { inverterNum, command: cmd, _cmd: cmd, payload: cmd };\n}\n\nconst msgs = [];\n\n// ----- QPIGS/QPIGS2 strat√©gie -----\nconst supportsQPIGS2 = flow.get(`inv${inverterNum}_supports_qpigs2`);\nconst useQPIGS2 = (supportsQPIGS2 !== false);\n\nfunction pushRealtimeTick() {\n  if (useQPIGS2) {\n    msgs.push(makeCmd(alt === 0 ? \"QPIGS\" : \"QPIGS2\"));\n    alt = alt ? 0 : 1;\n  } else {\n    msgs.push(makeCmd(\"QPIGS\"));\n    if (ts >= nextRetryQPIGS2) {\n      msgs.push(makeCmd(\"QPIGS2\"));\n      nextRetryQPIGS2 = ts + 60 * 60 * 1000;\n    }\n  }\n}\n\n// 1) tick realtime\npushRealtimeTick();\n\n// 2) Burst imm√©diat + DIAG one-shot\nif (firstRun) {\n  const burst = [\n    // realtime infos\n    \"QMOD\",\n\n    // energies\n    \"QET\", `QEY${yyyy}`, `QEM${yyyymm}`, `QED${yyyymmdd}`,\n    \"QLT\", `QLY${yyyy}`, `QLM${yyyymm}`, `QLD${yyyymmdd}`,\n\n    // ‚úÖ DIAG (1 fois au boot)\n    \"QMN\",      // model\n    \"QID\",      // serial (si besoin: remplacer par QSID)\n    \"QVFW\",     // fw main\n    \"QVFW3\",    // fw remote/panel (si support√©)\n    \"QPIWS\"     // warnings/faults (1er √©tat)\n  ];\n  burst.forEach(c => msgs.push(makeCmd(c)));\n\n  // schedules\n  nextQMOD = ts + 5 * 60 * 1000;\n  nextHour = ts + 60 * 60 * 1000;\n  nextDay10m = ts + 10 * 60 * 1000;\n  nextMonth6 = ts + 6 * 60 * 60 * 1000;\n  nextYear24 = ts + 24 * 60 * 60 * 1000;\n\n  nextQPIRI = ts + 5 * 60 * 1000;\n  nextQDOP = ts + 5 * 60 * 1000;\n\n  // ‚úÖ DIAG flags/timers\n  diagDone = true;\n  nextQPIWS = ts + 5 * 60 * 1000;\n\n  firstRun = false;\n  node.status({ fill: \"green\", shape: \"dot\", text: `FIRST RUN: ${msgs.length} cmds` });\n\n} else {\n\n  // QMOD 5 min\n  if (nextQMOD == null) nextQMOD = ts + 5 * 60 * 1000;\n  if (ts >= nextQMOD) {\n    msgs.push(makeCmd(\"QMOD\"));\n    nextQMOD = ts + 5 * 60 * 1000;\n  }\n\n  // QPIRI 5 min\n  if (nextQPIRI == null) nextQPIRI = ts + 5 * 60 * 1000;\n  if (ts >= nextQPIRI) {\n    msgs.push(makeCmd(\"QPIRI\"));\n    nextQPIRI = ts + 5 * 60 * 1000;\n  }\n\n  // QDOP 5 min\n  if (nextQDOP == null) nextQDOP = ts + 5 * 60 * 1000;\n  if (ts >= nextQDOP) {\n    msgs.push(makeCmd(\"QDOP\"));\n    nextQDOP = ts + 5 * 60 * 1000;\n  }\n\n  // ‚úÖ QPIWS (fault/warnings) 5 min\n  if (nextQPIWS == null) nextQPIWS = ts + 5 * 60 * 1000;\n  if (ts >= nextQPIWS) {\n    msgs.push(makeCmd(\"QPIWS\"));\n    nextQPIWS = ts + 5 * 60 * 1000;\n  }\n\n  // Hourly\n  if (nextHour == null) nextHour = ts + 60 * 60 * 1000;\n  if (ts >= nextHour) {\n    msgs.push(makeCmd(\"QET\"));\n    msgs.push(makeCmd(\"QLT\"));\n    nextHour = ts + 60 * 60 * 1000;\n  }\n\n  // Daily 10min\n  if (nextDay10m == null) nextDay10m = ts + 10 * 60 * 1000;\n  if (ts >= nextDay10m) {\n    msgs.push(makeCmd(`QED${yyyymmdd}`));\n    msgs.push(makeCmd(`QLD${yyyymmdd}`));\n    nextDay10m = ts + 10 * 60 * 1000;\n  }\n\n  // Monthly 6h\n  if (nextMonth6 == null) nextMonth6 = ts + 6 * 60 * 60 * 1000;\n  if (ts >= nextMonth6) {\n    msgs.push(makeCmd(`QEM${yyyymm}`));\n    msgs.push(makeCmd(`QLM${yyyymm}`));\n    nextMonth6 = ts + 6 * 60 * 60 * 1000;\n  }\n\n  // Yearly 24h\n  if (nextYear24 == null) nextYear24 = ts + 24 * 60 * 60 * 1000;\n  if (ts >= nextYear24) {\n    msgs.push(makeCmd(`QEY${yyyy}`));\n    msgs.push(makeCmd(`QLY${yyyy}`));\n    nextYear24 = ts + 24 * 60 * 60 * 1000;\n  }\n}\n\n// save\ncontext.set(\"alt\", alt);\ncontext.set(\"firstRun\", firstRun);\ncontext.set(\"nextQMOD\", nextQMOD);\ncontext.set(\"nextHour\", nextHour);\ncontext.set(\"nextDay10m\", nextDay10m);\ncontext.set(\"nextMonth6\", nextMonth6);\ncontext.set(\"nextYear24\", nextYear24);\ncontext.set(\"nextQPIRI\", nextQPIRI);\ncontext.set(\"nextQDOP\", nextQDOP);\ncontext.set(\"nextRetryQPIGS2\", nextRetryQPIGS2);\n\n// ‚úÖ save DIAG\ncontext.set(\"diagDone\", diagDone);\ncontext.set(\"nextQPIWS\", nextQPIWS);\n\nreturn [msgs];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 240,
        "y": 400,
        "wires": [
            [
                "3f378285d5efa6bc"
            ]
        ]
    },
    {
        "id": "79e8ddf5e61d2ba2",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "7ec01c3a3046742d",
        "name": "parser ",
        "func": "// ====== PARSER 1 (Voltronic) - QUEUE MODE ======\n// Entr√©e: msg.payload = Buffer (Serial IN en \"a single buffer\", pas de split)\n// Sorties:\n//   1) trigger pump (msg.topic=\"pump\")\n//   2) data pars√©e (vers normalize state)\n// Associe la r√©ponse √† la commande \"inflight\" (envoy√©e par Queue Pump)\n\nconst inv = msg.inverterNum ?? 1;\nif (!Buffer.isBuffer(msg.payload)) return null;\n\n// --- accumulateur RX ---\nlet rx = context.get(\"rxbuf\");\nif (!Buffer.isBuffer(rx)) rx = Buffer.alloc(0);\n\n// s√©curit√© overflow\nif (rx.length > 8192) rx = Buffer.alloc(0);\n\n// concat\nrx = Buffer.concat([rx, msg.payload]);\n\nconst CR = 0x0D;\n\n// extrait toutes les frames finissant par CR\nconst frames = [];\nwhile (true) {\n  const idx = rx.indexOf(CR);\n  if (idx === -1) break;\n  frames.push(rx.slice(0, idx + 1));\n  rx = rx.slice(idx + 1);\n}\ncontext.set(\"rxbuf\", rx);\n\nif (!frames.length) return null;\n\n// commande inflight (celle r√©ellement envoy√©e)\nconst inflightKey = `inv${inv}_inflight`;\nconst inflight = flow.get(inflightKey);\nconst inflightCmd = inflight?.cmd || \"UNKNOWN\";\n\n// Nettoyage trame -> ASCII sans CRC/CR\nfunction cleanAsciiFromFrame(frameBuf) {\n  // NAK brut possible (0x15)\n  if (frameBuf.length === 1 && frameBuf[0] === 0x15) return \"NAK\";\n\n  // Normalement: <data ASCII> + <CRC 2 bytes> + <CR>\n  let dataBuf = frameBuf;\n\n  if (frameBuf.length >= 3 && frameBuf[frameBuf.length - 1] === CR) {\n    dataBuf = frameBuf.slice(0, -3); // retire CRC(2) + CR(1)\n  } else if (frameBuf.length >= 1 && frameBuf[frameBuf.length - 1] === CR) {\n    dataBuf = frameBuf.slice(0, -1); // fallback retire CR\n  }\n\n  return dataBuf.toString(\"ascii\");\n}\n\nfunction parseFrame(frameBuf, cmd) {\n  const ascii = cleanAsciiFromFrame(frameBuf);\n\n  // D√©tection NAK \"NAK\" ou 0x15\n  if (ascii.includes(\"NAK\") || ascii === \"NAK\") {\n    return {\n      inverter: inv,\n      command: cmd,\n      nak: true,\n      raw: \"NAK\",\n      fields: [],\n      nums: [],\n      value: null\n    };\n  }\n\n  // Enlever parenth√®ses si pr√©sentes\n  let body = ascii.trim();\n  if (body.startsWith(\"(\")) body = body.slice(1);\n  if (body.endsWith(\")\")) body = body.slice(0, -1);\n  body = body.trim();\n\n  const fields = body.length ? body.split(/\\s+/) : [];\n  const nums = fields.map(v => {\n    const n = Number(v);\n    return Number.isFinite(n) ? n : null;\n  });\n\n  // Cas √©nergie (1 valeur)\n  const isEnergyCmd = /^Q(E[TYMD]|L[TYMD])/.test(cmd);\n  let value = null;\n  if (isEnergyCmd && fields.length >= 1) {\n    const n0 = Number(fields[0]);\n    if (Number.isFinite(n0)) value = n0;\n  }\n\n  return {\n    inverter: inv,\n    command: cmd,\n    raw: body,\n    fields,\n    nums,\n    value\n  };\n}\n\n// Ici, on part du principe QUEUE = 1 commande envoy√©e -> 1 r√©ponse attendue.\n// Mais on g√®re quand m√™me le cas \"plusieurs frames d'un coup\" :\n// - 1√®re frame = inflightCmd\n// - frames suivantes = UNKNOWN (ou on garde inflightCmd si tu pr√©f√®res)\nconst outMsgs = [];\nfor (let i = 0; i < frames.length; i++) {\n  const cmd = (i === 0) ? inflightCmd : \"UNKNOWN\";\n  outMsgs.push({\n    inverterNum: inv,\n    _cmd: cmd,\n    command: cmd,\n    payload: parseFrame(frames[i], cmd),\n    _rx_ts: Date.now()\n  });\n}\n\n// ACK : d√®s qu'on re√ßoit au moins une frame, on lib√®re inflight\nflow.set(inflightKey, null);\n\n// Trigger pump imm√©diatement (pour envoyer la prochaine commande)\nconst pumpMsg = { inverterNum: inv, topic: \"pump\" };\n\n// Sortie 1: pump trigger\n// Sortie 2: data pars√©e (plusieurs messages possibles)\nreturn [[pumpMsg], outMsgs];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 430,
        "y": 460,
        "wires": [
            [
                "152320995f37f3e8"
            ],
            [
                "95c044d0fae501bc"
            ]
        ]
    },
    {
        "id": "1662751f64ba1280",
        "type": "mqtt out",
        "z": "280951c3196085f3",
        "g": "7ec01c3a3046742d",
        "name": "ond2",
        "topic": "",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "mqtt_broker",
        "x": 1090,
        "y": 460,
        "wires": []
    },
    {
        "id": "95c044d0fae501bc",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "7ec01c3a3046742d",
        "name": "normalize state",
        "func": "// ====== NORMALIZE STATE (AUTO / MULTI-MODEL) - + SCC BATTERY VOLTAGE + DIAG + MORE PRECISION ======\nif (!msg.payload || typeof msg.payload !== \"object\") return null;\n\nconst inv = msg.inverterNum ?? msg.payload.inverter ?? 1;\n\n// Normaliser la commande (√©vite \"QPIRI\\r\", \"qpiri\", \"QPIRI \")\nconst cmd = String(msg.payload.command || msg.command || msg._cmd || \"UNKNOWN\")\n  .trim()\n  .toUpperCase();\n\nconst f = Array.isArray(msg.payload.fields) ? msg.payload.fields : [];\nconst n = Array.isArray(msg.payload.nums) ? msg.payload.nums : [];\nconst value = msg.payload.value;\n\nlet state = context.get(\"state\");\nif (!state || typeof state !== \"object\") state = {};\n\n// helpers\nconst num = (idx) => (Number.isFinite(n[idx]) ? n[idx] : null);\nconst int = (idx) => {\n  const v = num(idx);\n  return v == null ? null : Math.trunc(v);\n};\nconst round = (v, d) => {\n  const nn = Number(v);\n  if (!Number.isFinite(nn)) return null;\n  const m = 10 ** d;\n  return Math.round(nn * m) / m;\n};\n\n// --- apprentissage index pv1_power par node (donc par inverter) ---\nlet pv1PowerIdx = context.get(\"pv1PowerIdx\"); // m√©moris√© par node\n\n// ===== QPIGS =====\nif (cmd === \"QPIGS\" && f.length >= 16) {\n  // Champs communs (stables)\n  if (f.length > 0) state.grid_voltage = round(num(0), 1);\n  if (f.length > 1) state.grid_frequency = round(num(1), 1);\n  if (f.length > 2) state.ac_output_voltage = round(num(2), 1);\n  if (f.length > 3) state.ac_output_frequency = round(num(3), 1);\n\n  // Apparent/active/load : souvent 4/5/6\n  if (f.length > 4) state.ac_output_apparent_power = int(4); // (optionnel utile)\n  if (f.length > 5) state.ac_output_active_power = int(5);\n  if (f.length > 6) state.output_load_percent = int(6);\n\n  // bus voltage : souvent 7\n  if (f.length > 7) state.bus_voltage = int(7);\n\n  // ‚úÖ Batterie : tension 2 d√©cimales, courants 1 d√©cimale\n  if (f.length > 8) state.battery_voltage = round(num(8), 2);\n  if (f.length > 9) state.battery_charging_current = round(num(9), 1);\n  if (f.length > 10) state.battery_capacity = int(10);\n  if (f.length > 11) state.inverter_heat_sink_temp = int(11);\n\n  // PV entr√©e : souvent 12/13\n  if (f.length > 12) state.pv1_input_current = round(num(12), 1);\n  if (f.length > 13) state.pv1_input_voltage = round(num(13), 1);\n\n  // ‚úÖ NOUVEAU SENSOR : Battery voltage from SCC (WW.WW) -> champ 15 => index 14 (selon TES trames)\n  if (f.length > 14) state.battery_voltage_from_scc = round(num(14), 2);\n\n  // ‚úÖ Discharge current : champ 16 => index 15 (selon TES trames)\n  if (f.length > 15) state.battery_discharge_current = round(num(15), 1);\n\n  // ---- PV1 Power : auto\n  if (pv1PowerIdx != null && f.length > pv1PowerIdx) {\n    state.pv1_power = int(pv1PowerIdx);\n  } else {\n    const candidates = [19, 20, 18, 17, 16]; // variantes connues\n    for (const idx of candidates) {\n      if (f.length > idx && Number.isFinite(n[idx])) {\n        const I = state.pv1_input_current;\n        const V = state.pv1_input_voltage;\n        const pCalc = (Number.isFinite(I) && Number.isFinite(V)) ? (I * V) : null;\n        const pField = n[idx];\n\n        if (pCalc != null && pCalc > 10) {\n          const ratio = pField / pCalc;\n          if (ratio > 0.8 && ratio < 1.2) {\n            pv1PowerIdx = idx;\n            context.set(\"pv1PowerIdx\", pv1PowerIdx);\n            state.pv1_power = int(idx);\n            break;\n          }\n        } else {\n          if (idx === 19) {\n            state.pv1_power = int(19);\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  state._last_qpigs_ts = Date.now();\n}\n\n// ===== NOUVEAU : GRID POWER (champ 25 firmwares r√©cents)\nif (f.length > 24 && Number.isFinite(n[24])) {\n  state.grid_power = int(24);\n}\n\n\n// ===== QPIGS2 (optionnel) =====\nif (cmd === \"QPIGS2\" && f.length >= 3) {\n  state.pv2_input_current = round(num(0), 1);\n  state.pv2_input_voltage = round(num(1), 1);\n  state.pv2_power = int(2);\n  state._last_qpigs2_ts = Date.now();\n}\n\n// ===== QMOD =====\nif (cmd === \"QMOD\") {\n  const rawMode = (f[0] ?? msg.payload.raw ?? \"\").toString().trim();\n  const modeMap = { P: \"Power On\", S: \"Standby\", L: \"Grid\", B: \"Battery\", F: \"Fault\" };\n  state.operation_mode = modeMap[rawMode] || rawMode || null;\n  state.operation_mode_code = rawMode || null;\n  state._last_qmod_ts = Date.now();\n}\n\n// ===== QPIRI -> PARAMETRES =====\nif (cmd === \"QPIRI\" && msg.payload?.nak !== true) {\n  const nf = (idx) => {\n    const v = (f && f.length > idx) ? f[idx] : null;\n    const nn = Number(v);\n    return Number.isFinite(nn) ? nn : null;\n  };\n\n  const mapBatteryType = (code) => {\n    const m = { 0: \"AGM\", 1: \"Flooded\", 2: \"User\", 3: \"Pylon\", 5: \"Weco\", 6: \"Soltaro\", 8: \"Lib\", 9: \"Lic\" };\n    return m[code] ?? String(code ?? \"\");\n  };\n  const mapOutputPriority = (code) => {\n    const m = { 0: \"UtilitySolarBat\", 1: \"SolarUtilityBat\", 2: \"SolarBatUtility\" };\n    return m[code] ?? String(code ?? \"\");\n  };\n  const mapChargerPriority = (code) => {\n    const m = { 1: \"Solar first\", 2: \"Solar + Utility\", 3: \"Only solar\" };\n    return m[code] ?? String(code ?? \"\");\n  };\n\n  if (!state.params || typeof state.params !== \"object\") state.params = {};\n\n  const battTypeCode = nf(12);\n  const outPrioCode = nf(16);\n  const chgPrioCode = nf(17);\n\n  state.params.qpiri = {\n    battery_recharge_voltage: nf(8),\n    battery_under_voltage: nf(9),\n    battery_bulk_voltage: nf(10),\n    battery_float_voltage: nf(11),\n\n    battery_type_code: battTypeCode,\n    battery_type: mapBatteryType(battTypeCode),\n\n    max_ac_charging_current: nf(13),\n    max_charging_current: nf(14),\n\n    output_source_priority_code: outPrioCode,\n    output_source_priority: mapOutputPriority(outPrioCode),\n\n    charger_source_priority_code: chgPrioCode,\n    charger_source_priority: mapChargerPriority(chgPrioCode),\n\n    battery_re_discharge_voltage: nf(22),\n    max_discharging_current: nf(27),\n\n    ts: Date.now()\n  };\n\n  state._last_qpiri_ts = Date.now();\n}\n\n// ===== QDOP -> PARAMETRES batterie (%) =====\nif (cmd === \"QDOP\" && msg.payload?.nak !== true) {\n  const nf = (idx) => {\n    const v = (f && f.length > idx) ? f[idx] : null;\n    const nn = Number(v);\n    return Number.isFinite(nn) ? nn : null;\n  };\n\n  if (!state.params || typeof state.params !== \"object\") state.params = {};\n\n  state.params.qdop = {\n    battery_recharge_capacity_pct: nf(8),\n    battery_redischarge_capacity_pct: nf(9),\n    battery_under_capacity_pct: nf(10),\n    ts: Date.now()\n  };\n\n  state._last_qdop_ts = Date.now();\n}\n\n// ===== DIAGNOSTIC (model/serial/fw + faults/warnings) =====\nif (cmd === \"QMN\" && msg.payload?.nak !== true) {\n  state.diag = state.diag || {};\n  state.diag.model = (f[0] ?? msg.payload.raw ?? \"\").toString().trim() || null;\n  state._last_qmn_ts = Date.now();\n}\n\nif ((cmd === \"QID\" || cmd === \"QSID\") && msg.payload?.nak !== true) {\n  state.diag = state.diag || {};\n  state.diag.serial = (f[0] ?? msg.payload.raw ?? \"\").toString().trim() || null;\n  state._last_qid_ts = Date.now();\n}\n\nif ((cmd === \"QVFW\" || cmd === \"QVFW3\") && msg.payload?.nak !== true) {\n  state.diag = state.diag || {};\n  const fw = (f[0] ?? msg.payload.raw ?? \"\").toString().trim() || null;\n  if (cmd === \"QVFW\") state.diag.fw_main = fw;\n  if (cmd === \"QVFW3\") state.diag.fw_remote = fw;\n  state._last_qvfw_ts = Date.now();\n}\n\n// ===== QPIWS -> FAULTS / WARNINGS (4 lignes HA) =====\nif (cmd === \"QPIWS\" && msg.payload?.nak !== true) {\n\n  const bits = String(f[0] ?? msg.payload.raw ?? \"\").trim();\n  if (!state.diag || typeof state.diag !== \"object\") state.diag = {};\n\n  const bit = (i) => (bits.length > i ? bits.charAt(i) === \"1\" : false);\n  const a1_fault = bit(1);\n\n  // Mapping QPIWS (principaux) - adapt√© doc\n  const map = [\n    { i: 0, label: \"PV loss\", kind: \"warn\" },\n    { i: 1, label: \"Inverter fault\", kind: \"fault\" },\n    { i: 2, label: \"Bus over\", kind: \"fault\" },\n    { i: 3, label: \"Bus under\", kind: \"fault\" },\n    { i: 4, label: \"Bus soft fail\", kind: \"fault\" },\n    { i: 5, label: \"Line fail\", kind: \"warn\" },\n    { i: 6, label: \"OPV short\", kind: \"fault\" },\n    { i: 7, label: \"Inverter voltage low\", kind: \"fault\" },\n    { i: 8, label: \"Inverter voltage high\", kind: \"fault\" },\n\n    // \"Compile with a1\" -> peut √™tre warning ou fault selon a1\n    { i: 9, label: \"Over temperature\", kind: () => a1_fault ? \"fault\" : \"warn\" },\n    { i: 10, label: \"Fan locked\", kind: () => a1_fault ? \"fault\" : \"warn\" },\n    { i: 11, label: \"Battery voltage high\", kind: () => a1_fault ? \"fault\" : \"warn\" },\n\n    { i: 12, label: \"Battery low alarm\", kind: \"warn\" },\n    { i: 14, label: \"Battery shutdown\", kind: \"warn\" },\n    { i: 15, label: \"Battery derating\", kind: \"warn\" },\n    { i: 16, label: \"Over load\", kind: () => a1_fault ? \"fault\" : \"warn\" },\n\n    { i: 17, label: \"EEPROM fault\", kind: \"warn\" },\n    { i: 18, label: \"Inverter over current\", kind: \"fault\" },\n    { i: 19, label: \"Inverter soft fail\", kind: \"fault\" },\n    { i: 20, label: \"Self test fail\", kind: \"fault\" },\n    { i: 21, label: \"OP DC voltage over\", kind: \"fault\" },\n    { i: 23, label: \"Current sensor fail\", kind: \"fault\" },\n\n    // VMIV sp√©cifiques (optionnels)\n    { i: 33, label: \"Low PV energy\", kind: \"warn\" },\n    { i: 34, label: \"High AC input\", kind: \"warn\" },\n    { i: 35, label: \"Battery equalization\", kind: \"warn\" }\n  ];\n\n  const faults = [];\n  const warns = [];\n\n  for (const m of map) {\n    if (!bit(m.i)) continue;\n    const k = (typeof m.kind === \"function\") ? m.kind() : m.kind;\n    if (k === \"fault\") faults.push(m.label);\n    else warns.push(m.label);\n  }\n\n  // ---- 4 lignes pour HA\n  state.diag.fault_state = faults.length ? \"FAULT\" : \"OK\";\n  state.diag.fault_details = faults.length ? faults.join(\", \") : \"None\";\n\n  state.diag.warn_state = warns.length ? \"WARN\" : \"OK\";\n  state.diag.warn_details = warns.length ? warns.join(\", \") : \"None\";\n\n  // bool utiles pour automations\n  state.diag.has_fault = faults.length > 0;\n  state.diag.has_warning = warns.length > 0;\n\n  state.diag._last_qpiws_ts = Date.now();\n}\n\n// ===== Support QPIGS2 (diagnostic) =====\nconst supportsKey = `inv${inv}_supports_qpigs2`;\nconst supports = flow.get(supportsKey);\nif (supports !== undefined) state.supports_qpigs2 = (supports !== false);\n\n// ===== ENERGIES (FIX Today) =====\nconst round2 = (v) => (v == null ? null : Math.round(v * 100) / 100);\nconst toKwhToday = (v) => (!Number.isFinite(v) ? null : round2(v / 1000));\nconst toKwhAuto = (v) => (!Number.isFinite(v) ? null : (v >= 10000 ? round2(v / 1000) : round2(v)));\n\nif (Number.isFinite(value)) {\n  // PV\n  if (cmd === \"QET\") { state.pv_energy_total_raw = value; state.pv_energy_total_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QEY\")) { state.pv_energy_year_raw = value; state.pv_energy_year_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QEM\")) { state.pv_energy_month_raw = value; state.pv_energy_month_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QED\")) { state.pv_energy_day_raw = value; state.pv_energy_day_kwh = toKwhToday(value); }\n\n  // LOAD\n  if (cmd === \"QLT\") { state.load_energy_total_raw = value; state.load_energy_total_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QLY\")) { state.load_energy_year_raw = value; state.load_energy_year_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QLM\")) { state.load_energy_month_raw = value; state.load_energy_month_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QLD\")) { state.load_energy_day_raw = value; state.load_energy_day_kwh = toKwhToday(value); }\n\n  state._last_energy_ts = Date.now();\n}\n\n// ===== PV total power =====\nconst pv1 = Number.isFinite(state.pv1_power) ? state.pv1_power : 0;\nconst pv2 = Number.isFinite(state.pv2_power) ? state.pv2_power : 0;\nstate.pv_total_power = pv1 + pv2;\n\n// ===== BATTERY POWER (W) - CUSTOM SENSORS =====\nconst Vb = Number.isFinite(state.battery_voltage) ? state.battery_voltage : null;\nconst Ichg = Number.isFinite(state.battery_charging_current) ? state.battery_charging_current : 0;\nconst Idis = Number.isFinite(state.battery_discharge_current) ? state.battery_discharge_current : 0;\n\nif (Vb != null) {\n  const chargeW = round(Vb * Math.max(0, Ichg), 1);\n  const dischargeW = round(Vb * Math.max(0, Idis), 1);\n\n  state.battery_charge = chargeW;              // +W\n  state.battery_discharge = dischargeW;        // +W\n  state.battery_power = (chargeW != null && dischargeW != null) ? round(chargeW - dischargeW, 1) : null;\n} else {\n  state.battery_charge = null;\n  state.battery_discharge = null;\n  state.battery_power = null;\n}\n\ncontext.set(\"state\", state);\nmsg.inverterNum = inv;\nmsg.payload = state;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 460,
        "wires": [
            [
                "c6a6cf11c6876196"
            ]
        ]
    },
    {
        "id": "c6a6cf11c6876196",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "7ec01c3a3046742d",
        "name": "MQTT state publisher",
        "func": "if (!msg.payload || typeof msg.payload !== \"object\") return null;\n\nconst inv = msg.inverterNum ?? 1;\n\nreturn [\n    {\n        topic: `voltronic/${inv}/state`,\n        payload: JSON.stringify(msg.payload),\n        retain: false\n    },\n    {\n        topic: `voltronic/${inv}/availability`,\n        payload: \"online\",\n        retain: true\n    }\n];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 460,
        "wires": [
            [
                "1662751f64ba1280"
            ],
            [
                "1662751f64ba1280"
            ]
        ]
    },
    {
        "id": "3f378285d5efa6bc",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "7ec01c3a3046742d",
        "name": "Queue Enqueue ",
        "func": "const inv = msg.inverterNum ?? 1;\nconst key = `inv${inv}_queue`;\n\nlet q = flow.get(key);\nif (!Array.isArray(q)) q = [];\n\n// msg peut √™tre 1 commande, ou un lot (si tu envoies [msgs])\n// Ici, on g√®re les deux cas proprement.\nconst toPush = [];\n\nif (Array.isArray(msg)) {\n    // rare : si tu envoies direct un tableau de msgs\n    toPush.push(...msg);\n} else if (Array.isArray(msg.payload) && msg.payload?.[0]?.command) {\n    // si jamais ton flow passe un tableau dans payload\n    toPush.push(...msg.payload);\n} else {\n    // msg normal\n    toPush.push(msg);\n}\n\n// ajoute uniquement si on a une commande\ntoPush.forEach(m => {\n    const cmd = (m.command || m._cmd || m.payload || \"\").toString().trim().toUpperCase();\n    if (!cmd) return;\n\n    q.push({\n        inverterNum: inv,\n        command: cmd,\n        _cmd: cmd,\n        payload: cmd,\n        enqueued_ts: Date.now()\n    });\n});\n\n// limite taille\nif (q.length > 200) q = q.slice(-200);\n\nflow.set(key, q);\n\n// d√©clenche le pump\nreturn { inverterNum: inv, topic: \"pump\" };\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 440,
        "y": 400,
        "wires": [
            [
                "152320995f37f3e8"
            ]
        ]
    },
    {
        "id": "152320995f37f3e8",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "7ec01c3a3046742d",
        "name": "Queue Pump ",
        "func": "const inv = msg.inverterNum ?? 1;\n\nconst qKey = `inv${inv}_queue`;\nconst inFlightKey = `inv${inv}_inflight`;\n\nlet inFlight = flow.get(inFlightKey);\n\n// Si une commande est d√©j√† en attente de r√©ponse, on n‚Äôen envoie pas une autre\nif (inFlight && (Date.now() - (inFlight.ts || 0)) < 3000) {\n  return null;\n}\n\nlet q = flow.get(qKey);\nif (!Array.isArray(q) || q.length === 0) return null;\n\n// Prend la prochaine commande\nconst next = q.shift();\nflow.set(qKey, q);\n\n// Marque comme en vol\nflow.set(inFlightKey, { cmd: next.command, ts: Date.now() });\n\n// Envoie au construire commande\nreturn next;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 420,
        "wires": [
            [
                "0cb75a50bfad7cf1"
            ]
        ]
    },
    {
        "id": "83ef0d7ea356371d",
        "type": "inject",
        "z": "280951c3196085f3",
        "g": "7ec01c3a3046742d",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 650,
        "y": 380,
        "wires": [
            [
                "152320995f37f3e8"
            ]
        ]
    },
    {
        "id": "0967f976f3607b87",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "7ec01c3a3046742d",
        "name": "tag",
        "func": "msg.inverterNum = 2;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 290,
        "y": 460,
        "wires": [
            [
                "79e8ddf5e61d2ba2"
            ]
        ]
    },
    {
        "id": "de354293640c80a3",
        "type": "mqtt in",
        "z": "280951c3196085f3",
        "g": "57656369260fdee6",
        "name": "MQTT IN - HA SET",
        "topic": "voltronic/+/set/+",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "mqtt_broker",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 150,
        "y": 220,
        "wires": [
            [
                "8558e17ff63073c1"
            ]
        ]
    },
    {
        "id": "8558e17ff63073c1",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "57656369260fdee6",
        "name": "HA SET ‚Üí Voltronic CMD",
        "func": "// HA SET -> Voltronic CMD  (1 sortie)\n// topic: voltronic/<inv>/set/<param>\n// payload: valeur\n\nconst m = (msg.topic || \"\").match(/^voltronic\\/(\\d+)\\/set\\/(.+)$/);\nif (!m) return null;\n\nconst inverterNum = Number(m[1]);\nconst param = m[2];\n\nlet v = msg.payload;\nif (typeof v === \"string\") v = v.trim();\n\nconst toNum = (x) => {\n  const n = Number(x);\n  return Number.isFinite(n) ? n : null;\n};\nconst pad3 = (x) => String(Math.trunc(Number(x))).padStart(3, \"0\");\nconst fixed1 = (x) => Number(x).toFixed(1);\nconst clamp = (x, a, b) => Math.min(b, Math.max(a, Number(x)));\n\nconst machine = inverterNum;\n\nlet cmd = null;\n\n// SELECTS\nif (param === \"output_source_priority\") {\n  const map = { UtilitySolarBat: \"POP00\", SolarUtilityBat: \"POP01\", SolarBatUtility: \"POP02\" };\n  cmd = map[v] || null;\n} else if (param === \"charger_source_priority\") {\n  const map = { \"Solar first\": \"PCP01\", \"Solar + Utility\": \"PCP02\", \"Only solar\": \"PCP03\" };\n  cmd = map[v] || null;\n} else if (param === \"battery_type\") {\n  const map = { AGM:\"PBT00\", Flooded:\"PBT01\", User:\"PBT02\", Pylon:\"PBT03\", Weco:\"PBT05\", Soltaro:\"PBT06\", Lib:\"PBT08\", Lic:\"PBT09\" };\n  cmd = map[v] || null;\n}\n\n// VOLTAGES nn.n\nelse if (param === \"battery_recharge_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PBCV${fixed1(nv)}`; }\nelse if (param === \"battery_re_discharge_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PBDV${fixed1(nv)}`; }\nelse if (param === \"battery_under_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PSDV${fixed1(nv)}`; }\nelse if (param === \"battery_bulk_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PCVV${fixed1(nv)}`; }\nelse if (param === \"battery_float_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PBFT${fixed1(nv)}`; }\n\n// CURRENTS\nelse if (param === \"max_charging_current\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `MNCHGC${machine}${pad3(clamp(nv,0,300))}`;\n}\nelse if (param === \"max_ac_charging_current\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `MUCHGC${machine}${pad3(clamp(nv,0,300))}`;\n}\nelse if (param === \"max_discharging_current\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `PBATMAXDISC${pad3(clamp(nv,0,300))}`;\n}\n\n// QDOP seuils %\nelse if (param === \"battery_recharge_capacity_pct\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `PBCC${pad3(clamp(nv,5,95))}`;\n}\nelse if (param === \"battery_redischarge_capacity_pct\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `PBDC${pad3(clamp(nv,10,100))}`;\n}\nelse if (param === \"battery_under_capacity_pct\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `PSDC${pad3(clamp(nv,0,90))}`;\n}\n\nif (!cmd) return null;\n\nconst mk = (c) => ({\n  inverterNum,\n  command: c,\n  _cmd: c,\n  payload: c,\n  _burst: true\n});\n\n// 1Ô∏è‚É£ Message SET (prioritaire)\nconst setMsg = mk(cmd);\nsetMsg._burst = false;\n\n// 2Ô∏è‚É£ Rafale refresh apr√®s SET (pour MAJ imm√©diate HA)\nconst refresh = [\"QPIRI\", \"QDOP\", \"QMOD\", \"QPIGS\"];\n// optionnel si support√© : refresh.splice(3,0,\"QPIGS2\");\n\nconst out = [setMsg, ...refresh.map(mk)];\n\nnode.status({\n  fill: \"green\",\n  shape: \"dot\",\n  text: `SET ${param} + refresh x${out.length - 1}`\n});\n\n// ‚ùóÔ∏èIMPORTANT : 1 sortie => tableau de messages dans la sortie 1\nreturn [out];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 220,
        "wires": [
            [
                "de9aa384c451b6cf"
            ]
        ]
    },
    {
        "id": "de9aa384c451b6cf",
        "type": "link out",
        "z": "280951c3196085f3",
        "g": "57656369260fdee6",
        "name": "link out 1",
        "mode": "link",
        "links": [
            "b64df27ef9b2e03f"
        ],
        "x": 575,
        "y": 220,
        "wires": []
    },
    {
        "id": "b64df27ef9b2e03f",
        "type": "link in",
        "z": "280951c3196085f3",
        "g": "57656369260fdee6",
        "name": "link in 1",
        "links": [
            "de9aa384c451b6cf"
        ],
        "x": 275,
        "y": 60,
        "wires": [
            [
                "4e49dec8b23d003f"
            ]
        ]
    },
    {
        "id": "f75b804e3f323942",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "7ec01c3a3046742d",
        "name": "HA SET ‚Üí Voltronic CMD",
        "func": "// HA SET -> Voltronic CMD  (1 sortie)\n// topic: voltronic/<inv>/set/<param>\n// payload: valeur\n\nconst m = (msg.topic || \"\").match(/^voltronic\\/(\\d+)\\/set\\/(.+)$/);\nif (!m) return null;\n\nconst inverterNum = Number(m[1]);\nconst param = m[2];\n\nlet v = msg.payload;\nif (typeof v === \"string\") v = v.trim();\n\nconst toNum = (x) => {\n  const n = Number(x);\n  return Number.isFinite(n) ? n : null;\n};\nconst pad3 = (x) => String(Math.trunc(Number(x))).padStart(3, \"0\");\nconst fixed1 = (x) => Number(x).toFixed(1);\nconst clamp = (x, a, b) => Math.min(b, Math.max(a, Number(x)));\n\nconst machine = inverterNum;\n\nlet cmd = null;\n\n// SELECTS\nif (param === \"output_source_priority\") {\n  const map = { UtilitySolarBat: \"POP00\", SolarUtilityBat: \"POP01\", SolarBatUtility: \"POP02\" };\n  cmd = map[v] || null;\n} else if (param === \"charger_source_priority\") {\n  const map = { \"Solar first\": \"PCP01\", \"Solar + Utility\": \"PCP02\", \"Only solar\": \"PCP03\" };\n  cmd = map[v] || null;\n} else if (param === \"battery_type\") {\n  const map = { AGM:\"PBT00\", Flooded:\"PBT01\", User:\"PBT02\", Pylon:\"PBT03\", Weco:\"PBT05\", Soltaro:\"PBT06\", Lib:\"PBT08\", Lic:\"PBT09\" };\n  cmd = map[v] || null;\n}\n\n// VOLTAGES nn.n\nelse if (param === \"battery_recharge_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PBCV${fixed1(nv)}`; }\nelse if (param === \"battery_re_discharge_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PBDV${fixed1(nv)}`; }\nelse if (param === \"battery_under_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PSDV${fixed1(nv)}`; }\nelse if (param === \"battery_bulk_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PCVV${fixed1(nv)}`; }\nelse if (param === \"battery_float_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PBFT${fixed1(nv)}`; }\n\n// CURRENTS\nelse if (param === \"max_charging_current\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `MNCHGC${machine}${pad3(clamp(nv,0,300))}`;\n}\nelse if (param === \"max_ac_charging_current\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `MUCHGC${machine}${pad3(clamp(nv,0,300))}`;\n}\nelse if (param === \"max_discharging_current\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `PBATMAXDISC${pad3(clamp(nv,0,300))}`;\n}\n\n// QDOP seuils %\nelse if (param === \"battery_recharge_capacity_pct\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `PBCC${pad3(clamp(nv,5,95))}`;\n}\nelse if (param === \"battery_redischarge_capacity_pct\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `PBDC${pad3(clamp(nv,10,100))}`;\n}\nelse if (param === \"battery_under_capacity_pct\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `PSDC${pad3(clamp(nv,0,90))}`;\n}\n\nif (!cmd) return null;\n\nconst mk = (c) => ({\n  inverterNum,\n  command: c,\n  _cmd: c,\n  payload: c,\n  _burst: true\n});\n\n// 1Ô∏è‚É£ Message SET (prioritaire)\nconst setMsg = mk(cmd);\nsetMsg._burst = false;\n\n// 2Ô∏è‚É£ Rafale refresh apr√®s SET (pour MAJ imm√©diate HA)\nconst refresh = [\"QPIRI\", \"QDOP\", \"QMOD\", \"QPIGS\"];\n// optionnel si support√© : refresh.splice(3,0,\"QPIGS2\");\n\nconst out = [setMsg, ...refresh.map(mk)];\n\nnode.status({\n  fill: \"green\",\n  shape: \"dot\",\n  text: `SET ${param} + refresh x${out.length - 1}`\n});\n\n// ‚ùóÔ∏èIMPORTANT : 1 sortie => tableau de messages dans la sortie 1\nreturn [out];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 520,
        "wires": [
            [
                "361cfd9b7b2c4692"
            ]
        ]
    },
    {
        "id": "4f7d529112896319",
        "type": "mqtt in",
        "z": "280951c3196085f3",
        "g": "7ec01c3a3046742d",
        "name": "MQTT IN - HA SET",
        "topic": "voltronic/+/set/+",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "mqtt_broker",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 130,
        "y": 520,
        "wires": [
            [
                "f75b804e3f323942"
            ]
        ]
    },
    {
        "id": "361cfd9b7b2c4692",
        "type": "link out",
        "z": "280951c3196085f3",
        "g": "7ec01c3a3046742d",
        "name": "link out 2",
        "mode": "link",
        "links": [
            "535730443c533ff9"
        ],
        "x": 545,
        "y": 520,
        "wires": []
    },
    {
        "id": "535730443c533ff9",
        "type": "link in",
        "z": "280951c3196085f3",
        "g": "7ec01c3a3046742d",
        "name": "link in 2",
        "links": [
            "361cfd9b7b2c4692"
        ],
        "x": 315,
        "y": 340,
        "wires": [
            [
                "3f378285d5efa6bc"
            ]
        ]
    },
    {
        "id": "3723c166ecd597c8",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "5886b0dc312a65e2",
        "name": "construire commande ",
        "func": "// ====== CONSTRUIRE COMMANDE (Voltronic) ======\nconst helpers = global.get(\"helpers\");\n\nif (!helpers || typeof helpers.buildVoltronicCommand !== \"function\") {\n  node.error(\"helpers.buildVoltronicCommand introuvable (global.helpers)\");\n  return null;\n}\n\n// R√©cup√®re la commande (priorit√© √† msg.command)\nlet cmd = (msg.command ?? msg._cmd ?? msg.payload ?? \"\").toString().trim().toUpperCase();\n\nif (!cmd) {\n  node.warn(\"Commande vide -> ignor√©e\");\n  return null;\n}\n\n// S√©curit√©: commande uniquement alphanum (Voltronic = lettres/chiffres)\nif (!/^[A-Z0-9]+$/.test(cmd)) {\n  node.warn(`Commande invalide ignor√©e: \"${cmd}\"`);\n  return null;\n}\n\n// Conserver la commande envoy√©e (utile pour associer RX)\nmsg.command = cmd;\nmsg._cmd = cmd;\n\n// Construire la trame (CRC + CR)\nconst buf = helpers.buildVoltronicCommand(cmd);\n\n// Payload = Buffer √† envoyer dans Serial Out\nmsg.payload = buf;\n\n// Debug utile\nmsg._tx_ts = Date.now();\nmsg._tx_ascii = cmd;\nmsg._tx_hex = buf.toString(\"hex\");\n\n// Status (optionnel)\nnode.status({\n  fill: \"blue\",\n  shape: \"dot\",\n  text: `${cmd} ‚Üí ond${msg.inverterNum ?? \"?\"}`\n});\n\n// m√©morise la derni√®re commande par onduleur\nif (msg.inverterNum != null) {\n  flow.set(`inv${msg.inverterNum}_last_cmd`, msg._cmd);\n  flow.set(`inv${msg.inverterNum}_last_cmd_ts`, Date.now());\n}\n\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 860,
        "y": 700,
        "wires": [
            [
                "f2b75a0a86b82097"
            ]
        ]
    },
    {
        "id": "15d3edfa362fa487",
        "type": "inject",
        "z": "280951c3196085f3",
        "g": "5886b0dc312a65e2",
        "name": "ond3",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "0.5",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 110,
        "y": 700,
        "wires": [
            [
                "9cad9c70bd135ba1"
            ]
        ]
    },
    {
        "id": "9cad9c70bd135ba1",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "5886b0dc312a65e2",
        "name": "requetes",
        "func": "// ====== REQUETES (Option A + firstRun + force + QPIGS2 auto-disable + retry 1h + DIAG) ======\nconst inverterNum = 3;\nconst ts = Date.now();\nconst now = new Date();\n\nconst pad2 = (n) => String(n).padStart(2, \"0\");\nconst yyyy = now.getFullYear();\nconst mm = pad2(now.getMonth() + 1);\nconst dd = pad2(now.getDate());\n\nconst yyyymm = `${yyyy}${mm}`;\nconst yyyymmdd = `${yyyy}${mm}${dd}`;\n\n// √©tat alternance\nlet alt = context.get(\"alt\");\nif (alt === undefined || alt === null) alt = 0;\n\n// firstRun peut rester false si context persistant\nlet firstRun = context.get(\"firstRun\");\nif (firstRun === undefined) firstRun = true;\n\n// Permet de forcer un burst via un inject bouton (msg.forceFirstRun=true)\nif (msg && msg.forceFirstRun === true) {\n  firstRun = true;\n}\n\n// timers existants\nlet nextQMOD = context.get(\"nextQMOD\");\nlet nextHour = context.get(\"nextHour\");\nlet nextDay10m = context.get(\"nextDay10m\");\nlet nextMonth6 = context.get(\"nextMonth6\");\nlet nextYear24 = context.get(\"nextYear24\");\n\n// timers params\nlet nextQPIRI = context.get(\"nextQPIRI\");\nlet nextQDOP = context.get(\"nextQDOP\");\n\n// retry QPIGS2 m√™me si d√©sactiv√©\nlet nextRetryQPIGS2 = context.get(\"nextRetryQPIGS2\");\nif (!nextRetryQPIGS2) nextRetryQPIGS2 = ts + 60 * 60 * 1000;\n\n// ‚úÖ DIAG timers\nlet diagDone = context.get(\"diagDone\");           // 1-shot after boot\nlet nextQPIWS = context.get(\"nextQPIWS\");         // 5 min\n\nfunction makeCmd(cmd) {\n  return { inverterNum, command: cmd, _cmd: cmd, payload: cmd };\n}\n\nconst msgs = [];\n\n// ----- QPIGS/QPIGS2 strat√©gie -----\nconst supportsQPIGS2 = flow.get(`inv${inverterNum}_supports_qpigs2`);\nconst useQPIGS2 = (supportsQPIGS2 !== false);\n\nfunction pushRealtimeTick() {\n  if (useQPIGS2) {\n    msgs.push(makeCmd(alt === 0 ? \"QPIGS\" : \"QPIGS2\"));\n    alt = alt ? 0 : 1;\n  } else {\n    msgs.push(makeCmd(\"QPIGS\"));\n    if (ts >= nextRetryQPIGS2) {\n      msgs.push(makeCmd(\"QPIGS2\"));\n      nextRetryQPIGS2 = ts + 60 * 60 * 1000;\n    }\n  }\n}\n\n// 1) tick realtime\npushRealtimeTick();\n\n// 2) Burst imm√©diat + DIAG one-shot\nif (firstRun) {\n  const burst = [\n    // realtime infos\n    \"QMOD\",\n\n    // energies\n    \"QET\", `QEY${yyyy}`, `QEM${yyyymm}`, `QED${yyyymmdd}`,\n    \"QLT\", `QLY${yyyy}`, `QLM${yyyymm}`, `QLD${yyyymmdd}`,\n\n    // ‚úÖ DIAG (1 fois au boot)\n    \"QMN\",      // model\n    \"QID\",      // serial (si besoin: remplacer par QSID)\n    \"QVFW\",     // fw main\n    \"QVFW3\",    // fw remote/panel (si support√©)\n    \"QPIWS\"     // warnings/faults (1er √©tat)\n  ];\n  burst.forEach(c => msgs.push(makeCmd(c)));\n\n  // schedules\n  nextQMOD = ts + 5 * 60 * 1000;\n  nextHour = ts + 60 * 60 * 1000;\n  nextDay10m = ts + 10 * 60 * 1000;\n  nextMonth6 = ts + 6 * 60 * 60 * 1000;\n  nextYear24 = ts + 24 * 60 * 60 * 1000;\n\n  nextQPIRI = ts + 5 * 60 * 1000;\n  nextQDOP = ts + 5 * 60 * 1000;\n\n  // ‚úÖ DIAG flags/timers\n  diagDone = true;\n  nextQPIWS = ts + 5 * 60 * 1000;\n\n  firstRun = false;\n  node.status({ fill: \"green\", shape: \"dot\", text: `FIRST RUN: ${msgs.length} cmds` });\n\n} else {\n\n  // QMOD 5 min\n  if (nextQMOD == null) nextQMOD = ts + 5 * 60 * 1000;\n  if (ts >= nextQMOD) {\n    msgs.push(makeCmd(\"QMOD\"));\n    nextQMOD = ts + 5 * 60 * 1000;\n  }\n\n  // QPIRI 5 min\n  if (nextQPIRI == null) nextQPIRI = ts + 5 * 60 * 1000;\n  if (ts >= nextQPIRI) {\n    msgs.push(makeCmd(\"QPIRI\"));\n    nextQPIRI = ts + 5 * 60 * 1000;\n  }\n\n  // QDOP 5 min\n  if (nextQDOP == null) nextQDOP = ts + 5 * 60 * 1000;\n  if (ts >= nextQDOP) {\n    msgs.push(makeCmd(\"QDOP\"));\n    nextQDOP = ts + 5 * 60 * 1000;\n  }\n\n  // ‚úÖ QPIWS (fault/warnings) 5 min\n  if (nextQPIWS == null) nextQPIWS = ts + 5 * 60 * 1000;\n  if (ts >= nextQPIWS) {\n    msgs.push(makeCmd(\"QPIWS\"));\n    nextQPIWS = ts + 5 * 60 * 1000;\n  }\n\n  // Hourly\n  if (nextHour == null) nextHour = ts + 60 * 60 * 1000;\n  if (ts >= nextHour) {\n    msgs.push(makeCmd(\"QET\"));\n    msgs.push(makeCmd(\"QLT\"));\n    nextHour = ts + 60 * 60 * 1000;\n  }\n\n  // Daily 10min\n  if (nextDay10m == null) nextDay10m = ts + 10 * 60 * 1000;\n  if (ts >= nextDay10m) {\n    msgs.push(makeCmd(`QED${yyyymmdd}`));\n    msgs.push(makeCmd(`QLD${yyyymmdd}`));\n    nextDay10m = ts + 10 * 60 * 1000;\n  }\n\n  // Monthly 6h\n  if (nextMonth6 == null) nextMonth6 = ts + 6 * 60 * 60 * 1000;\n  if (ts >= nextMonth6) {\n    msgs.push(makeCmd(`QEM${yyyymm}`));\n    msgs.push(makeCmd(`QLM${yyyymm}`));\n    nextMonth6 = ts + 6 * 60 * 60 * 1000;\n  }\n\n  // Yearly 24h\n  if (nextYear24 == null) nextYear24 = ts + 24 * 60 * 60 * 1000;\n  if (ts >= nextYear24) {\n    msgs.push(makeCmd(`QEY${yyyy}`));\n    msgs.push(makeCmd(`QLY${yyyy}`));\n    nextYear24 = ts + 24 * 60 * 60 * 1000;\n  }\n}\n\n// save\ncontext.set(\"alt\", alt);\ncontext.set(\"firstRun\", firstRun);\ncontext.set(\"nextQMOD\", nextQMOD);\ncontext.set(\"nextHour\", nextHour);\ncontext.set(\"nextDay10m\", nextDay10m);\ncontext.set(\"nextMonth6\", nextMonth6);\ncontext.set(\"nextYear24\", nextYear24);\ncontext.set(\"nextQPIRI\", nextQPIRI);\ncontext.set(\"nextQDOP\", nextQDOP);\ncontext.set(\"nextRetryQPIGS2\", nextRetryQPIGS2);\n\n// ‚úÖ save DIAG\ncontext.set(\"diagDone\", diagDone);\ncontext.set(\"nextQPIWS\", nextQPIWS);\n\nreturn [msgs];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 240,
        "y": 700,
        "wires": [
            [
                "12e2da8864f63658"
            ]
        ]
    },
    {
        "id": "934204be298bcd3d",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "5886b0dc312a65e2",
        "name": "parser ",
        "func": "// ====== PARSER 1 (Voltronic) - QUEUE MODE ======\n// Entr√©e: msg.payload = Buffer (Serial IN en \"a single buffer\", pas de split)\n// Sorties:\n//   1) trigger pump (msg.topic=\"pump\")\n//   2) data pars√©e (vers normalize state)\n// Associe la r√©ponse √† la commande \"inflight\" (envoy√©e par Queue Pump)\n\nconst inv = msg.inverterNum ?? 1;\nif (!Buffer.isBuffer(msg.payload)) return null;\n\n// --- accumulateur RX ---\nlet rx = context.get(\"rxbuf\");\nif (!Buffer.isBuffer(rx)) rx = Buffer.alloc(0);\n\n// s√©curit√© overflow\nif (rx.length > 8192) rx = Buffer.alloc(0);\n\n// concat\nrx = Buffer.concat([rx, msg.payload]);\n\nconst CR = 0x0D;\n\n// extrait toutes les frames finissant par CR\nconst frames = [];\nwhile (true) {\n  const idx = rx.indexOf(CR);\n  if (idx === -1) break;\n  frames.push(rx.slice(0, idx + 1));\n  rx = rx.slice(idx + 1);\n}\ncontext.set(\"rxbuf\", rx);\n\nif (!frames.length) return null;\n\n// commande inflight (celle r√©ellement envoy√©e)\nconst inflightKey = `inv${inv}_inflight`;\nconst inflight = flow.get(inflightKey);\nconst inflightCmd = inflight?.cmd || \"UNKNOWN\";\n\n// Nettoyage trame -> ASCII sans CRC/CR\nfunction cleanAsciiFromFrame(frameBuf) {\n  // NAK brut possible (0x15)\n  if (frameBuf.length === 1 && frameBuf[0] === 0x15) return \"NAK\";\n\n  // Normalement: <data ASCII> + <CRC 2 bytes> + <CR>\n  let dataBuf = frameBuf;\n\n  if (frameBuf.length >= 3 && frameBuf[frameBuf.length - 1] === CR) {\n    dataBuf = frameBuf.slice(0, -3); // retire CRC(2) + CR(1)\n  } else if (frameBuf.length >= 1 && frameBuf[frameBuf.length - 1] === CR) {\n    dataBuf = frameBuf.slice(0, -1); // fallback retire CR\n  }\n\n  return dataBuf.toString(\"ascii\");\n}\n\nfunction parseFrame(frameBuf, cmd) {\n  const ascii = cleanAsciiFromFrame(frameBuf);\n\n  // D√©tection NAK \"NAK\" ou 0x15\n  if (ascii.includes(\"NAK\") || ascii === \"NAK\") {\n    return {\n      inverter: inv,\n      command: cmd,\n      nak: true,\n      raw: \"NAK\",\n      fields: [],\n      nums: [],\n      value: null\n    };\n  }\n\n  // Enlever parenth√®ses si pr√©sentes\n  let body = ascii.trim();\n  if (body.startsWith(\"(\")) body = body.slice(1);\n  if (body.endsWith(\")\")) body = body.slice(0, -1);\n  body = body.trim();\n\n  const fields = body.length ? body.split(/\\s+/) : [];\n  const nums = fields.map(v => {\n    const n = Number(v);\n    return Number.isFinite(n) ? n : null;\n  });\n\n  // Cas √©nergie (1 valeur)\n  const isEnergyCmd = /^Q(E[TYMD]|L[TYMD])/.test(cmd);\n  let value = null;\n  if (isEnergyCmd && fields.length >= 1) {\n    const n0 = Number(fields[0]);\n    if (Number.isFinite(n0)) value = n0;\n  }\n\n  return {\n    inverter: inv,\n    command: cmd,\n    raw: body,\n    fields,\n    nums,\n    value\n  };\n}\n\n// Ici, on part du principe QUEUE = 1 commande envoy√©e -> 1 r√©ponse attendue.\n// Mais on g√®re quand m√™me le cas \"plusieurs frames d'un coup\" :\n// - 1√®re frame = inflightCmd\n// - frames suivantes = UNKNOWN (ou on garde inflightCmd si tu pr√©f√®res)\nconst outMsgs = [];\nfor (let i = 0; i < frames.length; i++) {\n  const cmd = (i === 0) ? inflightCmd : \"UNKNOWN\";\n  outMsgs.push({\n    inverterNum: inv,\n    _cmd: cmd,\n    command: cmd,\n    payload: parseFrame(frames[i], cmd),\n    _rx_ts: Date.now()\n  });\n}\n\n// ACK : d√®s qu'on re√ßoit au moins une frame, on lib√®re inflight\nflow.set(inflightKey, null);\n\n// Trigger pump imm√©diatement (pour envoyer la prochaine commande)\nconst pumpMsg = { inverterNum: inv, topic: \"pump\" };\n\n// Sortie 1: pump trigger\n// Sortie 2: data pars√©e (plusieurs messages possibles)\nreturn [[pumpMsg], outMsgs];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 430,
        "y": 760,
        "wires": [
            [
                "8feb5755ad105131"
            ],
            [
                "3b468cc517e1fcaa"
            ]
        ]
    },
    {
        "id": "4d6727a8daa54583",
        "type": "mqtt out",
        "z": "280951c3196085f3",
        "g": "5886b0dc312a65e2",
        "name": "ond3",
        "topic": "",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "mqtt_broker",
        "x": 1090,
        "y": 760,
        "wires": []
    },
    {
        "id": "3b468cc517e1fcaa",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "5886b0dc312a65e2",
        "name": "normalize state",
        "func": "// ====== NORMALIZE STATE (AUTO / MULTI-MODEL) - + SCC BATTERY VOLTAGE + DIAG + MORE PRECISION ======\nif (!msg.payload || typeof msg.payload !== \"object\") return null;\n\nconst inv = msg.inverterNum ?? msg.payload.inverter ?? 1;\n\n// Normaliser la commande (√©vite \"QPIRI\\r\", \"qpiri\", \"QPIRI \")\nconst cmd = String(msg.payload.command || msg.command || msg._cmd || \"UNKNOWN\")\n  .trim()\n  .toUpperCase();\n\nconst f = Array.isArray(msg.payload.fields) ? msg.payload.fields : [];\nconst n = Array.isArray(msg.payload.nums) ? msg.payload.nums : [];\nconst value = msg.payload.value;\n\nlet state = context.get(\"state\");\nif (!state || typeof state !== \"object\") state = {};\n\n// helpers\nconst num = (idx) => (Number.isFinite(n[idx]) ? n[idx] : null);\nconst int = (idx) => {\n  const v = num(idx);\n  return v == null ? null : Math.trunc(v);\n};\nconst round = (v, d) => {\n  const nn = Number(v);\n  if (!Number.isFinite(nn)) return null;\n  const m = 10 ** d;\n  return Math.round(nn * m) / m;\n};\n\n// --- apprentissage index pv1_power par node (donc par inverter) ---\nlet pv1PowerIdx = context.get(\"pv1PowerIdx\"); // m√©moris√© par node\n\n// ===== QPIGS =====\nif (cmd === \"QPIGS\" && f.length >= 16) {\n  // Champs communs (stables)\n  if (f.length > 0) state.grid_voltage = round(num(0), 1);\n  if (f.length > 1) state.grid_frequency = round(num(1), 1);\n  if (f.length > 2) state.ac_output_voltage = round(num(2), 1);\n  if (f.length > 3) state.ac_output_frequency = round(num(3), 1);\n\n  // Apparent/active/load : souvent 4/5/6\n  if (f.length > 4) state.ac_output_apparent_power = int(4); // (optionnel utile)\n  if (f.length > 5) state.ac_output_active_power = int(5);\n  if (f.length > 6) state.output_load_percent = int(6);\n\n  // bus voltage : souvent 7\n  if (f.length > 7) state.bus_voltage = int(7);\n\n  // ‚úÖ Batterie : tension 2 d√©cimales, courants 1 d√©cimale\n  if (f.length > 8) state.battery_voltage = round(num(8), 2);\n  if (f.length > 9) state.battery_charging_current = round(num(9), 1);\n  if (f.length > 10) state.battery_capacity = int(10);\n  if (f.length > 11) state.inverter_heat_sink_temp = int(11);\n\n  // PV entr√©e : souvent 12/13\n  if (f.length > 12) state.pv1_input_current = round(num(12), 1);\n  if (f.length > 13) state.pv1_input_voltage = round(num(13), 1);\n\n  // ‚úÖ NOUVEAU SENSOR : Battery voltage from SCC (WW.WW) -> champ 15 => index 14 (selon TES trames)\n  if (f.length > 14) state.battery_voltage_from_scc = round(num(14), 2);\n\n  // ‚úÖ Discharge current : champ 16 => index 15 (selon TES trames)\n  if (f.length > 15) state.battery_discharge_current = round(num(15), 1);\n\n  // ---- PV1 Power : auto\n  if (pv1PowerIdx != null && f.length > pv1PowerIdx) {\n    state.pv1_power = int(pv1PowerIdx);\n  } else {\n    const candidates = [19, 20, 18, 17, 16]; // variantes connues\n    for (const idx of candidates) {\n      if (f.length > idx && Number.isFinite(n[idx])) {\n        const I = state.pv1_input_current;\n        const V = state.pv1_input_voltage;\n        const pCalc = (Number.isFinite(I) && Number.isFinite(V)) ? (I * V) : null;\n        const pField = n[idx];\n\n        if (pCalc != null && pCalc > 10) {\n          const ratio = pField / pCalc;\n          if (ratio > 0.8 && ratio < 1.2) {\n            pv1PowerIdx = idx;\n            context.set(\"pv1PowerIdx\", pv1PowerIdx);\n            state.pv1_power = int(idx);\n            break;\n          }\n        } else {\n          if (idx === 19) {\n            state.pv1_power = int(19);\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  state._last_qpigs_ts = Date.now();\n}\n\n// ===== NOUVEAU : GRID POWER (champ 25 firmwares r√©cents)\nif (f.length > 24 && Number.isFinite(n[24])) {\n  state.grid_power = int(24);\n}\n\n\n// ===== QPIGS2 (optionnel) =====\nif (cmd === \"QPIGS2\" && f.length >= 3) {\n  state.pv2_input_current = round(num(0), 1);\n  state.pv2_input_voltage = round(num(1), 1);\n  state.pv2_power = int(2);\n  state._last_qpigs2_ts = Date.now();\n}\n\n// ===== QMOD =====\nif (cmd === \"QMOD\") {\n  const rawMode = (f[0] ?? msg.payload.raw ?? \"\").toString().trim();\n  const modeMap = { P: \"Power On\", S: \"Standby\", L: \"Grid\", B: \"Battery\", F: \"Fault\" };\n  state.operation_mode = modeMap[rawMode] || rawMode || null;\n  state.operation_mode_code = rawMode || null;\n  state._last_qmod_ts = Date.now();\n}\n\n// ===== QPIRI -> PARAMETRES =====\nif (cmd === \"QPIRI\" && msg.payload?.nak !== true) {\n  const nf = (idx) => {\n    const v = (f && f.length > idx) ? f[idx] : null;\n    const nn = Number(v);\n    return Number.isFinite(nn) ? nn : null;\n  };\n\n  const mapBatteryType = (code) => {\n    const m = { 0: \"AGM\", 1: \"Flooded\", 2: \"User\", 3: \"Pylon\", 5: \"Weco\", 6: \"Soltaro\", 8: \"Lib\", 9: \"Lic\" };\n    return m[code] ?? String(code ?? \"\");\n  };\n  const mapOutputPriority = (code) => {\n    const m = { 0: \"UtilitySolarBat\", 1: \"SolarUtilityBat\", 2: \"SolarBatUtility\" };\n    return m[code] ?? String(code ?? \"\");\n  };\n  const mapChargerPriority = (code) => {\n    const m = { 1: \"Solar first\", 2: \"Solar + Utility\", 3: \"Only solar\" };\n    return m[code] ?? String(code ?? \"\");\n  };\n\n  if (!state.params || typeof state.params !== \"object\") state.params = {};\n\n  const battTypeCode = nf(12);\n  const outPrioCode = nf(16);\n  const chgPrioCode = nf(17);\n\n  state.params.qpiri = {\n    battery_recharge_voltage: nf(8),\n    battery_under_voltage: nf(9),\n    battery_bulk_voltage: nf(10),\n    battery_float_voltage: nf(11),\n\n    battery_type_code: battTypeCode,\n    battery_type: mapBatteryType(battTypeCode),\n\n    max_ac_charging_current: nf(13),\n    max_charging_current: nf(14),\n\n    output_source_priority_code: outPrioCode,\n    output_source_priority: mapOutputPriority(outPrioCode),\n\n    charger_source_priority_code: chgPrioCode,\n    charger_source_priority: mapChargerPriority(chgPrioCode),\n\n    battery_re_discharge_voltage: nf(22),\n    max_discharging_current: nf(27),\n\n    ts: Date.now()\n  };\n\n  state._last_qpiri_ts = Date.now();\n}\n\n// ===== QDOP -> PARAMETRES batterie (%) =====\nif (cmd === \"QDOP\" && msg.payload?.nak !== true) {\n  const nf = (idx) => {\n    const v = (f && f.length > idx) ? f[idx] : null;\n    const nn = Number(v);\n    return Number.isFinite(nn) ? nn : null;\n  };\n\n  if (!state.params || typeof state.params !== \"object\") state.params = {};\n\n  state.params.qdop = {\n    battery_recharge_capacity_pct: nf(8),\n    battery_redischarge_capacity_pct: nf(9),\n    battery_under_capacity_pct: nf(10),\n    ts: Date.now()\n  };\n\n  state._last_qdop_ts = Date.now();\n}\n\n// ===== DIAGNOSTIC (model/serial/fw + faults/warnings) =====\nif (cmd === \"QMN\" && msg.payload?.nak !== true) {\n  state.diag = state.diag || {};\n  state.diag.model = (f[0] ?? msg.payload.raw ?? \"\").toString().trim() || null;\n  state._last_qmn_ts = Date.now();\n}\n\nif ((cmd === \"QID\" || cmd === \"QSID\") && msg.payload?.nak !== true) {\n  state.diag = state.diag || {};\n  state.diag.serial = (f[0] ?? msg.payload.raw ?? \"\").toString().trim() || null;\n  state._last_qid_ts = Date.now();\n}\n\nif ((cmd === \"QVFW\" || cmd === \"QVFW3\") && msg.payload?.nak !== true) {\n  state.diag = state.diag || {};\n  const fw = (f[0] ?? msg.payload.raw ?? \"\").toString().trim() || null;\n  if (cmd === \"QVFW\") state.diag.fw_main = fw;\n  if (cmd === \"QVFW3\") state.diag.fw_remote = fw;\n  state._last_qvfw_ts = Date.now();\n}\n\n// ===== QPIWS -> FAULTS / WARNINGS (4 lignes HA) =====\nif (cmd === \"QPIWS\" && msg.payload?.nak !== true) {\n\n  const bits = String(f[0] ?? msg.payload.raw ?? \"\").trim();\n  if (!state.diag || typeof state.diag !== \"object\") state.diag = {};\n\n  const bit = (i) => (bits.length > i ? bits.charAt(i) === \"1\" : false);\n  const a1_fault = bit(1);\n\n  // Mapping QPIWS (principaux) - adapt√© doc\n  const map = [\n    { i: 0, label: \"PV loss\", kind: \"warn\" },\n    { i: 1, label: \"Inverter fault\", kind: \"fault\" },\n    { i: 2, label: \"Bus over\", kind: \"fault\" },\n    { i: 3, label: \"Bus under\", kind: \"fault\" },\n    { i: 4, label: \"Bus soft fail\", kind: \"fault\" },\n    { i: 5, label: \"Line fail\", kind: \"warn\" },\n    { i: 6, label: \"OPV short\", kind: \"fault\" },\n    { i: 7, label: \"Inverter voltage low\", kind: \"fault\" },\n    { i: 8, label: \"Inverter voltage high\", kind: \"fault\" },\n\n    // \"Compile with a1\" -> peut √™tre warning ou fault selon a1\n    { i: 9, label: \"Over temperature\", kind: () => a1_fault ? \"fault\" : \"warn\" },\n    { i: 10, label: \"Fan locked\", kind: () => a1_fault ? \"fault\" : \"warn\" },\n    { i: 11, label: \"Battery voltage high\", kind: () => a1_fault ? \"fault\" : \"warn\" },\n\n    { i: 12, label: \"Battery low alarm\", kind: \"warn\" },\n    { i: 14, label: \"Battery shutdown\", kind: \"warn\" },\n    { i: 15, label: \"Battery derating\", kind: \"warn\" },\n    { i: 16, label: \"Over load\", kind: () => a1_fault ? \"fault\" : \"warn\" },\n\n    { i: 17, label: \"EEPROM fault\", kind: \"warn\" },\n    { i: 18, label: \"Inverter over current\", kind: \"fault\" },\n    { i: 19, label: \"Inverter soft fail\", kind: \"fault\" },\n    { i: 20, label: \"Self test fail\", kind: \"fault\" },\n    { i: 21, label: \"OP DC voltage over\", kind: \"fault\" },\n    { i: 23, label: \"Current sensor fail\", kind: \"fault\" },\n\n    // VMIV sp√©cifiques (optionnels)\n    { i: 33, label: \"Low PV energy\", kind: \"warn\" },\n    { i: 34, label: \"High AC input\", kind: \"warn\" },\n    { i: 35, label: \"Battery equalization\", kind: \"warn\" }\n  ];\n\n  const faults = [];\n  const warns = [];\n\n  for (const m of map) {\n    if (!bit(m.i)) continue;\n    const k = (typeof m.kind === \"function\") ? m.kind() : m.kind;\n    if (k === \"fault\") faults.push(m.label);\n    else warns.push(m.label);\n  }\n\n  // ---- 4 lignes pour HA\n  state.diag.fault_state = faults.length ? \"FAULT\" : \"OK\";\n  state.diag.fault_details = faults.length ? faults.join(\", \") : \"None\";\n\n  state.diag.warn_state = warns.length ? \"WARN\" : \"OK\";\n  state.diag.warn_details = warns.length ? warns.join(\", \") : \"None\";\n\n  // bool utiles pour automations\n  state.diag.has_fault = faults.length > 0;\n  state.diag.has_warning = warns.length > 0;\n\n  state.diag._last_qpiws_ts = Date.now();\n}\n\n// ===== Support QPIGS2 (diagnostic) =====\nconst supportsKey = `inv${inv}_supports_qpigs2`;\nconst supports = flow.get(supportsKey);\nif (supports !== undefined) state.supports_qpigs2 = (supports !== false);\n\n// ===== ENERGIES (FIX Today) =====\nconst round2 = (v) => (v == null ? null : Math.round(v * 100) / 100);\nconst toKwhToday = (v) => (!Number.isFinite(v) ? null : round2(v / 1000));\nconst toKwhAuto = (v) => (!Number.isFinite(v) ? null : (v >= 10000 ? round2(v / 1000) : round2(v)));\n\nif (Number.isFinite(value)) {\n  // PV\n  if (cmd === \"QET\") { state.pv_energy_total_raw = value; state.pv_energy_total_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QEY\")) { state.pv_energy_year_raw = value; state.pv_energy_year_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QEM\")) { state.pv_energy_month_raw = value; state.pv_energy_month_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QED\")) { state.pv_energy_day_raw = value; state.pv_energy_day_kwh = toKwhToday(value); }\n\n  // LOAD\n  if (cmd === \"QLT\") { state.load_energy_total_raw = value; state.load_energy_total_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QLY\")) { state.load_energy_year_raw = value; state.load_energy_year_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QLM\")) { state.load_energy_month_raw = value; state.load_energy_month_kwh = toKwhAuto(value); }\n  if (cmd.startsWith(\"QLD\")) { state.load_energy_day_raw = value; state.load_energy_day_kwh = toKwhToday(value); }\n\n  state._last_energy_ts = Date.now();\n}\n\n// ===== PV total power =====\nconst pv1 = Number.isFinite(state.pv1_power) ? state.pv1_power : 0;\nconst pv2 = Number.isFinite(state.pv2_power) ? state.pv2_power : 0;\nstate.pv_total_power = pv1 + pv2;\n\n// ===== BATTERY POWER (W) - CUSTOM SENSORS =====\nconst Vb = Number.isFinite(state.battery_voltage) ? state.battery_voltage : null;\nconst Ichg = Number.isFinite(state.battery_charging_current) ? state.battery_charging_current : 0;\nconst Idis = Number.isFinite(state.battery_discharge_current) ? state.battery_discharge_current : 0;\n\nif (Vb != null) {\n  const chargeW = round(Vb * Math.max(0, Ichg), 1);\n  const dischargeW = round(Vb * Math.max(0, Idis), 1);\n\n  state.battery_charge = chargeW;              // +W\n  state.battery_discharge = dischargeW;        // +W\n  state.battery_power = (chargeW != null && dischargeW != null) ? round(chargeW - dischargeW, 1) : null;\n} else {\n  state.battery_charge = null;\n  state.battery_discharge = null;\n  state.battery_power = null;\n}\n\ncontext.set(\"state\", state);\nmsg.inverterNum = inv;\nmsg.payload = state;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 760,
        "wires": [
            [
                "81f39a65ee5f7e5f"
            ]
        ]
    },
    {
        "id": "81f39a65ee5f7e5f",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "5886b0dc312a65e2",
        "name": "MQTT state publisher",
        "func": "if (!msg.payload || typeof msg.payload !== \"object\") return null;\n\nconst inv = msg.inverterNum ?? 1;\n\nreturn [\n    {\n        topic: `voltronic/${inv}/state`,\n        payload: JSON.stringify(msg.payload),\n        retain: false\n    },\n    {\n        topic: `voltronic/${inv}/availability`,\n        payload: \"online\",\n        retain: true\n    }\n];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 760,
        "wires": [
            [
                "4d6727a8daa54583"
            ],
            [
                "4d6727a8daa54583"
            ]
        ]
    },
    {
        "id": "12e2da8864f63658",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "5886b0dc312a65e2",
        "name": "Queue Enqueue ",
        "func": "const inv = msg.inverterNum ?? 1;\nconst key = `inv${inv}_queue`;\n\nlet q = flow.get(key);\nif (!Array.isArray(q)) q = [];\n\n// msg peut √™tre 1 commande, ou un lot (si tu envoies [msgs])\n// Ici, on g√®re les deux cas proprement.\nconst toPush = [];\n\nif (Array.isArray(msg)) {\n    // rare : si tu envoies direct un tableau de msgs\n    toPush.push(...msg);\n} else if (Array.isArray(msg.payload) && msg.payload?.[0]?.command) {\n    // si jamais ton flow passe un tableau dans payload\n    toPush.push(...msg.payload);\n} else {\n    // msg normal\n    toPush.push(msg);\n}\n\n// ajoute uniquement si on a une commande\ntoPush.forEach(m => {\n    const cmd = (m.command || m._cmd || m.payload || \"\").toString().trim().toUpperCase();\n    if (!cmd) return;\n\n    q.push({\n        inverterNum: inv,\n        command: cmd,\n        _cmd: cmd,\n        payload: cmd,\n        enqueued_ts: Date.now()\n    });\n});\n\n// limite taille\nif (q.length > 200) q = q.slice(-200);\n\nflow.set(key, q);\n\n// d√©clenche le pump\nreturn { inverterNum: inv, topic: \"pump\" };\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 440,
        "y": 700,
        "wires": [
            [
                "8feb5755ad105131"
            ]
        ]
    },
    {
        "id": "8feb5755ad105131",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "5886b0dc312a65e2",
        "name": "Queue Pump ",
        "func": "const inv = msg.inverterNum ?? 1;\n\nconst qKey = `inv${inv}_queue`;\nconst inFlightKey = `inv${inv}_inflight`;\n\nlet inFlight = flow.get(inFlightKey);\n\n// Si une commande est d√©j√† en attente de r√©ponse, on n‚Äôen envoie pas une autre\nif (inFlight && (Date.now() - (inFlight.ts || 0)) < 3000) {\n  return null;\n}\n\nlet q = flow.get(qKey);\nif (!Array.isArray(q) || q.length === 0) return null;\n\n// Prend la prochaine commande\nconst next = q.shift();\nflow.set(qKey, q);\n\n// Marque comme en vol\nflow.set(inFlightKey, { cmd: next.command, ts: Date.now() });\n\n// Envoie au construire commande\nreturn next;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 720,
        "wires": [
            [
                "3723c166ecd597c8"
            ]
        ]
    },
    {
        "id": "3f12c1ae87a1cc36",
        "type": "inject",
        "z": "280951c3196085f3",
        "g": "5886b0dc312a65e2",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 650,
        "y": 680,
        "wires": [
            [
                "8feb5755ad105131"
            ]
        ]
    },
    {
        "id": "b0cf0a62812a68fe",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "5886b0dc312a65e2",
        "name": "tag",
        "func": "msg.inverterNum = 3;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 290,
        "y": 760,
        "wires": [
            [
                "934204be298bcd3d"
            ]
        ]
    },
    {
        "id": "235c705debdbb1ae",
        "type": "function",
        "z": "280951c3196085f3",
        "g": "5886b0dc312a65e2",
        "name": "HA SET ‚Üí Voltronic CMD",
        "func": "// HA SET -> Voltronic CMD  (1 sortie)\n// topic: voltronic/<inv>/set/<param>\n// payload: valeur\n\nconst m = (msg.topic || \"\").match(/^voltronic\\/(\\d+)\\/set\\/(.+)$/);\nif (!m) return null;\n\nconst inverterNum = Number(m[1]);\nconst param = m[2];\n\nlet v = msg.payload;\nif (typeof v === \"string\") v = v.trim();\n\nconst toNum = (x) => {\n  const n = Number(x);\n  return Number.isFinite(n) ? n : null;\n};\nconst pad3 = (x) => String(Math.trunc(Number(x))).padStart(3, \"0\");\nconst fixed1 = (x) => Number(x).toFixed(1);\nconst clamp = (x, a, b) => Math.min(b, Math.max(a, Number(x)));\n\nconst machine = inverterNum;\n\nlet cmd = null;\n\n// SELECTS\nif (param === \"output_source_priority\") {\n  const map = { UtilitySolarBat: \"POP00\", SolarUtilityBat: \"POP01\", SolarBatUtility: \"POP02\" };\n  cmd = map[v] || null;\n} else if (param === \"charger_source_priority\") {\n  const map = { \"Solar first\": \"PCP01\", \"Solar + Utility\": \"PCP02\", \"Only solar\": \"PCP03\" };\n  cmd = map[v] || null;\n} else if (param === \"battery_type\") {\n  const map = { AGM:\"PBT00\", Flooded:\"PBT01\", User:\"PBT02\", Pylon:\"PBT03\", Weco:\"PBT05\", Soltaro:\"PBT06\", Lib:\"PBT08\", Lic:\"PBT09\" };\n  cmd = map[v] || null;\n}\n\n// VOLTAGES nn.n\nelse if (param === \"battery_recharge_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PBCV${fixed1(nv)}`; }\nelse if (param === \"battery_re_discharge_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PBDV${fixed1(nv)}`; }\nelse if (param === \"battery_under_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PSDV${fixed1(nv)}`; }\nelse if (param === \"battery_bulk_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PCVV${fixed1(nv)}`; }\nelse if (param === \"battery_float_voltage\") { const nv = toNum(v); if (nv==null) return null; cmd = `PBFT${fixed1(nv)}`; }\n\n// CURRENTS\nelse if (param === \"max_charging_current\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `MNCHGC${machine}${pad3(clamp(nv,0,300))}`;\n}\nelse if (param === \"max_ac_charging_current\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `MUCHGC${machine}${pad3(clamp(nv,0,300))}`;\n}\nelse if (param === \"max_discharging_current\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `PBATMAXDISC${pad3(clamp(nv,0,300))}`;\n}\n\n// QDOP seuils %\nelse if (param === \"battery_recharge_capacity_pct\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `PBCC${pad3(clamp(nv,5,95))}`;\n}\nelse if (param === \"battery_redischarge_capacity_pct\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `PBDC${pad3(clamp(nv,10,100))}`;\n}\nelse if (param === \"battery_under_capacity_pct\") {\n  const nv = toNum(v); if (nv==null) return null;\n  cmd = `PSDC${pad3(clamp(nv,0,90))}`;\n}\n\nif (!cmd) return null;\n\nconst mk = (c) => ({\n  inverterNum,\n  command: c,\n  _cmd: c,\n  payload: c,\n  _burst: true\n});\n\n// 1Ô∏è‚É£ Message SET (prioritaire)\nconst setMsg = mk(cmd);\nsetMsg._burst = false;\n\n// 2Ô∏è‚É£ Rafale refresh apr√®s SET (pour MAJ imm√©diate HA)\nconst refresh = [\"QPIRI\", \"QDOP\", \"QMOD\", \"QPIGS\"];\n// optionnel si support√© : refresh.splice(3,0,\"QPIGS2\");\n\nconst out = [setMsg, ...refresh.map(mk)];\n\nnode.status({\n  fill: \"green\",\n  shape: \"dot\",\n  text: `SET ${param} + refresh x${out.length - 1}`\n});\n\n// ‚ùóÔ∏èIMPORTANT : 1 sortie => tableau de messages dans la sortie 1\nreturn [out];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 820,
        "wires": [
            [
                "498a02e4859e8220"
            ]
        ]
    },
    {
        "id": "45c1028f3ead8766",
        "type": "mqtt in",
        "z": "280951c3196085f3",
        "g": "5886b0dc312a65e2",
        "name": "MQTT IN - HA SET",
        "topic": "voltronic/+/set/+",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "mqtt_broker",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 130,
        "y": 820,
        "wires": [
            [
                "235c705debdbb1ae"
            ]
        ]
    },
    {
        "id": "498a02e4859e8220",
        "type": "link out",
        "z": "280951c3196085f3",
        "g": "5886b0dc312a65e2",
        "name": "link out 3",
        "mode": "link",
        "links": [
            "636d882818322eec"
        ],
        "x": 545,
        "y": 820,
        "wires": []
    },
    {
        "id": "636d882818322eec",
        "type": "link in",
        "z": "280951c3196085f3",
        "g": "5886b0dc312a65e2",
        "name": "link in 3",
        "links": [
            "498a02e4859e8220"
        ],
        "x": 315,
        "y": 640,
        "wires": [
            [
                "12e2da8864f63658"
            ]
        ]
    },
    {
        "id": "49440ecbca3993df",
        "type": "serial in",
        "z": "280951c3196085f3",
        "g": "5886b0dc312a65e2",
        "name": "üì• Serial In 3",
        "serial": "39e06a015d18096d",
        "x": 130,
        "y": 760,
        "wires": [
            [
                "b0cf0a62812a68fe"
            ]
        ]
    },
    {
        "id": "f2b75a0a86b82097",
        "type": "serial out",
        "z": "280951c3196085f3",
        "g": "5886b0dc312a65e2",
        "name": "üì§ Serial Out 3",
        "serial": "39e06a015d18096d",
        "x": 1100,
        "y": 700,
        "wires": []
    },
    {
        "id": "a21ddb7191f1b93f",
        "type": "function",
        "z": "296b81230a5aed2a",
        "g": "fca760cd70eac181",
        "name": "üîç HA Discovery ond1",
        "func": "const inv = 1;\n\nconst base = `voltronic/${inv}`;\nconst state_topic = `${base}/state`;\nconst availability_topic = `${base}/availability`;\nconst set_base = `${base}/set`; // o√π HA publiera les changements\n\nconst device = {\n  identifiers: [`voltronic_inv_${inv}`],\n  name: `Voltronic Inverter ${inv}`,\n  manufacturer: \"Voltronic\",\n  model: \"Axpert/Voltronic\",\n};\n\nfunction sensorCfg(objectId, name, unit, device_class, state_class, valueTpl, extra = {}) {\n  const uid = `voltronic_${inv}_${objectId}`;\n  const topic = `homeassistant/sensor/${uid}/config`;\n\n  const payload = {\n    name,\n    unique_id: uid,\n    state_topic,\n    availability_topic,\n    payload_available: \"online\",\n    payload_not_available: \"offline\",\n    value_template: valueTpl,\n    device,\n    ...extra,\n  };\n\n  if (unit) payload.unit_of_measurement = unit;\n  if (device_class) payload.device_class = device_class;\n  if (state_class) payload.state_class = state_class;\n\n  return { topic, payload: JSON.stringify(payload), retain: true };\n}\n\nfunction binarySensorCfg(objectId, name, device_class, valueTpl, extra = {}) {\n  const uid = `voltronic_${inv}_${objectId}`;\n  const topic = `homeassistant/binary_sensor/${uid}/config`;\n\n  const payload = {\n    name,\n    unique_id: uid,\n    state_topic,\n    availability_topic,\n    payload_available: \"online\",\n    payload_not_available: \"offline\",\n    value_template: valueTpl,\n    device,\n    ...extra,\n  };\n\n  if (device_class) payload.device_class = device_class;\n\n  return { topic, payload: JSON.stringify(payload), retain: true };\n}\n\nfunction selectCfg(objectId, name, options, valueTpl, commandTopic, extra = {}) {\n  const uid = `voltronic_${inv}_${objectId}`;\n  const topic = `homeassistant/select/${uid}/config`;\n\n  const payload = {\n    name,\n    unique_id: uid,\n    state_topic,\n    availability_topic,\n    payload_available: \"online\",\n    payload_not_available: \"offline\",\n    value_template: valueTpl,\n    command_topic: commandTopic,\n    options,\n    device,\n    ...extra,\n  };\n\n  return { topic, payload: JSON.stringify(payload), retain: true };\n}\n\nfunction numberCfg(objectId, name, unit, min, max, step, valueTpl, commandTopic, extra = {}) {\n  const uid = `voltronic_${inv}_${objectId}`;\n  const topic = `homeassistant/number/${uid}/config`;\n\n  const payload = {\n    name,\n    unique_id: uid,\n    state_topic,\n    availability_topic,\n    payload_available: \"online\",\n    payload_not_available: \"offline\",\n    value_template: valueTpl,\n    command_topic: commandTopic,\n    unit_of_measurement: unit,\n    min,\n    max,\n    step,\n    mode: \"box\",\n    device,\n    ...extra,\n  };\n\n  return { topic, payload: JSON.stringify(payload), retain: true };\n}\n\n// =======================\n// 1) CAPTEURS\n// =======================\nconst msgsSensors = [\n  // --- AC\n  sensorCfg(\"ac_output_active_power\", \"AC Output Active Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.ac_output_active_power }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n  sensorCfg(\"ac_output_voltage\", \"AC Output Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.ac_output_voltage }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n  sensorCfg(\"ac_output_frequency\", \"AC Output Frequency\", \"Hz\", \"frequency\", \"measurement\", \"{{ value_json.ac_output_frequency }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n  sensorCfg(\"output_load_percent\", \"Output Load\", \"%\", null, \"measurement\", \"{{ value_json.output_load_percent }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n  sensorCfg(\"operation_mode\", \"Operation Mode\", null, null, null, \"{{ value_json.operation_mode }}\"),\n\n  // --- Batterie (mesures)\n  sensorCfg(\"battery_voltage\", \"Battery Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.battery_voltage }}\", { icon: \"mdi:battery-charging-high\" }),\n  sensorCfg(\"battery_charging_current\", \"Battery Charging Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.battery_charging_current }}\", { icon: \"mdi:battery-arrow-up-outline\" }),\n  sensorCfg(\"battery_discharge_current\", \"Battery Discharge Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.battery_discharge_current }}\", { icon: \"mdi:battery-arrow-down-outline\" }),\n  sensorCfg(\"battery_capacity\", \"Battery Capacity\", \"%\", \"battery\", \"measurement\", \"{{ value_json.battery_capacity }}\", { icon: \"mdi:battery-charging-high\" }),\n\n  // --- Puissances batterie (perso)\n  sensorCfg(\"battery_charge\", \"Battery charge\", \"W\", \"power\", \"measurement\", \"{{ value_json.battery_charge }}\", { icon: \"mdi:battery-arrow-up-outline\" }),\n  sensorCfg(\"battery_discharge\", \"Battery discharge\", \"W\", \"power\", \"measurement\", \"{{ value_json.battery_discharge }}\", { icon: \"mdi:battery-arrow-down-outline\" }),\n  sensorCfg(\"battery_power\", \"Battery power\", \"W\", \"power\", \"measurement\", \"{{ value_json.battery_power }}\", { icon: \"mdi:battery-charging-high\" }),\n\n  // --- PV\n  sensorCfg(\"pv_total_power\", \"PV Total Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.pv_total_power }}\", { icon: \"mdi:solar-power\" }),\n  sensorCfg(\"pv1_power\", \"PV1 Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.pv1_power }}\", { icon: \"mdi:solar-power\" }),\n  sensorCfg(\"pv2_power\", \"PV2 Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.pv2_power }}\", { icon: \"mdi:solar-power\" }),\n  sensorCfg(\"pv1_input_voltage\", \"PV1 Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.pv1_input_voltage }}\"),\n  sensorCfg(\"pv2_input_voltage\", \"PV2 Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.pv2_input_voltage }}\"),\n  sensorCfg(\"pv1_input_current\", \"PV1 Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.pv1_input_current }}\"),\n  sensorCfg(\"pv2_input_current\", \"PV2 Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.pv2_input_current }}\"),\n\n  // --- R√©seau\n  sensorCfg(\"grid_voltage\", \"Grid Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.grid_voltage }}\", { icon: \"mdi:transmission-tower\" }),\n  // ‚úÖ FIX : tu avais \"}}\" -> corrig√©\n  sensorCfg(\"grid_frequency\", \"Grid Frequency\", \"Hz\", \"frequency\", \"measurement\", \"{{ value_json.grid_frequency }}\", { icon: \"mdi:transmission-tower\" }),\n\n  // --- Temp\n  sensorCfg(\"inverter_heat_sink_temp\", \"Inverter Heatsink Temp\", \"¬∞C\", \"temperature\", \"measurement\", \"{{ value_json.inverter_heat_sink_temp }}\"),\n  sensorCfg(\n  \"grid_power\",\n  \"Grid Power\",\n  \"W\",\n  \"power\",\n  \"measurement\",\n  \"{{ value_json.grid_power }}\",\n  { icon: \"mdi:transmission-tower\" }\n),\n\n\n  // --- ENERGIES\n  sensorCfg(\"load_energy_month_kwh\", \"Load month\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.load_energy_month_kwh }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n  sensorCfg(\"load_energy_year_kwh\", \"Load year\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.load_energy_year_kwh }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n  sensorCfg(\"load_energy_day_kwh\", \"Load today\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.load_energy_day_kwh }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n  sensorCfg(\"load_energy_total_kwh\", \"Load total\", \"kWh\", \"energy\", \"total_increasing\", \"{{ value_json.load_energy_total_kwh }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n\n  sensorCfg(\"pv_energy_month_kwh\", \"PV month\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.pv_energy_month_kwh }}\", { icon: \"mdi:solar-power\" }),\n  sensorCfg(\"pv_energy_year_kwh\", \"PV year\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.pv_energy_year_kwh }}\", { icon: \"mdi:solar-power\" }),\n  sensorCfg(\"pv_energy_day_kwh\", \"PV today\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.pv_energy_day_kwh }}\", { icon: \"mdi:solar-power\" }),\n  sensorCfg(\"pv_energy_total_kwh\", \"PV total\", \"kWh\", \"energy\", \"total_increasing\", \"{{ value_json.pv_energy_total_kwh }}\", { icon: \"mdi:solar-power\" }),\n\n  // =======================\n  // DIAGNOSTIC\n  // =======================\n  sensorCfg(\"diag_model\", \"Inverter Model\", null, null, null, \"{{ value_json.diag.model }}\", { entity_category: \"diagnostic\" }),\n  sensorCfg(\"diag_serial\", \"Inverter Serial\", null, null, null, \"{{ value_json.diag.serial }}\", { entity_category: \"diagnostic\" }),\n  sensorCfg(\"diag_fw_main\", \"Firmware Main\", null, null, null, \"{{ value_json.diag.fw_main }}\", { entity_category: \"diagnostic\" }),\n  sensorCfg(\"diag_fw_remote\", \"Firmware Remote\", null, null, null, \"{{ value_json.diag.fw_remote }}\", { entity_category: \"diagnostic\" }),\n\n  // ‚úÖ NOUVELLES 4 LIGNES (Fault/Warn)\n  sensorCfg(\"diag_fault_state\", \"Fault state\", null, null, null, \"{{ value_json.diag.fault_state }}\", { entity_category: \"diagnostic\", icon: \"mdi:alert-circle\" }),\n  sensorCfg(\"diag_fault_details\", \"Fault details\", null, null, null, \"{{ value_json.diag.fault_details }}\", { entity_category: \"diagnostic\", icon: \"mdi:alert-box-outline\" }),\n  sensorCfg(\"diag_warn_state\", \"Warning state\", null, null, null, \"{{ value_json.diag.warn_state }}\", { entity_category: \"diagnostic\", icon: \"mdi:alert-outline\" }),\n  sensorCfg(\"diag_warn_details\", \"Warning details\", null, null, null, \"{{ value_json.diag.warn_details }}\", { entity_category: \"diagnostic\", icon: \"mdi:text-box-alert-outline\" }),\n];\n\n// ==========================================\n// 2) PARAMETRES\n// ==========================================\nconst baseTplQPIRI = \"value_json.params.qpiri\";\nconst baseTplQDOP = \"value_json.params.qdop\";\n\nconst msgsParams = [\n  selectCfg(\"param_battery_type\", \"Battery type\",\n    [\"AGM\", \"Flooded\", \"User\", \"Lib\", \"Lic\", \"Pylon\", \"Weco\", \"Soltaro\"],\n    `{{ ${baseTplQPIRI}.battery_type }}`,\n    `${set_base}/battery_type`\n  ),\n\n  selectCfg(\"param_output_source_priority\", \"Source priority\",\n    [\"UtilitySolarBat\", \"SolarUtilityBat\", \"SolarBatUtility\"],\n    `{{ ${baseTplQPIRI}.output_source_priority }}`,\n    `${set_base}/output_source_priority`\n  ),\n\n  selectCfg(\"param_charger_source_priority\", \"Charging priority\",\n    [\"Solar first\", \"Solar + Utility\", \"Only solar\"],\n    `{{ ${baseTplQPIRI}.charger_source_priority }}`,\n    `${set_base}/charger_source_priority`\n  ),\n\n  // Voltages\n  numberCfg(\"param_battery_bulk_voltage\", \"Bulk\", \"V\", 40, 65, 0.1,\n    `{{ ${baseTplQPIRI}.battery_bulk_voltage }}`, `${set_base}/battery_bulk_voltage`\n  ),\n  numberCfg(\"param_battery_float_voltage\", \"Float\", \"V\", 40, 65, 0.1,\n    `{{ ${baseTplQPIRI}.battery_float_voltage }}`, `${set_base}/battery_float_voltage`\n  ),\n  numberCfg(\"param_battery_re_discharge_voltage\", \"Re-discharge voltage\", \"V\", 40, 65, 0.1,\n    `{{ ${baseTplQPIRI}.battery_re_discharge_voltage }}`, `${set_base}/battery_re_discharge_voltage`\n  ),\n  numberCfg(\"param_battery_recharge_voltage\", \"Return grid V\", \"V\", 40, 65, 0.1,\n    `{{ ${baseTplQPIRI}.battery_recharge_voltage }}`, `${set_base}/battery_recharge_voltage`\n  ),\n  numberCfg(\"param_battery_under_voltage\", \"Under voltage\", \"V\", 40, 65, 0.1,\n    `{{ ${baseTplQPIRI}.battery_under_voltage }}`, `${set_base}/battery_under_voltage`\n  ),\n\n  // Currents (discrets)\n  selectCfg(\"param_max_ac_charging_current\", \"Grid charging current\",\n    [\"2\", \"10\", \"20\", \"30\", \"40\", \"50\", \"60\", \"70\", \"80\", \"90\", \"100\", \"110\", \"120\", \"130\", \"140\", \"150\"],\n    `{{ ${baseTplQPIRI}.max_ac_charging_current }}`,\n    `${set_base}/max_ac_charging_current`,\n    { icon: \"mdi:transmission-tower\" }\n  ),\n  selectCfg(\"param_max_charging_current\", \"Max charging current\",\n    [\"10\", \"20\", \"30\", \"40\", \"50\", \"60\", \"70\", \"80\", \"90\", \"100\", \"110\", \"120\", \"130\", \"140\", \"150\"],\n    `{{ ${baseTplQPIRI}.max_charging_current }}`,\n    `${set_base}/max_charging_current`,\n    { icon: \"mdi:battery-charging\" }\n  ),\n  selectCfg(\"param_max_discharging_current\", \"Max discharging current\",\n    [\"10\", \"20\", \"30\", \"40\", \"50\", \"60\", \"70\", \"80\", \"90\", \"100\", \"110\", \"120\", \"130\", \"140\", \"150\"],\n    `{{ ${baseTplQPIRI}.max_discharging_current }}`,\n    `${set_base}/max_discharging_current`,\n    { icon: \"mdi:battery-arrow-down\" }\n  ),\n\n  // QDOP % (5%)\n  numberCfg(\"param_battery_recharge_capacity_pct\", \"Return grid %\", \"%\", 0, 100, 5,\n    `{{ ${baseTplQDOP}.battery_recharge_capacity_pct }}`, `${set_base}/battery_recharge_capacity_pct`\n  ),\n  numberCfg(\"param_battery_redischarge_capacity_pct\", \"Return battery %\", \"%\", 0, 100, 5,\n    `{{ ${baseTplQDOP}.battery_redischarge_capacity_pct }}`, `${set_base}/battery_redischarge_capacity_pct`\n  ),\n  numberCfg(\"param_battery_under_capacity_pct\", \"Battery under capacity %\", \"%\", 0, 100, 5,\n    `{{ ${baseTplQDOP}.battery_under_capacity_pct }}`, `${set_base}/battery_under_capacity_pct`\n  ),\n];\n\nconst msgs = [...msgsSensors, ...msgsParams];\nreturn [msgs];\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 80,
        "wires": [
            [
                "a5d5ee44dfe21839"
            ]
        ]
    },
    {
        "id": "a5d5ee44dfe21839",
        "type": "mqtt out",
        "z": "296b81230a5aed2a",
        "g": "fca760cd70eac181",
        "name": "üì° MQTT Out",
        "topic": "",
        "qos": "0",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "mqtt_broker",
        "x": 700,
        "y": 80,
        "wires": []
    },
    {
        "id": "5c73574c1a191af3",
        "type": "inject",
        "z": "296b81230a5aed2a",
        "g": "fca760cd70eac181",
        "name": "‚è∞ Au d√©marrage",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 170,
        "y": 80,
        "wires": [
            [
                "a21ddb7191f1b93f"
            ]
        ]
    },
    {
        "id": "9900a8c0b8fb0ade",
        "type": "function",
        "z": "296b81230a5aed2a",
        "g": "2ffb0ad1ec6c4336",
        "name": "üîç HA Discovery ond2",
        "func": "const inv = 2;\n\nconst base = `voltronic/${inv}`;\nconst state_topic = `${base}/state`;\nconst availability_topic = `${base}/availability`;\nconst set_base = `${base}/set`; // o√π HA publiera les changements\n\nconst device = {\n  identifiers: [`voltronic_inv_${inv}`],\n  name: `Voltronic Inverter ${inv}`,\n  manufacturer: \"Voltronic\",\n  model: \"Axpert/Voltronic\",\n};\n\nfunction sensorCfg(objectId, name, unit, device_class, state_class, valueTpl, extra = {}) {\n  const uid = `voltronic_${inv}_${objectId}`;\n  const topic = `homeassistant/sensor/${uid}/config`;\n\n  const payload = {\n    name,\n    unique_id: uid,\n    state_topic,\n    availability_topic,\n    payload_available: \"online\",\n    payload_not_available: \"offline\",\n    value_template: valueTpl,\n    device,\n    ...extra,\n  };\n\n  if (unit) payload.unit_of_measurement = unit;\n  if (device_class) payload.device_class = device_class;\n  if (state_class) payload.state_class = state_class;\n\n  return { topic, payload: JSON.stringify(payload), retain: true };\n}\n\nfunction binarySensorCfg(objectId, name, device_class, valueTpl, extra = {}) {\n  const uid = `voltronic_${inv}_${objectId}`;\n  const topic = `homeassistant/binary_sensor/${uid}/config`;\n\n  const payload = {\n    name,\n    unique_id: uid,\n    state_topic,\n    availability_topic,\n    payload_available: \"online\",\n    payload_not_available: \"offline\",\n    value_template: valueTpl,\n    device,\n    ...extra,\n  };\n\n  if (device_class) payload.device_class = device_class;\n\n  return { topic, payload: JSON.stringify(payload), retain: true };\n}\n\nfunction selectCfg(objectId, name, options, valueTpl, commandTopic, extra = {}) {\n  const uid = `voltronic_${inv}_${objectId}`;\n  const topic = `homeassistant/select/${uid}/config`;\n\n  const payload = {\n    name,\n    unique_id: uid,\n    state_topic,\n    availability_topic,\n    payload_available: \"online\",\n    payload_not_available: \"offline\",\n    value_template: valueTpl,\n    command_topic: commandTopic,\n    options,\n    device,\n    ...extra,\n  };\n\n  return { topic, payload: JSON.stringify(payload), retain: true };\n}\n\nfunction numberCfg(objectId, name, unit, min, max, step, valueTpl, commandTopic, extra = {}) {\n  const uid = `voltronic_${inv}_${objectId}`;\n  const topic = `homeassistant/number/${uid}/config`;\n\n  const payload = {\n    name,\n    unique_id: uid,\n    state_topic,\n    availability_topic,\n    payload_available: \"online\",\n    payload_not_available: \"offline\",\n    value_template: valueTpl,\n    command_topic: commandTopic,\n    unit_of_measurement: unit,\n    min,\n    max,\n    step,\n    mode: \"box\",\n    device,\n    ...extra,\n  };\n\n  return { topic, payload: JSON.stringify(payload), retain: true };\n}\n\n// =======================\n// 1) CAPTEURS\n// =======================\nconst msgsSensors = [\n  // --- AC\n  sensorCfg(\"ac_output_active_power\", \"AC Output Active Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.ac_output_active_power }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n  sensorCfg(\"ac_output_voltage\", \"AC Output Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.ac_output_voltage }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n  sensorCfg(\"ac_output_frequency\", \"AC Output Frequency\", \"Hz\", \"frequency\", \"measurement\", \"{{ value_json.ac_output_frequency }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n  sensorCfg(\"output_load_percent\", \"Output Load\", \"%\", null, \"measurement\", \"{{ value_json.output_load_percent }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n  sensorCfg(\"operation_mode\", \"Operation Mode\", null, null, null, \"{{ value_json.operation_mode }}\"),\n\n  // --- Batterie (mesures)\n  sensorCfg(\"battery_voltage\", \"Battery Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.battery_voltage }}\", { icon: \"mdi:battery-charging-high\" }),\n  sensorCfg(\"battery_charging_current\", \"Battery Charging Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.battery_charging_current }}\", { icon: \"mdi:battery-arrow-up-outline\" }),\n  sensorCfg(\"battery_discharge_current\", \"Battery Discharge Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.battery_discharge_current }}\", { icon: \"mdi:battery-arrow-down-outline\" }),\n  sensorCfg(\"battery_capacity\", \"Battery Capacity\", \"%\", \"battery\", \"measurement\", \"{{ value_json.battery_capacity }}\", { icon: \"mdi:battery-charging-high\" }),\n\n  // --- Puissances batterie (perso)\n  sensorCfg(\"battery_charge\", \"Battery charge\", \"W\", \"power\", \"measurement\", \"{{ value_json.battery_charge }}\", { icon: \"mdi:battery-arrow-up-outline\" }),\n  sensorCfg(\"battery_discharge\", \"Battery discharge\", \"W\", \"power\", \"measurement\", \"{{ value_json.battery_discharge }}\", { icon: \"mdi:battery-arrow-down-outline\" }),\n  sensorCfg(\"battery_power\", \"Battery power\", \"W\", \"power\", \"measurement\", \"{{ value_json.battery_power }}\", { icon: \"mdi:battery-charging-high\" }),\n\n  // --- PV\n  sensorCfg(\"pv_total_power\", \"PV Total Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.pv_total_power }}\", { icon: \"mdi:solar-power\" }),\n  sensorCfg(\"pv1_power\", \"PV1 Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.pv1_power }}\", { icon: \"mdi:solar-power\" }),\n  sensorCfg(\"pv2_power\", \"PV2 Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.pv2_power }}\", { icon: \"mdi:solar-power\" }),\n  sensorCfg(\"pv1_input_voltage\", \"PV1 Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.pv1_input_voltage }}\"),\n  sensorCfg(\"pv2_input_voltage\", \"PV2 Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.pv2_input_voltage }}\"),\n  sensorCfg(\"pv1_input_current\", \"PV1 Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.pv1_input_current }}\"),\n  sensorCfg(\"pv2_input_current\", \"PV2 Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.pv2_input_current }}\"),\n\n  // --- R√©seau\n  sensorCfg(\"grid_voltage\", \"Grid Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.grid_voltage }}\", { icon: \"mdi:transmission-tower\" }),\n  // ‚úÖ FIX : tu avais \"}}\" -> corrig√©\n  sensorCfg(\"grid_frequency\", \"Grid Frequency\", \"Hz\", \"frequency\", \"measurement\", \"{{ value_json.grid_frequency }}\", { icon: \"mdi:transmission-tower\" }),\n\n  // --- Temp\n  sensorCfg(\"inverter_heat_sink_temp\", \"Inverter Heatsink Temp\", \"¬∞C\", \"temperature\", \"measurement\", \"{{ value_json.inverter_heat_sink_temp }}\"),\n  sensorCfg(\n  \"grid_power\",\n  \"Grid Power\",\n  \"W\",\n  \"power\",\n  \"measurement\",\n  \"{{ value_json.grid_power }}\",\n  { icon: \"mdi:transmission-tower\" }\n),\n\n\n  // --- ENERGIES\n  sensorCfg(\"load_energy_month_kwh\", \"Load month\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.load_energy_month_kwh }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n  sensorCfg(\"load_energy_year_kwh\", \"Load year\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.load_energy_year_kwh }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n  sensorCfg(\"load_energy_day_kwh\", \"Load today\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.load_energy_day_kwh }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n  sensorCfg(\"load_energy_total_kwh\", \"Load total\", \"kWh\", \"energy\", \"total_increasing\", \"{{ value_json.load_energy_total_kwh }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n\n  sensorCfg(\"pv_energy_month_kwh\", \"PV month\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.pv_energy_month_kwh }}\", { icon: \"mdi:solar-power\" }),\n  sensorCfg(\"pv_energy_year_kwh\", \"PV year\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.pv_energy_year_kwh }}\", { icon: \"mdi:solar-power\" }),\n  sensorCfg(\"pv_energy_day_kwh\", \"PV today\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.pv_energy_day_kwh }}\", { icon: \"mdi:solar-power\" }),\n  sensorCfg(\"pv_energy_total_kwh\", \"PV total\", \"kWh\", \"energy\", \"total_increasing\", \"{{ value_json.pv_energy_total_kwh }}\", { icon: \"mdi:solar-power\" }),\n\n  // =======================\n  // DIAGNOSTIC\n  // =======================\n  sensorCfg(\"diag_model\", \"Inverter Model\", null, null, null, \"{{ value_json.diag.model }}\", { entity_category: \"diagnostic\" }),\n  sensorCfg(\"diag_serial\", \"Inverter Serial\", null, null, null, \"{{ value_json.diag.serial }}\", { entity_category: \"diagnostic\" }),\n  sensorCfg(\"diag_fw_main\", \"Firmware Main\", null, null, null, \"{{ value_json.diag.fw_main }}\", { entity_category: \"diagnostic\" }),\n  sensorCfg(\"diag_fw_remote\", \"Firmware Remote\", null, null, null, \"{{ value_json.diag.fw_remote }}\", { entity_category: \"diagnostic\" }),\n\n  // ‚úÖ NOUVELLES 4 LIGNES (Fault/Warn)\n  sensorCfg(\"diag_fault_state\", \"Fault state\", null, null, null, \"{{ value_json.diag.fault_state }}\", { entity_category: \"diagnostic\", icon: \"mdi:alert-circle\" }),\n  sensorCfg(\"diag_fault_details\", \"Fault details\", null, null, null, \"{{ value_json.diag.fault_details }}\", { entity_category: \"diagnostic\", icon: \"mdi:alert-box-outline\" }),\n  sensorCfg(\"diag_warn_state\", \"Warning state\", null, null, null, \"{{ value_json.diag.warn_state }}\", { entity_category: \"diagnostic\", icon: \"mdi:alert-outline\" }),\n  sensorCfg(\"diag_warn_details\", \"Warning details\", null, null, null, \"{{ value_json.diag.warn_details }}\", { entity_category: \"diagnostic\", icon: \"mdi:text-box-alert-outline\" }),\n];\n\n// ==========================================\n// 2) PARAMETRES\n// ==========================================\nconst baseTplQPIRI = \"value_json.params.qpiri\";\nconst baseTplQDOP = \"value_json.params.qdop\";\n\nconst msgsParams = [\n  selectCfg(\"param_battery_type\", \"Battery type\",\n    [\"AGM\", \"Flooded\", \"User\", \"Lib\", \"Lic\", \"Pylon\", \"Weco\", \"Soltaro\"],\n    `{{ ${baseTplQPIRI}.battery_type }}`,\n    `${set_base}/battery_type`\n  ),\n\n  selectCfg(\"param_output_source_priority\", \"Source priority\",\n    [\"UtilitySolarBat\", \"SolarUtilityBat\", \"SolarBatUtility\"],\n    `{{ ${baseTplQPIRI}.output_source_priority }}`,\n    `${set_base}/output_source_priority`\n  ),\n\n  selectCfg(\"param_charger_source_priority\", \"Charging priority\",\n    [\"Solar first\", \"Solar + Utility\", \"Only solar\"],\n    `{{ ${baseTplQPIRI}.charger_source_priority }}`,\n    `${set_base}/charger_source_priority`\n  ),\n\n  // Voltages\n  numberCfg(\"param_battery_bulk_voltage\", \"Bulk\", \"V\", 40, 65, 0.1,\n    `{{ ${baseTplQPIRI}.battery_bulk_voltage }}`, `${set_base}/battery_bulk_voltage`\n  ),\n  numberCfg(\"param_battery_float_voltage\", \"Float\", \"V\", 40, 65, 0.1,\n    `{{ ${baseTplQPIRI}.battery_float_voltage }}`, `${set_base}/battery_float_voltage`\n  ),\n  numberCfg(\"param_battery_re_discharge_voltage\", \"Re-discharge voltage\", \"V\", 40, 65, 0.1,\n    `{{ ${baseTplQPIRI}.battery_re_discharge_voltage }}`, `${set_base}/battery_re_discharge_voltage`\n  ),\n  numberCfg(\"param_battery_recharge_voltage\", \"Return grid V\", \"V\", 40, 65, 0.1,\n    `{{ ${baseTplQPIRI}.battery_recharge_voltage }}`, `${set_base}/battery_recharge_voltage`\n  ),\n  numberCfg(\"param_battery_under_voltage\", \"Under voltage\", \"V\", 40, 65, 0.1,\n    `{{ ${baseTplQPIRI}.battery_under_voltage }}`, `${set_base}/battery_under_voltage`\n  ),\n\n  // Currents (discrets)\n  selectCfg(\"param_max_ac_charging_current\", \"Grid charging current\",\n    [\"2\", \"10\", \"20\", \"30\", \"40\", \"50\", \"60\", \"70\", \"80\", \"90\", \"100\", \"110\", \"120\", \"130\", \"140\", \"150\"],\n    `{{ ${baseTplQPIRI}.max_ac_charging_current }}`,\n    `${set_base}/max_ac_charging_current`,\n    { icon: \"mdi:transmission-tower\" }\n  ),\n  selectCfg(\"param_max_charging_current\", \"Max charging current\",\n    [\"10\", \"20\", \"30\", \"40\", \"50\", \"60\", \"70\", \"80\", \"90\", \"100\", \"110\", \"120\", \"130\", \"140\", \"150\"],\n    `{{ ${baseTplQPIRI}.max_charging_current }}`,\n    `${set_base}/max_charging_current`,\n    { icon: \"mdi:battery-charging\" }\n  ),\n  selectCfg(\"param_max_discharging_current\", \"Max discharging current\",\n    [\"10\", \"20\", \"30\", \"40\", \"50\", \"60\", \"70\", \"80\", \"90\", \"100\", \"110\", \"120\", \"130\", \"140\", \"150\"],\n    `{{ ${baseTplQPIRI}.max_discharging_current }}`,\n    `${set_base}/max_discharging_current`,\n    { icon: \"mdi:battery-arrow-down\" }\n  ),\n\n  // QDOP % (5%)\n  numberCfg(\"param_battery_recharge_capacity_pct\", \"Return grid %\", \"%\", 0, 100, 5,\n    `{{ ${baseTplQDOP}.battery_recharge_capacity_pct }}`, `${set_base}/battery_recharge_capacity_pct`\n  ),\n  numberCfg(\"param_battery_redischarge_capacity_pct\", \"Return battery %\", \"%\", 0, 100, 5,\n    `{{ ${baseTplQDOP}.battery_redischarge_capacity_pct }}`, `${set_base}/battery_redischarge_capacity_pct`\n  ),\n  numberCfg(\"param_battery_under_capacity_pct\", \"Battery under capacity %\", \"%\", 0, 100, 5,\n    `{{ ${baseTplQDOP}.battery_under_capacity_pct }}`, `${set_base}/battery_under_capacity_pct`\n  ),\n];\n\nconst msgs = [...msgsSensors, ...msgsParams];\nreturn [msgs];\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 200,
        "wires": [
            [
                "9fd6ea60084d9aba"
            ]
        ]
    },
    {
        "id": "9fd6ea60084d9aba",
        "type": "mqtt out",
        "z": "296b81230a5aed2a",
        "g": "2ffb0ad1ec6c4336",
        "name": "üì° MQTT Out",
        "topic": "",
        "qos": "0",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "mqtt_broker",
        "x": 700,
        "y": 200,
        "wires": []
    },
    {
        "id": "423279481f2891e9",
        "type": "inject",
        "z": "296b81230a5aed2a",
        "g": "2ffb0ad1ec6c4336",
        "name": "‚è∞ Au d√©marrage",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 170,
        "y": 200,
        "wires": [
            [
                "9900a8c0b8fb0ade"
            ]
        ]
    },
    {
        "id": "05595a6f316d37e4",
        "type": "function",
        "z": "296b81230a5aed2a",
        "g": "8b109ad885d98582",
        "name": "üîç HA Discovery ond3",
        "func": "const inv = 3;\n\nconst base = `voltronic/${inv}`;\nconst state_topic = `${base}/state`;\nconst availability_topic = `${base}/availability`;\nconst set_base = `${base}/set`; // o√π HA publiera les changements\n\nconst device = {\n  identifiers: [`voltronic_inv_${inv}`],\n  name: `Voltronic Inverter ${inv}`,\n  manufacturer: \"Voltronic\",\n  model: \"Axpert/Voltronic\",\n};\n\nfunction sensorCfg(objectId, name, unit, device_class, state_class, valueTpl, extra = {}) {\n  const uid = `voltronic_${inv}_${objectId}`;\n  const topic = `homeassistant/sensor/${uid}/config`;\n\n  const payload = {\n    name,\n    unique_id: uid,\n    state_topic,\n    availability_topic,\n    payload_available: \"online\",\n    payload_not_available: \"offline\",\n    value_template: valueTpl,\n    device,\n    ...extra,\n  };\n\n  if (unit) payload.unit_of_measurement = unit;\n  if (device_class) payload.device_class = device_class;\n  if (state_class) payload.state_class = state_class;\n\n  return { topic, payload: JSON.stringify(payload), retain: true };\n}\n\nfunction binarySensorCfg(objectId, name, device_class, valueTpl, extra = {}) {\n  const uid = `voltronic_${inv}_${objectId}`;\n  const topic = `homeassistant/binary_sensor/${uid}/config`;\n\n  const payload = {\n    name,\n    unique_id: uid,\n    state_topic,\n    availability_topic,\n    payload_available: \"online\",\n    payload_not_available: \"offline\",\n    value_template: valueTpl,\n    device,\n    ...extra,\n  };\n\n  if (device_class) payload.device_class = device_class;\n\n  return { topic, payload: JSON.stringify(payload), retain: true };\n}\n\nfunction selectCfg(objectId, name, options, valueTpl, commandTopic, extra = {}) {\n  const uid = `voltronic_${inv}_${objectId}`;\n  const topic = `homeassistant/select/${uid}/config`;\n\n  const payload = {\n    name,\n    unique_id: uid,\n    state_topic,\n    availability_topic,\n    payload_available: \"online\",\n    payload_not_available: \"offline\",\n    value_template: valueTpl,\n    command_topic: commandTopic,\n    options,\n    device,\n    ...extra,\n  };\n\n  return { topic, payload: JSON.stringify(payload), retain: true };\n}\n\nfunction numberCfg(objectId, name, unit, min, max, step, valueTpl, commandTopic, extra = {}) {\n  const uid = `voltronic_${inv}_${objectId}`;\n  const topic = `homeassistant/number/${uid}/config`;\n\n  const payload = {\n    name,\n    unique_id: uid,\n    state_topic,\n    availability_topic,\n    payload_available: \"online\",\n    payload_not_available: \"offline\",\n    value_template: valueTpl,\n    command_topic: commandTopic,\n    unit_of_measurement: unit,\n    min,\n    max,\n    step,\n    mode: \"box\",\n    device,\n    ...extra,\n  };\n\n  return { topic, payload: JSON.stringify(payload), retain: true };\n}\n\n// =======================\n// 1) CAPTEURS\n// =======================\nconst msgsSensors = [\n  // --- AC\n  sensorCfg(\"ac_output_active_power\", \"AC Output Active Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.ac_output_active_power }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n  sensorCfg(\"ac_output_voltage\", \"AC Output Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.ac_output_voltage }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n  sensorCfg(\"ac_output_frequency\", \"AC Output Frequency\", \"Hz\", \"frequency\", \"measurement\", \"{{ value_json.ac_output_frequency }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n  sensorCfg(\"output_load_percent\", \"Output Load\", \"%\", null, \"measurement\", \"{{ value_json.output_load_percent }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n  sensorCfg(\"operation_mode\", \"Operation Mode\", null, null, null, \"{{ value_json.operation_mode }}\"),\n\n  // --- Batterie (mesures)\n  sensorCfg(\"battery_voltage\", \"Battery Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.battery_voltage }}\", { icon: \"mdi:battery-charging-high\" }),\n  sensorCfg(\"battery_charging_current\", \"Battery Charging Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.battery_charging_current }}\", { icon: \"mdi:battery-arrow-up-outline\" }),\n  sensorCfg(\"battery_discharge_current\", \"Battery Discharge Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.battery_discharge_current }}\", { icon: \"mdi:battery-arrow-down-outline\" }),\n  sensorCfg(\"battery_capacity\", \"Battery Capacity\", \"%\", \"battery\", \"measurement\", \"{{ value_json.battery_capacity }}\", { icon: \"mdi:battery-charging-high\" }),\n\n  // --- Puissances batterie (perso)\n  sensorCfg(\"battery_charge\", \"Battery charge\", \"W\", \"power\", \"measurement\", \"{{ value_json.battery_charge }}\", { icon: \"mdi:battery-arrow-up-outline\" }),\n  sensorCfg(\"battery_discharge\", \"Battery discharge\", \"W\", \"power\", \"measurement\", \"{{ value_json.battery_discharge }}\", { icon: \"mdi:battery-arrow-down-outline\" }),\n  sensorCfg(\"battery_power\", \"Battery power\", \"W\", \"power\", \"measurement\", \"{{ value_json.battery_power }}\", { icon: \"mdi:battery-charging-high\" }),\n\n  // --- PV\n  sensorCfg(\"pv_total_power\", \"PV Total Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.pv_total_power }}\", { icon: \"mdi:solar-power\" }),\n  sensorCfg(\"pv1_power\", \"PV1 Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.pv1_power }}\", { icon: \"mdi:solar-power\" }),\n  sensorCfg(\"pv2_power\", \"PV2 Power\", \"W\", \"power\", \"measurement\", \"{{ value_json.pv2_power }}\", { icon: \"mdi:solar-power\" }),\n  sensorCfg(\"pv1_input_voltage\", \"PV1 Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.pv1_input_voltage }}\"),\n  sensorCfg(\"pv2_input_voltage\", \"PV2 Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.pv2_input_voltage }}\"),\n  sensorCfg(\"pv1_input_current\", \"PV1 Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.pv1_input_current }}\"),\n  sensorCfg(\"pv2_input_current\", \"PV2 Current\", \"A\", \"current\", \"measurement\", \"{{ value_json.pv2_input_current }}\"),\n\n  // --- R√©seau\n  sensorCfg(\"grid_voltage\", \"Grid Voltage\", \"V\", \"voltage\", \"measurement\", \"{{ value_json.grid_voltage }}\", { icon: \"mdi:transmission-tower\" }),\n  // ‚úÖ FIX : tu avais \"}}\" -> corrig√©\n  sensorCfg(\"grid_frequency\", \"Grid Frequency\", \"Hz\", \"frequency\", \"measurement\", \"{{ value_json.grid_frequency }}\", { icon: \"mdi:transmission-tower\" }),\n\n  // --- Temp\n  sensorCfg(\"inverter_heat_sink_temp\", \"Inverter Heatsink Temp\", \"¬∞C\", \"temperature\", \"measurement\", \"{{ value_json.inverter_heat_sink_temp }}\"),\n  sensorCfg(\n  \"grid_power\",\n  \"Grid Power\",\n  \"W\",\n  \"power\",\n  \"measurement\",\n  \"{{ value_json.grid_power }}\",\n  { icon: \"mdi:transmission-tower\" }\n),\n\n\n  // --- ENERGIES\n  sensorCfg(\"load_energy_month_kwh\", \"Load month\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.load_energy_month_kwh }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n  sensorCfg(\"load_energy_year_kwh\", \"Load year\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.load_energy_year_kwh }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n  sensorCfg(\"load_energy_day_kwh\", \"Load today\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.load_energy_day_kwh }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n  sensorCfg(\"load_energy_total_kwh\", \"Load total\", \"kWh\", \"energy\", \"total_increasing\", \"{{ value_json.load_energy_total_kwh }}\", { icon: \"mdi:home-lightning-bolt-outline\" }),\n\n  sensorCfg(\"pv_energy_month_kwh\", \"PV month\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.pv_energy_month_kwh }}\", { icon: \"mdi:solar-power\" }),\n  sensorCfg(\"pv_energy_year_kwh\", \"PV year\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.pv_energy_year_kwh }}\", { icon: \"mdi:solar-power\" }),\n  sensorCfg(\"pv_energy_day_kwh\", \"PV today\", \"kWh\", \"energy\", \"measurement\", \"{{ value_json.pv_energy_day_kwh }}\", { icon: \"mdi:solar-power\" }),\n  sensorCfg(\"pv_energy_total_kwh\", \"PV total\", \"kWh\", \"energy\", \"total_increasing\", \"{{ value_json.pv_energy_total_kwh }}\", { icon: \"mdi:solar-power\" }),\n\n  // =======================\n  // DIAGNOSTIC\n  // =======================\n  sensorCfg(\"diag_model\", \"Inverter Model\", null, null, null, \"{{ value_json.diag.model }}\", { entity_category: \"diagnostic\" }),\n  sensorCfg(\"diag_serial\", \"Inverter Serial\", null, null, null, \"{{ value_json.diag.serial }}\", { entity_category: \"diagnostic\" }),\n  sensorCfg(\"diag_fw_main\", \"Firmware Main\", null, null, null, \"{{ value_json.diag.fw_main }}\", { entity_category: \"diagnostic\" }),\n  sensorCfg(\"diag_fw_remote\", \"Firmware Remote\", null, null, null, \"{{ value_json.diag.fw_remote }}\", { entity_category: \"diagnostic\" }),\n\n  // ‚úÖ NOUVELLES 4 LIGNES (Fault/Warn)\n  sensorCfg(\"diag_fault_state\", \"Fault state\", null, null, null, \"{{ value_json.diag.fault_state }}\", { entity_category: \"diagnostic\", icon: \"mdi:alert-circle\" }),\n  sensorCfg(\"diag_fault_details\", \"Fault details\", null, null, null, \"{{ value_json.diag.fault_details }}\", { entity_category: \"diagnostic\", icon: \"mdi:alert-box-outline\" }),\n  sensorCfg(\"diag_warn_state\", \"Warning state\", null, null, null, \"{{ value_json.diag.warn_state }}\", { entity_category: \"diagnostic\", icon: \"mdi:alert-outline\" }),\n  sensorCfg(\"diag_warn_details\", \"Warning details\", null, null, null, \"{{ value_json.diag.warn_details }}\", { entity_category: \"diagnostic\", icon: \"mdi:text-box-alert-outline\" }),\n];\n\n// ==========================================\n// 2) PARAMETRES\n// ==========================================\nconst baseTplQPIRI = \"value_json.params.qpiri\";\nconst baseTplQDOP = \"value_json.params.qdop\";\n\nconst msgsParams = [\n  selectCfg(\"param_battery_type\", \"Battery type\",\n    [\"AGM\", \"Flooded\", \"User\", \"Lib\", \"Lic\", \"Pylon\", \"Weco\", \"Soltaro\"],\n    `{{ ${baseTplQPIRI}.battery_type }}`,\n    `${set_base}/battery_type`\n  ),\n\n  selectCfg(\"param_output_source_priority\", \"Source priority\",\n    [\"UtilitySolarBat\", \"SolarUtilityBat\", \"SolarBatUtility\"],\n    `{{ ${baseTplQPIRI}.output_source_priority }}`,\n    `${set_base}/output_source_priority`\n  ),\n\n  selectCfg(\"param_charger_source_priority\", \"Charging priority\",\n    [\"Solar first\", \"Solar + Utility\", \"Only solar\"],\n    `{{ ${baseTplQPIRI}.charger_source_priority }}`,\n    `${set_base}/charger_source_priority`\n  ),\n\n  // Voltages\n  numberCfg(\"param_battery_bulk_voltage\", \"Bulk\", \"V\", 40, 65, 0.1,\n    `{{ ${baseTplQPIRI}.battery_bulk_voltage }}`, `${set_base}/battery_bulk_voltage`\n  ),\n  numberCfg(\"param_battery_float_voltage\", \"Float\", \"V\", 40, 65, 0.1,\n    `{{ ${baseTplQPIRI}.battery_float_voltage }}`, `${set_base}/battery_float_voltage`\n  ),\n  numberCfg(\"param_battery_re_discharge_voltage\", \"Re-discharge voltage\", \"V\", 40, 65, 0.1,\n    `{{ ${baseTplQPIRI}.battery_re_discharge_voltage }}`, `${set_base}/battery_re_discharge_voltage`\n  ),\n  numberCfg(\"param_battery_recharge_voltage\", \"Return grid V\", \"V\", 40, 65, 0.1,\n    `{{ ${baseTplQPIRI}.battery_recharge_voltage }}`, `${set_base}/battery_recharge_voltage`\n  ),\n  numberCfg(\"param_battery_under_voltage\", \"Under voltage\", \"V\", 40, 65, 0.1,\n    `{{ ${baseTplQPIRI}.battery_under_voltage }}`, `${set_base}/battery_under_voltage`\n  ),\n\n  // Currents (discrets)\n  selectCfg(\"param_max_ac_charging_current\", \"Grid charging current\",\n    [\"2\", \"10\", \"20\", \"30\", \"40\", \"50\", \"60\", \"70\", \"80\", \"90\", \"100\", \"110\", \"120\", \"130\", \"140\", \"150\"],\n    `{{ ${baseTplQPIRI}.max_ac_charging_current }}`,\n    `${set_base}/max_ac_charging_current`,\n    { icon: \"mdi:transmission-tower\" }\n  ),\n  selectCfg(\"param_max_charging_current\", \"Max charging current\",\n    [\"10\", \"20\", \"30\", \"40\", \"50\", \"60\", \"70\", \"80\", \"90\", \"100\", \"110\", \"120\", \"130\", \"140\", \"150\"],\n    `{{ ${baseTplQPIRI}.max_charging_current }}`,\n    `${set_base}/max_charging_current`,\n    { icon: \"mdi:battery-charging\" }\n  ),\n  selectCfg(\"param_max_discharging_current\", \"Max discharging current\",\n    [\"10\", \"20\", \"30\", \"40\", \"50\", \"60\", \"70\", \"80\", \"90\", \"100\", \"110\", \"120\", \"130\", \"140\", \"150\"],\n    `{{ ${baseTplQPIRI}.max_discharging_current }}`,\n    `${set_base}/max_discharging_current`,\n    { icon: \"mdi:battery-arrow-down\" }\n  ),\n\n  // QDOP % (5%)\n  numberCfg(\"param_battery_recharge_capacity_pct\", \"Return grid %\", \"%\", 0, 100, 5,\n    `{{ ${baseTplQDOP}.battery_recharge_capacity_pct }}`, `${set_base}/battery_recharge_capacity_pct`\n  ),\n  numberCfg(\"param_battery_redischarge_capacity_pct\", \"Return battery %\", \"%\", 0, 100, 5,\n    `{{ ${baseTplQDOP}.battery_redischarge_capacity_pct }}`, `${set_base}/battery_redischarge_capacity_pct`\n  ),\n  numberCfg(\"param_battery_under_capacity_pct\", \"Battery under capacity %\", \"%\", 0, 100, 5,\n    `{{ ${baseTplQDOP}.battery_under_capacity_pct }}`, `${set_base}/battery_under_capacity_pct`\n  ),\n];\n\nconst msgs = [...msgsSensors, ...msgsParams];\nreturn [msgs];\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 320,
        "wires": [
            [
                "b49da1eb9e7aeb60"
            ]
        ]
    },
    {
        "id": "b49da1eb9e7aeb60",
        "type": "mqtt out",
        "z": "296b81230a5aed2a",
        "g": "8b109ad885d98582",
        "name": "üì° MQTT Out",
        "topic": "",
        "qos": "0",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "mqtt_broker",
        "x": 700,
        "y": 320,
        "wires": []
    },
    {
        "id": "fd3b9f314f1f6121",
        "type": "inject",
        "z": "296b81230a5aed2a",
        "g": "8b109ad885d98582",
        "name": "‚è∞ Au d√©marrage",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 170,
        "y": 320,
        "wires": [
            [
                "05595a6f316d37e4"
            ]
        ]
    },
    {
        "id": "48bb9a525694ed98",
        "type": "global-config",
        "env": [],
        "modules": {
            "node-red-node-serialport": "2.0.3"
        }
    }
]